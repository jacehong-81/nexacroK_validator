//==============================================================================
//
//  TOBESOFT Co., Ltd.
//  Copyright 2017 TOBESOFT Co., Ltd.
//  All Rights Reserved.
//
//  NOTICE: TOBESOFT permits you to use, modify, and distribute this file 
//          in accordance with the terms of the license agreement accompanying it.
//
//  Readme URL: http://www.nexacro.co.kr/legal/nexacro17-public-license-readme-1.1.html	
//
//==============================================================================

if (!nexacro.Grid)
{
    //==============================================================================
    // nexacro.Grid eventinfo
    //==============================================================================
    nexacro.GridLongPressEventInfo = function (obj, id, pointinfos, from_comp, from_refer_comp, cell, col, row, subrow, pivotindex, mergecell, mergecol, mergerow)
    {
        nexacro.LongPressEventInfo.call(this, obj, id, pointinfos, from_comp, from_refer_comp);

        this.cell = cell;
        this.col = col;
        this.row = row;
        this.subrow = subrow;
        this.pivotindex = pivotindex;
        this.mergecell = mergecell;
        this.mergecol = mergecol;
        this.mergerow = mergerow;
    };
    var _pGridLongPressEventInfo = nexacro._createPrototype(nexacro.LongPressEventInfo, nexacro.GridLongPressEventInfo);
    nexacro.GridLongPressEventInfo.prototype = _pGridLongPressEventInfo;
    _pGridLongPressEventInfo._type_name = "GridLongPressEventInfo";

    _pGridLongPressEventInfo = null;

    nexacro.GridDragEventInfo = function (obj, id, dragdata, userdata, datatype, filelist, src_comp, src_refer_comp, from_comp, from_refer_comp,
        button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, cell, col, mergecell, mergecol, mergerow, pivotindex, row, subrow, meta_key)
    {
        nexacro.DragEventInfo.call(this, obj, id || "ongriddrag", dragdata, userdata, datatype, filelist, src_comp, src_refer_comp, from_comp, from_refer_comp, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, meta_key);

        this.cell = cell;
        this.col = col;
        this.row = row;
        this.subrow = subrow;
        this.pivotindex = pivotindex;
        this.mergecell = mergecell;
        this.mergecol = mergecol;
        this.mergerow = mergerow;
    };
    var _pGridDragEventInfo = nexacro._createPrototype(nexacro.DragEventInfo, nexacro.GridDragEventInfo);
    nexacro.GridDragEventInfo.prototype = _pGridDragEventInfo;
    _pGridDragEventInfo._type_name = "GridDragEventInfo";

    _pGridDragEventInfo = null;

    nexacro.GridClickEventInfo = function (obj, id, beforeCell, beforeCol, beforeRow, beforeSubrow, beforePvt, afterCell, afterCol, afterRow, afterSubrow, afterPvt, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        nexacro.ClickEventInfo.call(this, obj, id || "ongridclick", button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);

        this.cell = afterCell;
        this.col = afterCol;
        this.row = afterRow;
        this.subrow = afterSubrow;
        this.pivotindex = afterPvt;
        this.oldcell = beforeCell;
        this.oldcol = beforeCol;
        this.oldrow = beforeRow;
        this.oldsubrow = beforeSubrow;
        this.oldpivotindex = beforePvt;
    };
    var _pGridClickEventInfo = nexacro._createPrototype(nexacro.ClickEventInfo, nexacro.GridClickEventInfo);
    nexacro.GridClickEventInfo.prototype = _pGridClickEventInfo;
    _pGridClickEventInfo._type_name = "GridClickEventInfo";
    _pGridClickEventInfo._is_event = true;
    _pGridClickEventInfo = null;

    nexacro.GridEditEventInfo = function (obj, id, cell, col, pivotindex, row, subrow, value)
    {
        this.id = this.eventid = id || "ongridedit";
        this.fromobject = this.fromreferenceobject = obj;
        this.cell = cell;
        this.col = col;
        this.row = row;
        this.subrow = subrow;
        this.pivotindex = pivotindex;
        this.value = value;
    };
    var _pGridEditEventInfo = nexacro._createPrototype(nexacro.Event, nexacro.GridEditEventInfo);
    nexacro.GridEditEventInfo.prototype = _pGridEditEventInfo;
    _pGridEditEventInfo._type_name = "GridEditEventInfo";

    _pGridEditEventInfo = null;

    nexacro.GridKeyEventInfo = function (obj, id, cell, col, pivotindex, row, subrow, alt_key, ctrl_key, shift_key, key_code, meta_key)
    {
        this.id = this.eventid = id || "ongridkeyevent";
        this.fromobject = this.fromreferenceobject = obj;
        this.cell = cell;
        this.col = col;
        this.row = row;
        this.subrow = subrow;
        this.pivotindex = pivotindex;

        this.altkey = alt_key;
        this.ctrlkey = ctrl_key;
        this.shiftkey = shift_key;
        this.metakey = meta_key;
        this.keycode = key_code;
    };
    var _pGridKeyEventInfo = nexacro._createPrototype(nexacro.Event, nexacro.GridKeyEventInfo);
    nexacro.GridKeyEventInfo.prototype = _pGridKeyEventInfo;
    _pGridKeyEventInfo._type_name = "GridKeyEventInfo";
    /*
    nexacro.GridCellCustomControlEventInfo = function (obj, id, cell, col, pivotindex, row, subrow, e)
    {
        this.id = this.eventid = id;
        this.fromobject = this.fromreferenceobject = obj;
        this.cell = cell;
        this.col = col;
        this.row = row;
        this.subrow = subrow;
        this.pivotindex = pivotindex;
        this.customcontrolevent = e;
    };
    var _pGridCellCustomControlEventInfo = nexacro._createPrototype(nexacro.Event, nexacro.GridCellCustomControlEventInfo);
    nexacro.GridCellCustomControlEventInfo.prototype = _pGridCellCustomControlEventInfo;
    _pGridCellCustomControlEventInfo._type_name = "GridCellCustomControlEventInfo";
    */

    //==============================================================================
    // nexacro.GridInputEventInfo
    //==============================================================================
    nexacro.GridInputEventInfo = function (obj, cell, col, row, subrow, pivotindex, id)
    {
        this.id = this.eventid = id || "oninput";
        this.fromobject = this.fromreferenceobject = obj;
        this.cell = cell;
        this.col = col;
        this.row = row;
        this.subrow = subrow;
        this.pivotindex = pivotindex;
    };
    var _pGridInputEventInfo = nexacro._createPrototype(nexacro.Event, nexacro.GridInputEventInfo);
    nexacro.GridInputEventInfo.prototype = _pGridInputEventInfo;
    _pGridInputEventInfo._type_name = "GridInputEventInfo";

    _pGridInputEventInfo = null;

    nexacro.GridFormatChangedEventInfo = function (obj, id, newvalue, oldvalue, reason)
    {
        this.id = this.eventid = id || "ongridformatchanged";
        this.fromobject = this.fromreferenceobject = obj;
        this.newvalue = newvalue;
        this.oldvalue = oldvalue;
        this.reason = reason;
    };
    var _pGridFormatChangedEventInfo = nexacro._createPrototype(nexacro.Event, nexacro.GridFormatChangedEventInfo);
    nexacro.GridFormatChangedEventInfo.prototype = _pGridFormatChangedEventInfo;
    _pGridFormatChangedEventInfo._type_name = "GridFormatChangedEventInfo";

    _pGridFormatChangedEventInfo = null;

    nexacro.GridSelectEventInfo = function (obj, id, cell, col, row, subrow, pivotindex, oldcell, oldcol, oldrow, oldsubrow, oldpivotindex,
        selectendcol, selectendpivot, selectendrow, selectendsubrow, selectstartcol, selectstartpivot, selectstartrow, selectstartsubrow)
    {
        this.id = this.eventid = id || "ongridselect";
        this.fromobject = this.fromreferenceobject = obj;

        this.cell = cell;
        this.col = col;
        this.row = row;
        this.subrow = subrow;
        this.pivotindex = pivotindex;

        this.oldcell = oldcell;
        this.oldcol = oldcol;
        this.oldrow = oldrow;
        this.oldpivotindex = oldpivotindex;
        this.oldsubrow = oldsubrow;

        this.selectendcol = selectendcol;
        this.selectendpivot = selectendpivot;
        this.selectendrow = selectendrow;
        this.selectendsubrow = selectendsubrow;

        this.selectstartcol = selectstartcol;
        this.selectstartpivot = selectstartpivot;
        this.selectstartrow = selectstartrow;
        this.selectstartsubrow = selectstartsubrow;
    };
    var _pGridSelectEventInfo = nexacro._createPrototype(nexacro.Event, nexacro.GridSelectEventInfo);
    nexacro.GridSelectEventInfo.prototype = _pGridSelectEventInfo;
    _pGridSelectEventInfo._type_name = "GridSelectEventInfo";

    _pGridSelectEventInfo = null;

    nexacro.GridTreeStatusEventInfo = function (obj, id, cell, realrow, row, reason)
    {
        this.id = this.eventid = id || "ongridtreestatus";
        this.fromobject = this.fromreferenceobject = obj;
        this.cell = cell;
        this.realrow = realrow;
        this.row = row;
        this.reason = reason;
    };
    var _pGridTreeStatusEventInfo = nexacro._createPrototype(nexacro.Event, nexacro.GridTreeStatusEventInfo);
    nexacro.GridTreeStatusEventInfo.prototype = _pGridTreeStatusEventInfo;
    _pGridTreeStatusEventInfo._type_name = "GridTreeStatusEventInfo";

    _pGridTreeStatusEventInfo = null;

    nexacro.GridMouseEventInfo = function (obj, id, cell, col, mergecell, mergecol, mergerow, pivotindex, row, subrow, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        nexacro.MouseEventInfo.call(this, obj, id || "ongridmouse", button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);

        this.cell = cell;
        this.col = col;
        this.mergecell = mergecell;
        this.mergecol = mergecol;
        this.mergerow = mergerow;
        this.pivotindex = pivotindex;
        this.row = row;
        this.subrow = subrow;
    };
    var _pGridMouseEventInfo = nexacro._createPrototype(nexacro.MouseEventInfo, nexacro.GridMouseEventInfo);
    nexacro.GridMouseEventInfo.prototype = _pGridMouseEventInfo;
    _pGridMouseEventInfo._type_name = "GridMouseEventInfo";

    _pGridMouseEventInfo = null;

    nexacro.GridContextMenuEventInfo = function (obj, id, cell, col, mergecell, mergecol, mergerow, pivotindex, row, subrow, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        nexacro.ContextMenuEventInfo.call(this, obj, id, from_comp, from_refer_comp, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, meta_key);

        this.cell = cell;
        this.col = col;
        this.mergecell = mergecell;
        this.mergecol = mergecol;
        this.mergerow = mergerow;
        this.pivotindex = pivotindex;
        this.row = row;
        this.subrow = subrow;
    };
    var _pGridContextMenuEventInfo = nexacro._createPrototype(nexacro.MouseEventInfo, nexacro.GridContextMenuEventInfo);
    nexacro.GridContextMenuEventInfo.prototype = _pGridContextMenuEventInfo;
    _pGridContextMenuEventInfo._type_name = "GridContextMenuEventInfo";

    _pGridContextMenuEventInfo = null;

    nexacro.GridSizeChangedEventInfo = function (obj, id, formatindex, index, newvalue, oldvalue, reason, subindex)
    {
        this.id = this.eventid = id || "ongridsizechanged";
        this.fromobject = this.fromreferenceobject = obj;
        this.eventid = id;
        this.formatindex = formatindex;
        this.index = index;
        this.newvalue = newvalue;
        this.oldvalue = oldvalue;
        this.reason = reason;
        this.subindex = subindex;
    };

    var _pGridSizeChangedEventInfo = nexacro._createPrototype(nexacro.Event, nexacro.GridSizeChangedEventInfo);
    nexacro.GridSizeChangedEventInfo.prototype = _pGridSizeChangedEventInfo;
    _pGridSizeChangedEventInfo._type_name = "GridSizeChangedEventInfo";

    _pGridSizeChangedEventInfo = null;

    nexacro.GridHeadValueChangedEventInfo = function (obj, id, oldvalue, newvalue, cell)
    {
        this.id = this.eventid = id || "onheadvaluechanged";

        this.fromobject = this.fromreferenceobject = obj;
        this.eventid = id;
        this.cell = cell;
        this.newvalue = newvalue;
        this.oldvalue = oldvalue;
    };

    var _pGridHeadValueChangedEventInfo = nexacro._createPrototype(nexacro.Event, nexacro.GridHeadValueChangedEventInfo);
    nexacro.GridHeadValueChangedEventInfo.prototype = _pGridHeadValueChangedEventInfo;
    _pGridHeadValueChangedEventInfo._type_name = "GridHeadValueChangedEventInfo";

    _pGridHeadValueChangedEventInfo = null;

    nexacro.GridHTMLControlApplyValueEventInfo = function (obj, id, value, band, cell, rootnode)
    {
        this.id = this.eventid = id;
        this.fromobject = this.fromreferenceobject = obj;
        this.eventid = id || "onhtmlcontrolapplyvalue";
        this.band = band;
        this.cell = cell;
        this.value = value;
        this.rootnode = rootnode;
    };

    var _pGridHTMLControlApplyValueEventInfo = nexacro._createPrototype(nexacro.Event, nexacro.GridHTMLControlApplyValueEventInfo);
    nexacro.GridHTMLControlApplyValueEventInfo.prototype = _pGridHTMLControlApplyValueEventInfo;
    _pGridHTMLControlApplyValueEventInfo._type_name = "GridHTMLControlApplyValueEventInfo";
    _pGridHTMLControlApplyValueEventInfo = null;

    //==============================================================================
    // nexacro.GridImageErrorEventInfo
    //==============================================================================
    nexacro.GridImageErrorEventInfo = function (obj, id, errortype, errormsg, requesturi, row, cell)
    {
        this.id = this.eventid = id || "onimageerror";

        this.errortype = errortype;
        this.errormsg = errormsg;
        this.errorobj = obj;

        this.requesturi = requesturi;
        this.row = row;
        this.cell = cell;
    };
    var _pGridImageErrorEventInfo = nexacro._createPrototype(nexacro.ErrorEventInfo, nexacro.GridImageErrorEventInfo);
    nexacro.GridImageErrorEventInfo.prototype = _pGridImageErrorEventInfo;
    _pGridImageErrorEventInfo._type_name = "GridImageErrorEventInfo";

    _pGridImageErrorEventInfo = null;

    //==============================================================================
    // nexacro._GridCellControl
    // this Component has no Own styles -- reference to ref_object
    //==============================================================================
    nexacro._GridCellControl = function (id, left, top, width, height, right, bottom, parent, refinfo, rowidx, cellidx)
    {
        this._grid = refinfo ? refinfo._grid : null;

        nexacro._CellControl.call(this, id, left, top, width, height, right, bottom, parent, refinfo, cellidx, this._grid, rowidx);

        if (parent)
            this._band = parent._band;
        else
            this._band = null;

        this._clickcall = false;
        this._is_clickproc = false;
        this._refresh_display = false;

        // override child control
        this._cellExpandObj = "_GridExpandControl";
        this._cellFilterIconObj = "_GridFilterIconControl";
        this._cellButtonObj = "_GridButtonControl";
        this._cellCheckBoxObj = "_GridCheckboxControl";
        this._cellImageObj = "_GridImageControl";
        this._cellComboObj = "_GridComboControl";
        this._cellMultiComboObj = "_GridMultiComboControl";
        this._cellCalendarObj = "_GridCalendarControl";
        this._cellEditObj = "_GridEditControl";
        this._cellTextAreaObj = "_GridTextAreaControl";
        this._cellProgressBarObj = "_GridProgressBarControl";
        this._cellMaskEditObj = "_GridMaskEditControl";
        this._cellTreeObj = "_CellTreeItemControl";
        this._cellRadioItemObj = "_GridRadioItemControl";
        this._cellHTMLControlObj = "_GridHTMLControl";
        this._cellRowGroupExpandObj = "_cellRowGroupItemControl";

        if (this._env._p_enableaccessibility && refinfo)
        {
            var dispaytype = refinfo._getDisplaytype(rowidx);
            if (dispaytype == "treeitemcontrol" || dispaytype == "rowgroupcontrol")
                this._skip_mobile_tabfocus = true;
        }

    };

    var _pGridCell = nexacro._createPrototype(nexacro._CellControl, nexacro._GridCellControl);
    nexacro._GridCellControl.prototype = _pGridCell;
    _pGridCell._is_subcontrol = true;
    _pGridCell._type_name = "GridCellControl";


    _pGridCell._getDataRow = function ()
    {
        var grid = this._grid;
        if (grid)
        {
            var datarow = grid._getDataRow(this._rowidx);
            return datarow;
        }
        else
            return this._rowidx;
    };

    _pGridCell._isFakeCell = function ()
    {
        var grid = this._grid;
        return grid._isFakeCell(this._rowidx);
    };

    _pGridCell._setDisplay = function (v)
    {
        if (this._control_element && !this._is_tempcell)
        {
            this._control_element.setElementDisplay((v) ? "" : "none");
        }
    };

    //==============================================================================
    // nexacro._GridCellControl : Create & Destroy & Update    
    //==============================================================================
    // tree change status 시 cell 사라지는 문제때문에 임시 조치 : by odh
    _pGridCell.destroy = function ()
    {
        if (this._grid)
        {
            if (this._tree_lbuttondown && this._grid)
            {
                this._grid._lbuttondown_treecell = this;
                nexacro._OnceCallbackTimer.callonce(this._grid, function ()
                {
                    // this : grid
                    if (this._lbuttondown_treecell)
                        this._lbuttondown_treecell.destroy();
                }, 10);
                return;
            }

            if (this._grid._lbuttondown_treecell == this)
            {
                this._grid._lbuttondown_treecell = null;
            }
        }
        nexacro.Component.prototype.destroy.call(this);

        this._virtualmerge = null;
        this._grid = null;
        this._band = null;
    };

    _pGridCell.on_destroy_contents = function ()
    {
        if (this._editor)
        {
            if (this._editor == this._grid._currentCellEditor)
                this._grid._hideEditor();
        }
        nexacro._CellControl.prototype.on_destroy_contents.call(this);
    };

    //==============================================================================
    // nexacro._GridCellControl : Override
    //==============================================================================
    _pGridCell._on_apply_status = function (oldstatus, status, olduserstatus, userstatus, apply, status_param, value_param, applycssstatus, applycssuserstatus)
    {
        nexacro.Component.prototype._on_apply_status.call(this, oldstatus, status, olduserstatus, userstatus, apply, status_param, value_param, applycssstatus, applycssuserstatus);

        var control_elem = this._control_element;
        if (control_elem && this._isRtl())
        {
            control_elem._refreshBorderNone();
        }

        var grid = this._grid;
        var datarow = grid._getDataRow(this._rowidx);

        if (grid._isFakeCell(datarow))
        {
            this._changeStatus("mouseover", false);
            this._changeStatus("focused", false);
            return;
        }
    };

    _pGridCell._on_focus = function (self_flag, evt_name, lose_focus, refer_lose_focus, new_focus, refer_new_focus)
    {
        this._grid._focused_row = this._getDataRow();
        this._grid._focused_cell = this._cellidx;
        nexacro.Component.prototype._on_focus.call(this, self_flag, evt_name, lose_focus, refer_lose_focus, new_focus, refer_new_focus);
    };

    // _changeStatus -> _on_changeStatus -> on_changeStatus
    _pGridCell._on_changeStatus = function (status, value)
    {
        var grid = this._grid;
        if (status == "focused")
        {
            if (grid._isSelectRowType())
            {
                if (value == false)
                {
                    if (grid._focused_row == this._getDataRow())
                        return;
                }
                else if (this.selected)
                {
                    if (!this._rowstatuschange)
                        grid._on_apply_cell_status(this, status, true);
                }
            }
        }
        this._status_changing = true;

        var old = this._status;
        nexacro.Component.prototype._on_changeStatus.call(this, status, value);

        if (old != this._status)
        {
            if (!this._is_tempcell)
                this._applyVirtualMergeCellStyle({ status: status, value: value }, (old != ""));
        }

        this._status_changing = false;
    };

    _pGridCell.on_changeStatus = function (changestatus, value, applystatus, currentstatus, currentuserstatus)
    {
        if (this._getRowControl()._floating)
            return "enabled";

        return applystatus;
    };

    _pGridCell.on_changeUserStatus = function (changestatus, value, applyuserstatus, currentstatus, currentuserstatus)
    {
        if (this._getRowControl()._floating)
            return "";

        if (changestatus == "blinked" && value)
            return changestatus;

        //      this._applyVirtualMergeCellStyle(); 반영안되는 문제 있을시 해제
        return applyuserstatus;
    };

    _pGridCell.on_apply_status = function (status, userstatus, status_param, value_param)
    {
        if (!this._rowstatuschange)
        {
            // selected는 따로 처리함.
            if (status_param == "mouseover" || status_param == "focused")
                this._grid._on_apply_cell_status(this, status_param, value_param);
        }
    };

    _pGridCell._getClassCSSSelector = function ()
    {
        var cssarr;
        if (this._getRowControl()._floating)
            cssarr = nexacro.Component.prototype._getClassCSSSelector.call(this);
        else
            cssarr = nexacro._CellControl.prototype._getClassCSSSelector.call(this);

        return cssarr;
    };

    _pGridCell._apply_setfocus = function (evt_name, self_flag)
    {
        nexacro._CellControl.prototype._apply_setfocus.call(this, evt_name, self_flag);

        var control_elem = this._control_element;
        /*
        if (evt_name == "lbuttondown")   // cell click시 scroll움직임 방지
        {
            this._grid._focus_proc = control_elem;
            this._grid._control_element.setElementFocus(false);            
        }
        else
        {
            if (control_elem)
                control_elem.setElementFocus(false);
        }*/

        if (evt_name == "lbuttondown")
        {
            this._grid._focus_proc = control_elem;
        }

        /* accessibility */
        if (this._env._p_enableaccessibility)
        {
            this._grid._p_currentcell = this._cellidx;
            this._grid._currentBand = this._band.id;
        }
    };

    _pGridCell._on_last_lbuttonup = function ()
    {
        if (this.parent)
            this.parent._on_last_lbuttonup();
    };

    _pGridCell._on_last_keyup = function ()
    {
        if (this.parent)
        {

            var grid = this._grid;
            var lastfocus = grid._find_lastFocused();
            var isfocused = true;
            if (grid)
            {
                isfocused = (lastfocus == grid) ? true : false;
                if (isfocused && !grid._showEditing && grid._is_data_enter_apply)
                {
                    this._setFocus(false);
                }
            }
            this.parent._on_last_keyup();
        }
    };

    _pGridCell._on_killfocus = function (/*new_focus, new_ref_focus*/)
    {
        this._setAccessibilityStatFlag(this._status, this._pseudo);
        if (this._env._p_enableaccessibility)
        {
            if (nexacro._OS == "Android" && nexacro._Browser != "Runtime")
                this._setAccessibilityStatLive(false);
        }
    };

    _pGridCell._getTreeStatus = function ()
    {
        return this._grid.getTreeStatus(this._rowidx);
    };

    _pGridCell._resetScrollPos = function (target_comp, left, top, right, bottom, focus_direction)
    {
        /* adjust scroll position */
        var grid = this._grid;
        if (grid)
        {
            if (this._env._p_enableaccessibility && this._env._a11ytype == 5 && grid._scrollbars == 0)
            {
                var row = this.parent;
                if (row)
                {
                    row._showfull(this);
                    top = row._adjust_top;
                }
                bottom = top + this._adjust_height;
                nexacro.Component.prototype._resetScrollPos.call(this, target_comp, left, top, right, bottom, focus_direction);
            }
        }
    };

    //==============================================================================
    // nexacro._GridCellControl : Event Handlers
    //==============================================================================
    _pGridCell._common_lbuttonup = function (changedtouchinfos, elem, canvasX, canvasY, from_elem)
    {
        if (changedtouchinfos)
        {
            var touchinfo = nexacro._getFirstTouchInfo(changedtouchinfos);

            if (touchinfo)
            {
                elem = touchinfo._elem;
                canvasX = touchinfo.canvasx;
                canvasY = touchinfo.canvasy;
                from_elem = elem;
            }
        }

        if (elem != from_elem)
        {
            var upelem = this._is_real_upelem = from_elem;
            var grid = this._grid;
            var is_inGridElem = false;

            while (upelem)
            {
                if (upelem._type_name == "GridCellControl")
                {
                    grid._lastmouseentercell = upelem;
                }
                if (upelem instanceof nexacro.Grid)
                {
                    is_inGridElem = true;
                    break;
                }
                upelem = upelem.parent;
            }

            if (!upelem) //grid 내부에서 down 외부에서 up되었을때 upelem이 undefined
            {
                this._is_real_upelem = upelem;
            }
        }
        return true;
    };

    _pGridCell._on_touchend = function (touch_manager, touchinfos, changedtouchinfos)
    {
        if (this._common_lbuttonup(changedtouchinfos, null, null, null, null))
            nexacro.Component.prototype._on_touchend.call(this, touch_manager, touchinfos, changedtouchinfos);
    };

    _pGridCell._on_lbuttonup = function (elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, from_elem, meta_key)
    {
        if (this._common_lbuttonup(null, elem, canvasX, canvasY, from_elem))
            nexacro.Component.prototype._on_lbuttonup.call(this, elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, from_elem, meta_key);

        return true;
    };

    _pGridCell._common_mouseenter = function (from_comp)
    {
        if (!this._is_alive) return false;

        var grid = this._grid;
        var datarow = grid._getDataRow(this._rowidx);

        if (grid._isFakeCell(datarow))
            return false;

        if (from_comp != this)
        {
            if (this.parentcell)
            {
                grid._mouseovercell = { row: this.parentcell._rowidx, cell: this.parentcell._cellidx };
                grid._lastmouseentercell = this.parentcell;
            }
            else
            {
                grid._mouseovercell = { row: this._rowidx, cell: this._cellidx };
                grid._lastmouseentercell = this;
            }

            return true;
        }
        return true;
    };

    _pGridCell._on_mouseenter = function (elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, meta_key)
    {
        if (this._isSubCell)
        {
            return nexacro.Component.prototype._on_mouseenter.call(this, elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, meta_key);
        }
        else if (this._common_mouseenter(from_comp))
        {
            return nexacro.Component.prototype._on_mouseenter.call(this._grid._lastmouseentercell, elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, meta_key);
        }
    };

    _pGridCell._common_mouseleave = function (to_comp)
    {
        if (!this._is_alive) return false;

        var grid = this._grid;
        var datarow = grid._getDataRow(this._rowidx);

        grid._setGlobalCursor(null, this, this);

        if (grid._isFakeCell(datarow))
            return false;

        if (to_comp != this)
        {
            grid._mouseovercell = null;
            return true;
        }
        return false;
    };

    _pGridCell._on_mouseleave = function (elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, meta_key)
    {
        if (this._isSubCell)
        {
            return nexacro.Component.prototype._on_mouseleave.call(this, elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, meta_key);
        }
        else if (this._common_mouseleave(to_comp))
        {
            if (!this._grid._lastmouseentercell)        // popup시 mouseenter가 수행이 안되고 leave만 발생하는 경우가 있음.
                this._grid._lastmouseentercell = this;

            return nexacro.Component.prototype._on_mouseleave.call(this._grid._lastmouseentercell, elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, meta_key);
        }
    };

    _pGridCell._common_fire_lbuttondown = function (from_comp)
    {
        var grid = this._grid;
        var datarow = grid._getDataRow(this._rowidx);
        this._is_clickproc = false;
        this._clickcall = false;

        grid._lastmouseentercell = this;

        if (!grid || grid._isFakeCell(datarow))
            return false;

        if (this._refinfo._isSubCell)
            return this.parent._common_fire_lbuttondown(from_comp);

        if (!this._is_mergetemp)
        {
            if (this._band.id == "head" || this._band.id == "body")
            {
                var show = false;
                if (this._band.id == "head")
                {
                    // head click시 autoenter select 속성에 영향을 받아 바로 열리도록 기능 확장
                    if (!grid._showEditing || grid._p_autoenter === "select")
                    {
                        show = true;
                    }
                }
                else if (this._band.id == "body")
                {
                    if ((datarow != grid._selectinfo.curdsrow) || (this._cellidx != grid._selectinfo.curcell))
                    {
                        // body select status 위치가 변경된 경우
                        if (grid._p_autoenter == "select")
                            show = true;
                    }
                    else
                    {
                        // body select status 위치가 변경지 않은 경우
                        if (!grid._showEditing)
                        {
                            show = true;
                        }
                        else if (grid._p_autoenter == "select")
                        {
                            // select status가 변경되지 않았는데 headcell -> bodycell 이동한경우
                            if (grid._showEditRowIdx == -1 && grid._showEditCellIdx > -1)
                            {
                                show = true;
                            }
                        }
                    }
                }

                if (show)
                {
                    grid._tryShowEditorCell = true;
                    grid._showEditRowIdx = datarow;
                    grid._showEditCellIdx = this._cellidx;
                }
            }
            else
            {
                if ((datarow != grid._selectinfo.curdsrow) || (this._cellidx != grid._selectinfo.curcell))
                {
                    if (grid._showEditing)
                    {
                        grid._hideEditor();
                    }
                }
            }
        }
    };

    _pGridCell.on_fire_user_ontouchstart = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        this._common_fire_lbuttondown(from_comp);

        var parent = this._grid.parent;
        var touchinfo = nexacro._getFirstTouchInfo(changedtouchinfos);
        var subcomp = from_refer_comp;

        while (subcomp && subcomp instanceof nexacro.Component)
        {
            if (subcomp instanceof nexacro._GridCellControl)
                break;

            var canvas = subcomp._getRecalcCanvasXY(from_refer_comp._control_element, touchinfo.canvasx, touchinfo.canvasy);
            touchinfo.canvasx = canvas[0];
            touchinfo.canvasy = canvas[1];

            if (this._subComp == subcomp)
                break;

            subcomp = subcomp.parent;
        }

        if (this._isSubCell)
        {
            touchinfo.canvasx += this._adjust_left;
            touchinfo.canvasy += this._adjust_top;
            touchinfo.clientx += this._adjust_left;
            touchinfo.clienty += this._adjust_top;
        }

        if (this._subComp == from_comp)
        {
            var padding = this._getCurrentStylePadding();
            if (padding)
            {
                touchinfo.canvasx += padding.left;
                touchinfo.canvasy += padding.top;
                touchinfo.clientx += padding.left;
                touchinfo.clienty += padding.top;
            }
        }

        var retn = this._grid.on_fire_user_ontouchstart(touchinfos, changedtouchinfos, from_comp, from_refer_comp, true);

        var canvas_new = this._grid._getRecalcCanvasXY(from_refer_comp._control_element, touchinfo.canvasx, touchinfo.canvasy);
        touchinfo.canvasx = canvas_new[0];
        touchinfo.canvasy = canvas_new[1];

        var clientXY_new = this._getClientXY(touchinfo.clientx, touchinfo.clienty);
        touchinfo.clientx = clientXY_new[0];
        touchinfo.clienty = clientXY_new[1];

        if (!retn)
        {
            while (parent)
            {
                if (parent.on_fire_user_ontouchstart)
                {
                    retn = parent.on_fire_user_ontouchstart(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
                    if (retn)
                        break;
                }
                parent = parent.parent;
            }
        }
        return true;
    };

    _pGridCell.on_fire_user_onlbuttondown = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        var subcomp = from_refer_comp;
        var grid = this._grid;
        while (subcomp && subcomp instanceof nexacro.Component)
        {
            if (subcomp instanceof nexacro._GridCellControl)
                break;

            var canvas = subcomp._getRecalcCanvasXY(from_refer_comp._control_element, canvasX, canvasY);
            canvasX = canvas[0];
            canvasY = canvas[1];

            if (this._subComp == subcomp)
                break;

            subcomp = subcomp.parent;
        }

        this._common_fire_lbuttondown(from_comp);

        var parent = this._grid.parent;

        if (this._isSubCell)
        {
            canvasX += this._adjust_left;
            canvasY += this._adjust_top;
            clientX += this._adjust_left;
            clientY += this._adjust_top;
        }

        if (this._subComp == from_comp)
        {
            var padding = this._getCurrentStylePadding();
            if (padding)
            {
                canvasX += padding.left;
                canvasY += padding.top;
                clientX += padding.left;
                clientY += padding.top;
            }
        }
        grid._buttondowntime = Date.now();
        var retn = grid.on_fire_user_onlbuttondown(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key, true);
        var canvas_new = grid._getRecalcCanvasXY(from_refer_comp._control_element, canvasX, canvasY);
        canvasX = canvas_new[0];
        canvasY = canvas_new[1];

        var clientXY_new = this._getClientXY(canvasX, clientY);
        clientX = clientXY_new[0];
        clientY = clientXY_new[1];

        if (!retn)
        {
            while (parent)
            {
                if (parent.on_fire_user_onlbuttondown)
                {
                    retn = parent.on_fire_user_onlbuttondown(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
                    if (retn)
                        break;
                }
                parent = parent.parent;
            }
        }
        return true;
    };

    _pGridCell._common_fire_lbuttonup = function (touchinfos, changedtouchinfos, button, altKey, ctrlKey, shiftKey, screenX, screenY, canvasX, canvasY, clientX, clientY, obj, from_refer_comp, from_elem, meta_key)
    {
        var retn = false;
        var window = this._getWindow();
        var orgcell = this;

        if (this._is_real_upelem)
            orgcell = window.findComponent(this._is_real_upelem);

        var subcomp = from_refer_comp;
        while (subcomp && subcomp instanceof nexacro.Component)
        {
            if (subcomp instanceof nexacro._GridCellControl || subcomp instanceof nexacro.Grid)
                break;

            var canvas = subcomp._getRecalcCanvasXY(from_refer_comp._control_element, canvasX, canvasY);
            canvasX = canvas[0];
            canvasY = canvas[1];

            if (this._subComp == subcomp)
                break;

            subcomp = subcomp.parent;
        }

        var padding, parent;
        var canvas_new;
        var clientXY_new;
        var org_canvasX = canvasX;
        var org_canvasY = canvasY;
        var org_clientX = clientX;
        var org_clientY = clientY;
        var grid = this._grid;

        if (changedtouchinfos)
        {
            var touchinfo = nexacro._getFirstTouchInfo(changedtouchinfos);

            if (!touchinfo)
                return false;

            if (this._isSubCell)
            {
                touchinfo.canvasx += this._adjust_left;
                touchinfo.canvasy += this._adjust_top;
                touchinfo.clientx += this._adjust_left;
                touchinfo.clienty += this._adjust_top;
            }

            if (this._subComp == obj)
            {
                padding = this._getCurrentStylePadding();
                if (padding)
                {
                    touchinfo.canvasx += padding.left;
                    touchinfo.canvasy += padding.top;
                    touchinfo.clientx += padding.left;
                    touchinfo.clienty += padding.top;
                }
            }

            parent = grid.parent;
            retn = grid.on_fire_user_ontouchend(touchinfos, changedtouchinfos, orgcell, orgcell, true);

            canvas_new = grid._getRecalcCanvasXY(from_refer_comp._control_element, touchinfo.canvasx, touchinfo.canvasy);
            touchinfo.canvasx = canvas_new[0];
            touchinfo.canvasy = canvas_new[1];

            clientXY_new = this._getClientXY(touchinfo.clientx, touchinfo.clienty);
            touchinfo.clientx = clientXY_new[0];
            touchinfo.clienty = clientXY_new[1];

            if (!retn)
            {
                while (parent)
                {
                    if (parent.on_fire_user_ontouchend)
                    {
                        retn = parent.on_fire_user_ontouchend(touchinfos, changedtouchinfos, obj, from_refer_comp);
                        if (retn)
                            break;
                    }
                    parent = parent.parent;
                }
            }
        }
        else
        {
            if (this._isSubCell)
            {
                canvasX += this._adjust_left;
                canvasY += this._adjust_top;
                clientX += this._adjust_left;
                clientY += this._adjust_top;
            }

            if (this._subComp == obj)
            {
                padding = this._getCurrentStylePadding();
                if (padding)
                {
                    canvasX += padding.left;
                    canvasY += padding.top;
                    clientX += padding.left;
                    clientY += padding.top;
                }
            }

            parent = grid.parent;
            grid._buttonuptime = Date.now();
            retn = grid.on_fire_user_onlbuttonup(button, altKey, ctrlKey, shiftKey, screenX, screenY, canvasX, canvasY, clientX, clientY, orgcell, orgcell, from_elem, meta_key, true);

            org_canvasX = canvasX;
            org_canvasY = canvasY;

            canvas_new = grid._getRecalcCanvasXY(from_refer_comp._control_element, canvasX, canvasY);
            canvasX = canvas_new[0];
            canvasY = canvas_new[1];

            org_clientX = clientX;
            org_clientY = clientY;

            clientXY_new = this._getClientXY(canvasX, clientY);
            clientX = clientXY_new[0];
            clientY = clientXY_new[1];

            if (!retn)
            {
                while (parent)
                {
                    if (parent.on_fire_user_onlbuttonup)
                    {
                        retn = parent.on_fire_user_onlbuttonup(button, altKey, ctrlKey, shiftKey, screenX, screenY, canvasX, canvasY, clientX, clientY, obj, from_refer_comp, from_elem, meta_key);
                        if (retn)
                            break;
                    }
                    parent = parent.parent;
                }
            }
        }

        if (!this._is_alive)
            return true;

        var datarow = grid._getDataRow(this._rowidx);
        var upelem = this._is_real_upelem;
        var alreadyclick = this._is_clickproc;
        var clickcall = this._clickcall;

        this._is_real_upelem = null;
        this._is_clickproc = false;
        this._clickcall = false;

        if (grid._isFakeCell(datarow))
        {
            return false;
        }

        var cell = (this.parentcell) ? this.parentcell : this;
        var upelemtemp, check;

        if (!alreadyclick)
        {
            if (grid._lastmouseentercell == cell)
            {
                if (datarow == -1 || ((datarow == grid._selectinfo.curdsrow) && (cell._cellidx == grid._selectinfo.curcell)))
                {
                    if (grid._showEditing)
                    {
                        var editor = grid._currentCellEditor;
                        if (editor)
                        {
                            if (upelem instanceof nexacro.InputElement)
                            {
                                upelem.setElementFocus();

                                if (editor.getCaretPos)
                                {
                                    var selection = editor.getSelect();

                                    if (selection[0] == selection[1])
                                    {
                                        var cpos = editor.getCaretPos();
                                        editor._setFocus(false);

                                        if (editor.setCaretPos)
                                            editor.setCaretPos(cpos);
                                    }
                                }
                                else
                                {
                                    editor._setFocus(false);
                                }
                            }
                            else
                            {
                                editor._setFocus(false);
                            }
                        }

                        if (upelem) // mousedown과 up이 다른 경우만 존재
                        {
                            check = false;
                            upelemtemp = upelem;

                            while (upelemtemp)
                            {
                                if (upelemtemp._cellobj == obj)
                                {
                                    check = true;
                                    break;
                                }
                                upelemtemp = upelemtemp.parent;
                            }

                            if (!check)
                            {
                                check = clickcall;
                            }

                            if (check)
                            {
                                cell.on_fire_onclick(button, altKey, ctrlKey, shiftKey, screenX, screenY, org_canvasX, org_canvasY, org_clientX, org_clientY, obj, from_refer_comp, meta_key, "control", true);
                            }
                        }
                    }
                    else
                    {
                        if (upelem) // mousedown과 up이 다른 경우만 존재
                        {
                            var parentcell = (obj.parentcell) ? obj.parentcell : obj;
                            check = false;
                            upelemtemp = upelem;

                            while (upelemtemp)
                            {
                                if (upelemtemp == parentcell)
                                {
                                    check = true;
                                    break;
                                }
                                upelemtemp = upelemtemp.parent;
                            }

                            if (check)
                            {
                                var clickitem = cell._editor ? "control" : "";
                                cell.on_fire_onclick(button, altKey, ctrlKey, shiftKey, screenX, screenY, org_canvasX, org_canvasY, org_clientX, org_clientY, obj, from_refer_comp, meta_key, clickitem, true);
                            }
                        }
                    }
                }
            }
        }
    };

    _pGridCell.on_fire_user_ontouchend = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        this._common_fire_lbuttonup(touchinfos, changedtouchinfos, "", false, false, false, -1, -1, -1, -1, -1, -1, from_comp, from_refer_comp, null);
        return true;
    };

    _pGridCell.on_fire_user_onlbuttonup = function (button, altKey, ctrlKey, shiftKey, screenX, screenY, canvasX, canvasY, clientX, clientY, obj, refer_comp, from_elem, meta_key)
    {
        this._common_fire_lbuttonup(null, null, button, altKey, ctrlKey, shiftKey, screenX, screenY, canvasX, canvasY, clientX, clientY, obj, refer_comp, from_elem, meta_key);
        return true;
    };

    _pGridCell.on_fire_oninput = function ()
    {
        return this._grid.on_fire_oninput();
    };

    _pGridCell.on_fire_ondropdown = function (obj)
    {
        return this._grid.on_fire_ondropdown(obj);
    };

    _pGridCell.on_fire_oncloseup = function (obj, pretext, posttext, prevalue, postvalue)
    {
        var cell = this._cellidx;
        var col = this._refinfo._col;
        var pivotindex = -9;
        var row = this._getDataRow();
        var subrow = this._refinfo._row;

        this._changeStatus("mouseover", false);

        return this._grid.on_fire_oncloseup(obj, pretext, posttext, prevalue, postvalue, cell, col, pivotindex, row, subrow);
    };

    // ckick event    
    _pGridCell.on_fire_onclick = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key, clickitem, logic)
    {
        if (!logic)
        {
            var subcomp = from_refer_comp;
            while (subcomp && subcomp instanceof nexacro.Component)
            {
                if (subcomp instanceof nexacro._GridCellControl)
                    break;

                var canvas = subcomp._getRecalcCanvasXY(from_refer_comp._control_element, canvasX, canvasY);
                canvasX = canvas[0];
                canvasY = canvas[1];

                if (this._subComp == subcomp)
                    break;

                subcomp = subcomp.parent;
            }
        }

        if (this._isSubCell)
        {
            canvasX += this._adjust_left;
            canvasY += this._adjust_top;
            clientX += this._adjust_left;
            clientY += this._adjust_top;
        }

        if (this._subComp == from_comp)
        {
            var padding = this._getCurrentStylePadding();

            if (padding)
            {
                canvasX += padding.left;
                canvasY += padding.top;
                clientX += padding.left;
                clientY += padding.top;
            }
        }

        if (this._band)
        {
            this._is_clickproc = true;

            if (clickitem == undefined)
                clickitem = "";

            if (this._grid._isflingend)
                return true;

            if (this._grid._scrollpixel == "all")
                this._showfull(this);
            else
                this.parent._showfull(this);

            if (this._band.id == "body")
            {
                this._grid.on_fire_cellclick(this, clickitem, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
            }
            else if (this._band.id == "head")
            {
                if (from_refer_comp._sortCtrl || from_refer_comp instanceof nexacro._CellSortIconControl)
                {
                    var succ = true;

                    if (ctrl_key)
                    {
                        var sortinfo = this._grid._sortinfo;
                        var cellinfo = this._refinfo;
                        var sortcolumn = cellinfo._getAttrValue(cellinfo.sortcolumn, this._getDataRow());
                        var headcellinfos = this._grid._curFormat._headcells;

                        if (sortinfo)
                        {
                            for (var i = 0; i < sortinfo.length; i++)
                            {
                                if (sortinfo[i].cellidx != this._cellidx)
                                {
                                    var headcellinfo = headcellinfos[sortinfo[i].cellidx];
                                    var sortcolumn_prev = headcellinfo._getAttrValue(headcellinfo.sortcolumn, this._getDataRow());

                                    if (sortcolumn_prev == sortcolumn)
                                    {
                                        succ = false;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if (succ)
                    {
                        this._changeSortStatus(alt_key, ctrl_key, shift_key);
                        this._grid._applyGroupSort(true);
                    }
                }

                this._grid.on_fire_headclick(this, clickitem, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
            }
            else if (this._band.id == "summary")
            {
                this._grid.on_fire_summaryclick(this, clickitem, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
            }

            this._needToggle("onclick", from_comp);
        }
        return true;
    };

    _pGridCell._changeSortStatus = function (alt_key, ctrl_key, shift_key)
    {
        if (!this._sortCtrl)
            return;

        nexacro._CellControl.prototype._changeSortStatus.call(this, alt_key, ctrl_key, shift_key);

        if (!ctrl_key && !shift_key)
            this._grid._clearMultiSortIcons(this._cellidx);

        this._grid._applyMultiSortIcons(this._cellidx, this._sortCtrl._userstatus);
    };

    _pGridCell.on_fire_ondblclick = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key, clickitem)
    {
        var subcomp = from_refer_comp;
        while (subcomp && subcomp instanceof nexacro.Component)
        {
            if (subcomp instanceof nexacro._GridCellControl)
                break;

            var canvas = subcomp._getRecalcCanvasXY(from_refer_comp._control_element, canvasX, canvasY);
            canvasX = canvas[0];
            canvasY = canvas[1];

            if (this._subComp == subcomp)
                break;

            subcomp = subcomp.parent;
        }

        if (this._isSubCell)
        {
            canvasX += this._adjust_left;
            canvasY += this._adjust_top;
            clientX += this._adjust_left;
            clientY += this._adjust_top;
        }

        if (this._subComp == from_comp)
        {
            var padding = this._getCurrentStylePadding();

            if (padding)
            {
                canvasX += padding.left;
                canvasY += padding.top;
                clientX += padding.left;
                clientY += padding.top;
            }
        }

        if (this._band)
        {
            if (clickitem == undefined)
                clickitem = "";
            if (this._band.id == "body")
            {
                return this._grid.on_fire_celldblclick(this, clickitem, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
            }
            else if (this._band.id == "head")
            {
                return this._grid.on_fire_headdblclick(this, clickitem, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
            }
            else if (this._band.id == "summary")
            {
                return this._grid.on_fire_summarydblclick(this, clickitem, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
            }
            if (!this._is_alive) return;
        }
        return true;
    };

    //==============================================================================
    // nexacro._GridCellControl : Logical Part    
    //==============================================================================
    /*
    _pGridCell._applyMouseLeaveEvent = function ()
    {        
        if (this._is_created && this._status == "mouseover")
        {
            var row = this.parent;
            var grid = this._grid;

            if (grid._isSelectRowType())
            {
                row._updateAll("enabled");
            }
            else
            {
                this._updateAll("enabled");
            }
        }
    };

    _pGridCell._applyMouseOverEvent = function ()
    {
        if (this._is_created && this._status == "enabled")
        {
            var row = this.parent;
            var grid = this._grid;

            if (this._grid._isSelectRowType())
            {
                row._updateAll("mouseover");
            }
            else
            {
                this._updateAll("mouseover");
            }
        }
    };
    */
    _pGridCell._getFormatSize = function () // parent로 부터 정보를 받아와야함. 필요시 재정의하여 사용.
    {
        var cellinfo = this._refinfo;
        var col = cellinfo._col;
        var colspan = cellinfo._colspan;
        var row = cellinfo._row;
        var rowspan = cellinfo._rowspan;
        var format = this._grid._curFormat;

        return format._getFormatCellSize(col, row, colspan, rowspan, this._rowidx, true);
    };

    _pGridCell.__showExpand = function (flag)
    {
        if (!this._expandCtrl)
            return;

        if (this._fakecell || this._virtualmerge)
        {
            this._expandCtrl.set_visible(false);
            return;
        }

        // 여기부터 flag가 false인 경우는 suppress 처리시만 해당 됨.
        var grid = this._grid;
        var cellinfo = this._refinfo;
        var datarow = grid._getDataRow(this._rowidx);
        var expandshow = cellinfo._getAttrValue(cellinfo._p_expandshow, datarow);

        if (expandshow == "show")
        {
            if (flag == false)
            {
                if (cellinfo._p_suppressalign.indexOf("over") >= 0)     // suppressalign over 기능시엔 expand 전부 보임.
                    this._expandCtrl.set_visible(true);
                else
                    this._expandCtrl.set_visible(this.selected);    // hide 처리시 select가 될 경우엔 보임. 
            }
            else
                this._expandCtrl.set_visible(true);
        }
        else
        {
            this._expandCtrl.set_visible(false);
        }
        this._updateAvailableArea();
    };

    _pGridCell._isGroupCol = function ()
    {
        return (this._refinfo._groupcol >= 0);
    };

    _pGridCell._isUpdateArea = function ()
    {
        if (this._isSubCell || this._is_tempcell)
            return true;

        if (this._isGroupCol())
            return true;

        var grid = this._grid;
        var format = grid._curFormat;
        var gridrow = this._getRowControl(),
            gridrow_elem = gridrow.getElement(),
            update_left = gridrow_elem.scroll_left,
            update_right = update_left + grid._adjust_width - format.leftWidth - format.rightWidth;
        var cellinfo = this._refinfo;

        if (grid._p_createrowstype == "all" || cellinfo._area != "body" || (update_left <= this.getOffsetRight() && update_right >= this._adjust_left))
            return true;

        return false;
    };

    _pGridCell._isUseRowGroupControlDisplay = function ()
    {
        if (this._grid)
        {
            var treeinfo = this._grid._treeCellinfo;
            if (treeinfo && treeinfo._groupcol >= 0 && treeinfo._getDisplaytype(this._getDataRow()) == "rowgroupcontrol")
                return true;
        }
        return false;
    };

    _pGridCell._isGroupSubsumStyle = function ()
    {
        var dataset = this._getBindDataset();
        if (dataset)
        {
            var datarow = this._getDataRow();

            var grid = this._grid;
            var cellinfo = this._refinfo;

            if (dataset.getRowType(datarow) == 16 && ((grid._curFormat._group_info && grid._groupcount > 0) ? (cellinfo._col >= (grid._getGroupsStartCol() + grid._groupcount)) : true))
                return true;
        }
        return false;
    };

    _pGridCell._getRemoveLine = function ()
    {
        var grid = this._grid;
        var cellinfo = this._refinfo;
        var remove_l, remove_t, remove_r, remove_b;
        if (this._isSubCell)
        {
            remove_l = true;
            remove_t = true;
            remove_r = true;
            remove_b = true;
        }
        else if (this._band.id == "summary" && (grid._p_summarytype != "top" && grid._p_summarytype != "lefttop"))
        {
            if (cellinfo._area == "right")
            {
                remove_l = false;
                remove_t = false;
                remove_r = true;
                remove_b = true;
            }
            else
            {
                remove_l = true;
                remove_t = false;
                remove_r = false;
                remove_b = true;
            }
        }
        else
        {
            if (cellinfo._area == "right")
            {
                remove_l = false;
                remove_t = true;
                remove_r = true;
                remove_b = false;
            }
            else
            {
                remove_l = true;
                remove_t = true;
                remove_r = false;
                remove_b = false;

                if (grid._groupcount > 0 && this._band.id == "body")    // group(header,column) celld의 border를 suppress로 처리 후, 추가 보완 처리
                {
                    var dataset = this._getBindDataset();
                    var datarow = this._getDataRow();

                    if (this._isUseRowGroupControlDisplay())
                    {
                        var format = grid._curFormat;
                        var bodyrowslen = format._bodyrows.length;
                        var lastrow = bodyrowslen - 1;
                        var rowtype = dataset.getRowType(datarow);

                        if (rowtype == 32)  // group header
                        {
                            if (format._group_info)
                            {
                                if (cellinfo._groupcol >= 0)
                                {
                                    var treelvl = cellinfo._getGroupRowLevel(datarow);
                                    if (cellinfo._groupcol >= treelvl && dataset.getRowLevel(datarow) > 0)
                                        remove_r = true;
                                }
                                else 
                                {
                                    var group_after_col = grid._getGroupsStartCol() + grid._groupcount;
                                    var lastcol = format._cols.length - 1;
                                    var rightcnt = grid._getColFixCnt("right");

                                    if (rightcnt > 0)
                                        lastcol -= rightcnt;

                                    if (group_after_col <= cellinfo._col && cellinfo._col < lastcol)
                                        remove_r = true;
                                }
                            }
                        }

                        if ((cellinfo._row + cellinfo._rowspan - 1) < lastrow)
                            remove_b = true;
                    }
                }
            }
        }

        return [remove_l, remove_t, remove_r, remove_b];
    };

    // update all(style, contents, displayer, ...)
    _pGridCell._updateAll = function (status, onlycontents, nochk_updatearea, bexport)
    {
        if (this.__update(status, onlycontents, nochk_updatearea, bexport))
        {
            var control_elem = this.getElement();
            if (control_elem)
            {
                var remove_line = this._getRemoveLine();
                var remove_l, remove_t, remove_r, remove_b; // cell line 처리
                var grid = this._grid;

                remove_l = remove_line[0];
                remove_t = remove_line[1];
                remove_r = remove_line[2];
                remove_b = remove_line[3];

                var datarow = this._getDataRow();

                if (!this._isSubCell)
                {
                    var subcomp = this._subComp;

                    if (grid._focused_row == datarow)
                    {
                        if (grid._isSelectRowType() || grid._focused_cell == this._cellidx)
                        {
                            if (grid._isFocused())
                            {
                                this._changeStatus("focused", true);
                                if (subcomp && subcomp._focusedstatus)
                                {
                                    subcomp._focusedstatus = undefined
                                    subcomp._changeStatus("focused", true);
                                }
                            }
                        }
                    }
                    else
                    {
                        this._changeStatus("focused", false);
                        if (subcomp && subcomp._statusmap["focused"])
                        {
                            subcomp._focusedstatus = subcomp._statusmap["focused"];
                            subcomp._changeStatus("focused", false);
                        }
                    }

                    if (grid._mouseovercell && grid._mouseovercell.row != this._rowidx)
                        this._changeStatus("mouseover", false);
                }

                var cellinfo = this._refinfo;
                var suppproc = false;

                if (this.subcells.length > 0)
                {
                    for (var i = 0, n = this.subcells.length; i < n; i++)
                        this.subcells[i]._updateAll();
                }

                if (!this._isSubCell)
                {
                    var format = grid._curFormat;
                    var ps_rowslen = format._bodyrows ? format._bodyrows.length : 0;
                    var cols = format._cols;
                    var colvisible = (cols[cellinfo._col].groupcol < 0) ? cols[cellinfo._col].visible : true;

                    // -- column visible
                    if (colvisible)
                        this._control_element.setElementDisplay("");
                    else
                        this._control_element.setElementDisplay("none");

                    //-------------
                    function procBorderBottom(suppinfo, cell)
                    {
                        if (suppinfo)
                        {
                            var suppressborder = suppinfo.border_proc;

                            // suppressborder == 1이면 그리지 않음.

                            if (cell._getDisplayRowIdx() == cell._grid._getDispRowCnt() - 1)
                                suppressborder = 0;

                            if (suppressborder > 0 || (cellinfo._groupcol >= 0 && cellinfo._isGroupColumnFirstSubSumCell(datarow + 1)))
                            {
                                if (ps_rowslen > 1 && cell._band.id == "body")
                                {
                                    if (ps_rowslen == cellinfo._row + cellinfo._rowspan)
                                        return true;
                                }
                                else
                                {
                                    return true;
                                }
                            }
                        }
                        return false;
                    };
                    //-------------

                    if (this._isCellSuppress(cellinfo, datarow) && (cellinfo._getSuppress(datarow) != 0 || grid._supphorztype > 0))
                    {
                        if (this._band.id == "body" && cellinfo._p_suppressalign.indexOf("over") >= 0)
                        {
                            this._setContentsVisible("suppress", false);
                        }
                        else
                        {
                            if (this._disp_show)
                            {
                                var suppinfo = this._getSuppressInfo(bexport);
                                if (suppinfo)
                                {
                                    if (procBorderBottom(suppinfo, this))
                                        remove_b = true;

                                    if (suppinfo.horz_border_proc == 1)
                                    {
                                        if (cellinfo._area == "left")
                                            remove_r = true;
                                        else if (cellinfo._area == "right")
                                            remove_l = true;
                                    }

                                    if (suppinfo.text_proc != 0 || suppinfo.horz_text_proc != 0)
                                        this._setContentsVisible("suppress", false);
                                    else
                                        this._setContentsVisible("suppress", true);

                                    suppproc = true;
                                }
                                else
                                {
                                    if (this._disp_show && this._hideInner)
                                        this._setContentsVisible("suppress", true);
                                }
                            }
                        }
                    }
                    else
                    {
                        if (this._disp_show && this._hideInner)
                            this._setContentsVisible("suppress", true);

                        if (remove_b == false && ps_rowslen > 1 && cellinfo._row + cellinfo._rowspan == ps_rowslen)
                        {
                            var rowc = this.parent;
                            var cells = rowc._cells;

                            for (var j = 0; j < cells.length; j++)
                            {
                                if (cells[j]._refinfo._col == cellinfo._col)
                                {
                                    if (cells[j]._refinfo._p_suppress != 0)
                                    {
                                        var suppinfo = cells[j]._getSuppressInfo(bexport);

                                        if (procBorderBottom(suppinfo, cells[j]))
                                            remove_b = true;

                                        break;
                                    }
                                }
                            }
                        }
                    }
                }

                if (!onlycontents)
                    this._control_element.setElementBorderNone(remove_l, remove_t, remove_r, remove_b, this._isRtl(grid));

                if (control_elem._mode == "text")
                    this._changeClientmode("text");

                if (grid._isFakeCell(datarow) == false && !suppproc)  // virtualmerge border
                {
                    var vminfo = this._virtualmerge = grid._checkVirtualMerge(cellinfo, datarow);

                    if (vminfo)
                    {
                        var isselect = this._isSelectedColor();
                        var background;
                        if (vminfo.targetcell != this._cellidx || vminfo.targetrow != datarow)
                        {
                            background = grid._getCellStyleInfo(vminfo.targetcell, "background", vminfo.targetrow, isselect);
                            this.set_background(background);
                        }

                        var remove = vminfo.remove;
                        if (remove.indexOf("right") >= 0)
                            remove_r = true;
                        else if (remove.indexOf("left") >= 0)
                            remove_l = true;

                        if (remove.indexOf("bottom") >= 0)
                            remove_b = true;
                        else if (remove.indexOf("top") >= 0)
                            remove_t = true;

                        this._control_element.setElementBorderNone(remove_l, remove_t, remove_r, remove_b, this._isRtl(grid));
                        this._setContentsVisible("mergecell", false);
                    }
                    else
                    {
                        this._setContentsVisible("mergecell", true);
                    }
                }
            }
        }
    };

    _pGridCell._applyVirtualMergeCellStyle = function (status, flush)
    {
        var cellinfo = this._refinfo;
        var datarow = this._getDataRow();
        var grid = this._grid;

        if (grid && grid._isFakeCell(datarow) == false)  // virtualmerge border
        {
            var vminfo = grid._checkVirtualMerge(cellinfo, datarow);

            if (vminfo)
            {
                if (vminfo.targetcell != this._cellidx || vminfo.targetrow != datarow)
                {
                    var style = grid._getCellStyleInfo(vminfo.targetcell, ["background", "color"], vminfo.targetrow, this._isSelectedColor(), undefined, undefined, undefined, status, flush);
                    this.set_background(style.background);
                    this.set_color(style.color);
                    var target_cellinfo = grid._getCellinfos(vminfo.targetrow)[vminfo.targetcell];
                    var overlaycontrol = grid._overlay_controls[vminfo.overlayidx];
                    grid._updateOverlayControlStyle(overlaycontrol, vminfo.targetrow, target_cellinfo, status, false);
                }
            }
        }
    }

    // 각 cell의 displaytype에 따른 적용
    _pGridCell._isCellSuppress = function (cellinfo, datarow)
    {
        if (!this._grid._is_use_suppress && !this._grid._supphorztype)
            return false;

        if (!datarow)
            datarow = this._grid._getDataRow(this._rowidx);

        if (!cellinfo)
            cellinfo = this._refinfo;

        var disp_type = cellinfo._getDisplaytype(datarow);
        return ((disp_type != "treeitemcontrol" && disp_type != "rowgroupcontrol") || cellinfo._groupcol >= 0);
    };

    _pGridCell._getSuppressInfo = function (b_fulldata)
    {
        var grid = this._grid;
        var row2;

        if (b_fulldata) 
        {
            row2 = 0;
        }
        else
        {
            if (grid._fixed_rowcnt > 0)
            {
                if (grid._fixed_endrow >= this._rowidx)
                    row2 = grid._fixed_startrow;
                else
                    row2 = grid._toprowpos[0] - (grid._fixed_rowcnt - grid._fixed_startrow);
            }
            else
            {
                row2 = grid._toprowpos[0];
            }
        }

        var row = this._rowidx - row2;

        if (this._rowidx >= 0 && row < 0)
            return null;

        return this._refinfo._getSuppressInfo(row);
    };

    _pGridCell._getDisplayRowIdx = function ()
    {
        return this._rowidx - this._grid._getBodyBegRowPos(this._rowidx);
    };

    _pGridCell._getDisplayText = function ()
    {
        var cellinfo = this._refinfo;
        var datarow = this._getDataRow();
        var edittype = cellinfo._getEdittype(datarow);

        if (edittype == "checkbox")
        {
            return this._grid._getCheck(cellinfo._col, datarow, cellinfo._row);
        }
        else
        {
            var displayText = cellinfo._getDisplayText(datarow);
            displayText = this._getStringResourceProperty(displayText);
            return displayText;
        }
        return "";
    }

    _pGridCell._setDisplayText = function ()
    {
        if (!this._is_alive) return;
        this._displaytext = this._getDisplayText();
        this.on_apply_text();
    };

    _pGridCell._showfull = function (is_vscroll)
    {
        if (!this._is_alive) return;
        if (this._isSubCell)
            return this.parent._showfull();

        var band = this._band;
        var scrollleft = this._grid._getScrollLeft();
        var scrolltop = this._grid._getScrollTop();
        //var band_elem = band._control_element;
        var topPos = this.parent._adjust_top;

        var l = this._adjust_left;
        var t = this._adjust_top + topPos;
        var w = this._adjust_width;
        var h = this._adjust_height;
        var r = l + w;
        var b = t + h;

        l -= scrollleft;
        r -= scrollleft;
        t -= scrolltop;
        b -= scrolltop;

        var grid = this._grid;
        var gridrow = this._getRowControl();
        var hscroll = grid._hscrollmng;
        var vscroll = grid._vscrollmng;
        var cellinfo = this._refinfo;
        var bandrc = gridrow._getAreaRect(cellinfo._area);

        if (hscroll && cellinfo._area == "body")
        {
            if (w < bandrc.width)
            {
                if (l < 0)
                {
                    hscroll.setPos(hscroll.pos + l);
                }
                else if (r > bandrc.width)
                {
                    var gap = r - bandrc.width;
                    hscroll.setPos(hscroll.pos + gap);
                }
            }
        }
        // vscroll은 gridrow에서 처리
        // selectype이 cell이고 scrollpixel이 all이면 vscroll도 pixel 단위 움직임

        if (band.id == "body")
        {
            if (vscroll && is_vscroll && !gridrow._fixed)
            {
                if (h < band._getClientHeight())
                {
                    if (t < 0)
                    {
                        vscroll.setPixelPos(vscroll._pos + t);
                    }
                    else if (b > band._getClientHeight())
                    {
                        var gab = b - band._getClientHeight();
                        vscroll.setPixelPos(vscroll._pos + gab);
                    }
                }
            }
        }
    };

    _pGridCell._needToggle = function (eventname, from_comp)
    {
        if (!this._is_alive) return;

        var grid = this._grid;

        if (nexacro._toBoolean(grid._p_readonly))
            return;

        var datarow = grid._getDataRow(this._rowidx);
        var editType = this._refinfo._getEdittype(datarow);

        if (grid._p_selectchangetype == "down" && eventname == "onclick")
            return;
        else if (grid._p_selectchangetype == "up" && eventname == "onlbuttondown")
            return;

        if (editType == "checkbox")
        {
            if (this._curDisplayType != "checkboxcontrol")
            {
                grid._toggleVal(datarow, this._refinfo);
            }
            else
            {
                if (eventname == "onclick" || eventname == "onlbuttondown")
                {
                    if (this._grid._p_cellclickbound == "cell" && from_comp == this)
                    {
                        if (this._subComp && this._subComp._toggleCheck)
                        {
                            this._subComp._toggleCheck();
                        }
                    }
                }
                else
                {
                    if (this._subComp && this._subComp._toggleCheck)
                    {
                        this._subComp._toggleCheck();
                    }
                }
            }
        }
        else if (editType == "radioitem")
        {
            if (this._curDisplayType != "radioitemcontrol")
            {
                grid._selectVal(datarow, this._refinfo);
            }
            else
            {
                if (eventname == "onclick" || eventname == "onlbuttondown")
                {
                    if (this._grid._p_cellclickbound == "cell" && from_comp == this)
                    {
                        if (this._subComp && this._subComp._itemSelect)
                        {
                            this._subComp._itemSelect();
                        }
                    }
                }
                else
                {
                    if (this._subComp && this._subComp._itemSelect)
                    {
                        this._subComp._itemSelect();
                    }
                }
            }
        }
    };

    _pGridCell._getRowControl = function ()
    {
        return (this._isSubCell) ? this.parent.parent : this.parent;
    };

    _pGridCell._setPositionInGrid = function (editComp, noScrollPos, noPadding, noscroll_posinfo)
    {
        if (!this._is_alive)
            return { left: 0, top: 0, right: 0, bottom: 0, width: 0, height: 0, orgt: 0, orgl: 0 };
        var gridrow = this._getRowControl();
        var band = this._band;
        var grid = this._grid;
        var cellinfo = this._refinfo;
        var rect = gridrow._getAreaRect(cellinfo._area);

        var areal = rect.left;
        var arear = rect.left + rect.width;

        var is_fixed = (band.id == "body" && gridrow._fixed);
        var bandt = band._adjust_top + ((band.id == "body" && is_fixed == false) ? grid._fixed_height : 0);
        var bandb = band.getOffsetBottom();

        var l = this._adjust_left + areal;
        var t = gridrow._adjust_top + this._adjust_top + bandt;
        var border;

        if (band._refinfo._noborder == true && cellinfo._row == 0 && this._getDisplayRowIdx() <= 0)
        {
            border = this._getCurrentStyleBorder();
            t += border ? border.bottom._width : 0;
        }
        else if (this._rowidx == -2)
        {
            if (grid._p_summarytype != "top" && grid._p_summarytype != "lefttop")
            {
                border = this._getCurrentStyleBorder();
                t += border ? border.top._width : 0;
            }
        }

        var crect = this._getAvailableRect();
        var padding;

        if (!noPadding)
        {
            padding = this._getCurrentStylePadding();
            l += (padding) ? padding.left : 0;
            t += (padding) ? padding.top : 0;
        }
        else
        {
            padding = this._getCurrentStylePadding();
            crect.width += (padding) ? (padding.left + padding.right) : 0;
            crect.height += (padding) ? (padding.top + padding.bottom) : 0;
        }

        if (noscroll_posinfo)
        {
            noscroll_posinfo.left = l;
            noscroll_posinfo.right = l + crect.width;
            noscroll_posinfo.top = t;
            noscroll_posinfo.bottom = t + crect.height;
        }

        if (!noScrollPos)
        {
            var band_scroll_top = (is_fixed) ? 0 : grid._getScrollTop();
            var area_scroll_left = grid._getScrollLeft();

            if (cellinfo._area == "body")
                l -= (area_scroll_left >= 0) ? area_scroll_left : 0;
            if (band.id == "body")
                t -= (band_scroll_top >= 0) ? band_scroll_top : 0;
        }

        var r = l + crect.width;
        var b = t + crect.height;
        var orgt = t, orgl = l;

        if (t < bandt) t = bandt;
        if (b > bandb) b = bandb;
        if (l < areal) l = areal;
        if (r > arear) r = arear;

        var w = r - l;
        var h = b - t;

        if (w < 0) w = 0;
        if (h < 0) h = 0;

        if (editComp)
        {
            if (w == 0 || h == 0)
                editComp.move(0, -10, 0, 0);
            else
                editComp.move(l, t, w, h);
        }

        return { left: l, top: t, right: r, bottom: b, width: w, height: h, orgt: orgt, orgl: orgl };
    };

    _pGridCell._setCompPositionInGrid = function (editComp, noScrollPos, noPadding, noscroll_posinfo)
    {
        if (!this._is_alive)
            return { left: 0, top: 0, right: 0, bottom: 0, width: 0, height: 0, orgt: 0, orgl: 0 };
        var gridrow = this._getRowControl();
        var band = this._band;
        var grid = this._grid;
        var cellinfo = this._refinfo;
        var rect = gridrow._getAreaRect(cellinfo._area);

        var areal = rect.left;
        var arear = rect.left + rect.width;

        var is_fixed = (band.id == "body" && gridrow._fixed);
        var bandt = band._adjust_top + ((band.id == "body" && is_fixed == false) ? grid._fixed_height : 0);
        var bandb = band.getOffsetBottom();

        var l = this._adjust_left + editComp._adjust_left + areal;
        var t = gridrow._adjust_top + this._adjust_top + editComp._adjust_top + bandt;
        var border;

        if (band._refinfo._noborder == true && cellinfo._row == 0 && this._getDisplayRowIdx() <= 0)
        {
            border = this._getCurrentStyleBorder();
            t += border ? border.bottom._width : 0;
        }
        else if (this._rowidx == -2)
        {
            if (grid._p_summarytype != "top" && grid._p_summarytype != "lefttop")
            {
                border = this._getCurrentStyleBorder();
                t += border ? border.top._width : 0;
            }
        }

        var crect = this._getAvailableRect();
        var crect2 = this._getControlRect();
        crect.left = Math.max(crect.left, crect2.left);
        crect.top = Math.max(crect.top, crect2.top);
        crect.right = Math.min(crect.right, crect2.right);
        crect.bottom = Math.min(crect.bottom, crect2.bottom);
        crect.width = crect.right - crect.left;
        crect.height = crect.bottom - crect.top;
        //var padding;


        if (noscroll_posinfo)
        {
            noscroll_posinfo.left = l;
            noscroll_posinfo.right = l + crect.width;
            noscroll_posinfo.top = t;
            noscroll_posinfo.bottom = t + crect.height;
        }

        if (!noScrollPos)
        {
            var band_scroll_top = (is_fixed) ? 0 : grid._getScrollTop();
            var area_scroll_left = grid._getScrollLeft();

            if (cellinfo._area == "body")
                l -= (area_scroll_left >= 0) ? area_scroll_left : 0;
            if (band.id == "body")
                t -= (band_scroll_top >= 0) ? band_scroll_top : 0;
        }

        var r = l + crect.width;
        var b = t + crect.height;
        var orgt = t, orgl = l;

        if (t < bandt) t = bandt;
        if (b > bandb) b = bandb;
        if (l < areal) l = areal;
        if (r > arear) r = arear;

        var w = r - l;
        var h = b - t;

        if (w < 0) w = 0;
        if (h < 0) h = 0;



        return { left: l, top: t, right: r, bottom: b, width: w, height: h, orgt: orgt, orgl: orgl };
    };
    _pGridCell._getCompPositionInBand = function (editComp)
    {
        if (!this._is_alive)
            return { left: 0, top: 0, right: 0, bottom: 0, width: 0, height: 0, orgt: 0, orgl: 0, orgr: 0, orgb: 0 };
        var gridrow = this._getRowControl();
        var band = this._band;
        var grid = this._grid;
        var cellinfo = this._refinfo;

        // 해당 row rect
        var rect = gridrow._getAreaRect(cellinfo._area);

        var areal = rect.left;
        var arear = rect.left + rect.width;

        var is_fixed = (band.id == "body" && gridrow._fixed);
        var bandt = (band.id == "body" && is_fixed == false) ? grid._fixed_height : 0;
        var bandb = band._adjust_height;

        var l = this._adjust_left + editComp._adjust_left + areal;
        var t = gridrow._adjust_top + this._adjust_top + editComp._adjust_top + bandt;


        var crect = this._getAvailableRect();
        var crect2 = this._getControlRect();
        crect.left = Math.max(crect.left, crect2.left);
        crect.top = Math.max(crect.top, crect2.top);
        crect.right = Math.min(crect.right, crect2.right);
        crect.bottom = Math.min(crect.bottom, crect2.bottom);
        crect.width = crect.right - crect.left;
        crect.height = crect.bottom - crect.top;

        var band_scroll_top = (is_fixed) ? 0 : grid._getScrollTop();
        var area_scroll_left = grid._getScrollLeft();

        if (cellinfo._area == "body")
            l -= (area_scroll_left >= 0) ? area_scroll_left : 0;
        if (band.id == "body")
            t -= (band_scroll_top >= 0) ? band_scroll_top : 0;


        var r = l + crect.width;//this._adjust_width;
        var b = t + crect.height;//this._adjust_height;
        var orgt = t, orgl = l, orgr = r, orgb = b;

        if (t < bandt) t = bandt;
        if (b > bandb) b = bandb;
        if (l < areal) l = areal;
        if (r > arear) r = arear;

        var w = r - l;
        var h = b - t;

        if (w < 0) w = 0;
        if (h < 0) h = 0;

        return { left: l, top: t, right: r, bottom: b, width: w, height: h, orgt: orgt, orgl: orgl, orgr: orgr, orgb: orgb };
    };
    _pGridCell._getPositionInBand = function ()
    {
        if (!this._is_alive)
            return { left: 0, top: 0, right: 0, bottom: 0, width: 0, height: 0, orgt: 0, orgl: 0, orgr: 0, orgb: 0 };
        var gridrow = this._getRowControl();
        var band = this._band;
        var grid = this._grid;
        var cellinfo = this._refinfo;

        // 해당 row rect
        var rect = gridrow._getAreaRect(cellinfo._area);

        var areal = rect.left;
        var arear = rect.left + rect.width;

        var is_fixed = (band.id == "body" && gridrow._fixed);
        var bandt = (band.id == "body" && is_fixed == false) ? grid._fixed_height : 0;
        var bandb = band._adjust_height;

        var l = this._adjust_left + areal;
        var t = gridrow._adjust_top + this._adjust_top + bandt;

        var band_scroll_top = (is_fixed) ? 0 : grid._getScrollTop();
        var area_scroll_left = grid._getScrollLeft();

        if (cellinfo._area == "body")
            l -= (area_scroll_left >= 0) ? area_scroll_left : 0;
        if (band.id == "body")
            t -= (band_scroll_top >= 0) ? band_scroll_top : 0;

        var r = l + this._adjust_width;
        var b = t + this._adjust_height;
        var orgt = t, orgl = l, orgr = r, orgb = b;

        if (t < bandt) t = bandt;
        if (b > bandb) b = bandb;
        if (l < areal) l = areal;
        if (r > arear) r = arear;

        var w = r - l;
        var h = b - t;

        if (w < 0) w = 0;
        if (h < 0) h = 0;

        return { left: l, top: t, right: r, bottom: b, width: w, height: h, orgt: orgt, orgl: orgl, orgr: orgr, orgb: orgb };
    };

    _pGridCell._isConditionEditor = function ()
    {
        var grid = this._grid;
        var datarow = grid._getDataRow(this._rowidx);

        return (grid._currentCellCell == this._cellidx && grid._currentCellRow == datarow);
    };

    _pGridCell._showEditor = function (focus, showfull)
    {
        var textCtrl = this._text_elem;
        var cellinfo = this._refinfo;
        var grid = this._grid;
        var datarow = grid._getDataRow(this._rowidx);
        var editComp;
        var evt_name;
        if (nexacro._isTouchInteraction)
        {
            var keycode = grid._keydown_keycode;
            var is_autoenter_key = grid._p_autoenter == "key" && keycode && (grid._isChar(keycode) || keycode === 25);
            if (!is_autoenter_key)
            {
                evt_name = "touch";
            }
        }

        if (showfull)
            this._showfull();

        if (this._grid._showEditing)
            this._grid._hideEditor();

        grid._currentCellCell = this._cellidx;
        grid._currentCellRow = datarow;

        if (textCtrl)
            textCtrl.setElementVisible(false);

        if (!cellinfo._isDisplayEditOnlyOneControl(datarow))
        {
            if (this._subComp)
            {
                this._subComp.set_visible(false);
                this._subComp._changeStatus("mouseover", false);
            }
        }

        grid._currentCellEditor = editComp = this._createEditor();
        editComp._EditUpdateAll(cellinfo, this);
        editComp.set_visible(true);

        if (focus || nexacro._isTouchInteraction || grid._p_selectchangetype == "up")
            editComp._apply_setfocus(evt_name);

        if (grid._p_autoenter == "select" && grid._lbuttondown_proc)
        {
            editComp._user_push = true;
            editComp._changeStatus("focused", true);
            editComp._is_pushed_area = true;
            editComp._is_push = true;
        }
        else
        {
            editComp._changeStatus("focused", true);
        }

        if (this._env._p_enableaccessibility)
            editComp._setFocus(false);      // control read

        this._editor = editComp;

        if (editComp.setCaretPos)
        {
            if (!editComp._p_autoselect)
                editComp.setCaretPos(0);
            else if (grid._keydown_keycode == 37 || grid._keydown_keycode == 39) // left, right key
            {
                nexacro._OnceCallbackTimer.callonce(this, function ()
                {
                    editComp.setSelect(0, -1);
                });
            }
        }
        else if (editComp.comboedit && editComp.comboedit.setCaretPos)
        {
            if (!editComp.comboedit._p_autoselect)
                editComp.comboedit.setCaretPos(0);
            else if (grid._keydown_keycode == 37 || grid._keydown_keycode == 39) // left, right key
            {
                nexacro._OnceCallbackTimer.callonce(this, function ()
                {
                    editComp.comboedit.setSelect(0, -1);
                });
            }
        }
        else if (editComp.multicombotext && editComp.multicombotext.setCaretPos)
        {
            if (!editComp.multicombotext._p_autoselect)
                editComp.multicombotext.setCaretPos(0);
            else if (grid._keydown_keycode == 37 || grid._keydown_keycode == 39) // left, right key
            {
                nexacro._OnceCallbackTimer.callonce(this, function ()
                {
                    editComp.multicombotext.setSelect(0, -1);
                });
            }
        }

        grid._has_inputElement = true;
    };

    _pGridCell._hideEditor = function ()
    {
        var text = this._text_elem;

        if (!this._hideInner)
        {
            if (text)
                text.setElementVisible(true);

            if (this._subComp)
            {
                this._subComp.set_visible(true);
                this._subComp._changeStatus("mouseover", false);
            }
        }

        this._destroyEditor();

        this._grid._currentCellCell = -1;
        this._grid._currentCellRow = -1;
        this._grid._has_inputElement = false;
    };

    _pGridCell._getPositionInRootComponent = function (comp)
    {
        var rect = this._setCompPositionInGrid(comp);
        var bandrect = this._getCompPositionInBand(comp);
        return [rect, bandrect];
    };
    _pGridCell = null;

    nexacro._GridSubCellControl = function (id, left, top, width, height, right, bottom, parent, cellinfo, rowidx, cellidx)
    {
        nexacro._GridCellControl.call(this, id, left, top, width, height, right, bottom, parent, cellinfo, rowidx, cellidx);
        this._isSubCell = true;
    };

    var _pSubGridCell = nexacro._createPrototype(nexacro._GridCellControl, nexacro._GridSubCellControl);
    nexacro._GridSubCellControl.prototype = _pSubGridCell;
    _pSubGridCell._is_subcontrol = true;
    _pSubGridCell._type_name = "GridSubCellControl";

    _pSubGridCell.on_getIDCSSSelector = function ()
    {
        return "subcell";
    };

    //===============================================================
    // nexacro._GridExpandControl
    //===============================================================
    nexacro._GridExpandControl = function (parent, left, top, right, bottom, controlmode)
    {
        nexacro._CellExpandControl.call(this, parent, left, top, right, bottom, controlmode);

        if (parent._refinfo)
        {
            this._grid = parent._grid;
            this._cellobj = parent;
            this._cellinfo = parent._refinfo;
        }
        else
        {
            this._grid = parent;
        }
    };

    var _pGridExpand = nexacro._createPrototype(nexacro._CellExpandControl, nexacro._GridExpandControl);
    nexacro._GridExpandControl.prototype = _pGridExpand;

    //===============================================================
    // nexacro._GridExpandControl : Create & Destroy & Update
    //===============================================================
    _pGridExpand.on_destroy_contents = function ()
    {
        nexacro._CellExpandControl.prototype.on_destroy_contents.call(this);
        this._grid = null;
    };

    //===============================================================
    // nexacro._GridExpandControl : Event Handlers
    //===============================================================
    _pGridExpand._on_bubble_mouseenter = function (elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseenter();

        if (call)
            nexacro.Button.prototype._on_bubble_mouseenter.call(this, elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridExpand._on_bubble_mouseleave = function (elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseleave();

        if (call)
            nexacro.Button.prototype._on_bubble_mouseleave.call(this, elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridExpand.on_fire_user_ontouchstart = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        this._cellobj.on_fire_user_ontouchstart(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        var touchinfo = nexacro._getFirstTouchInfo(changedtouchinfos);

        if (touchinfo)
            this._grid.on_fire_onexpanddown("", false, false, false, touchinfo.screenx, touchinfo.screeny, touchinfo.canvasx, touchinfo.canvasy, touchinfo.clientx, touchinfo.clienty, from_comp, from_refer_comp);

        return true;
    };

    _pGridExpand.on_fire_user_onlbuttondown = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        this._cellobj.on_fire_user_onlbuttondown(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
        this._grid.on_fire_onexpanddown(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
        return true;
    };

    _pGridExpand.on_fire_user_ontouchend = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        this._cellobj.on_fire_user_ontouchend(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        var touchinfo = nexacro._getFirstTouchInfo(changedtouchinfos);
        if (touchinfo)
            this._grid.on_fire_onexpandup("", false, false, false, touchinfo.screenx, touchinfo.screeny, touchinfo.canvasx, touchinfo.canvasy, touchinfo.clientx, touchinfo.clienty, from_comp, from_refer_comp);
        return true;
    };

    _pGridExpand.on_fire_user_onlbuttonup = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key)
    {
        this._cellobj.on_fire_user_onlbuttonup(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key);
        this._grid.on_fire_onexpandup(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key);
        return true;
    };

    _pGridExpand._on_last_lbuttonup = function ()
    {
        this._cellobj._on_last_lbuttonup();
    };

    _pGridExpand._on_last_keyup = function ()
    {
        this._cellobj._on_last_keyup();
    };

    //===============================================================
    // nexacro._GridExpandControl : Logical Part
    //===============================================================

    _pGridExpand = null;

    //===============================================================
    // nexacro._GridFilterIconControl
    //===============================================================
    nexacro._GridFilterIconControl = function (parent, left, top, right, bottom, controlmode)
    {
        nexacro._CellFilterIconControl.call(this, parent, left, top, right, bottom, controlmode);

        if (parent._refinfo)
        {
            this._grid = parent._grid;
            this._cellobj = parent;
            this._cellinfo = parent._refinfo;
        }
        else
        {
            this._grid = parent;
        }
    };

    var _pGridFilterIcon = nexacro._createPrototype(nexacro._CellFilterIconControl, nexacro._GridFilterIconControl);
    nexacro._GridFilterIconControl.prototype = _pGridFilterIcon;

    //===============================================================
    // nexacro._GridFilterIconControl : Create & Destroy & Update
    //===============================================================
    _pGridFilterIcon.on_destroy_contents = function ()
    {
        nexacro._CellFilterIconControl.prototype.on_destroy_contents.call(this);
        this._grid = null;
    };

    //===============================================================
    // nexacro._GridFilterIconControl : Event Handlers
    //===============================================================
    _pGridFilterIcon._on_bubble_mouseenter = function (elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseenter();

        if (call)
            nexacro.Button.prototype._on_bubble_mouseenter.call(this, elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridFilterIcon._on_bubble_mouseleave = function (elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseleave();

        if (call)
            nexacro.Button.prototype._on_bubble_mouseleave.call(this, elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridFilterIcon.on_fire_user_ontouchstart = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        this._cellobj.on_fire_user_ontouchstart(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        return true;
    };

    _pGridFilterIcon.on_fire_user_onlbuttondown = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        this._cellobj.on_fire_user_onlbuttondown(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
        return true;
    };

    _pGridFilterIcon.on_fire_user_ontouchend = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        this._cellobj.on_fire_user_ontouchend(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        return true;
    };

    _pGridFilterIcon.on_fire_user_onlbuttonup = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key)
    {
        this._cellobj.on_fire_user_onlbuttonup(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key);
        return true;
    };

    _pGridFilterIcon._on_last_lbuttonup = function ()
    {
        this._cellobj._on_last_lbuttonup();
    };

    _pGridFilterIcon._on_last_keyup = function ()
    {
        this._cellobj._on_last_keyup();
    };

    //===============================================================
    // nexacro._GridFilterIconControl : Logical Part
    //===============================================================

    _pGridFilterIcon = null;

    //===============================================================
    // nexacro._GridButtonControl : Button
    // description : use Event Notifiers, style control - controlType
    //===============================================================
    nexacro._GridButtonControl = function (id, left, top, width, height, parent, displaymode, controlmode)
    {
        nexacro._CellButtonControl.call(this, id, left, top, width, height, parent, displaymode, controlmode);

        if (parent._refinfo)
        {
            this._grid = parent._refinfo._grid;
            this._cellinfo = parent._refinfo;
            this._cellobj = parent;
        }
        else
        {
            this._grid = parent;
            this._cellinfo = null;
            this._cellobj = null;
        }
    };
    var _pGridButton = nexacro._createPrototype(nexacro._CellButtonControl, nexacro._GridButtonControl);
    nexacro._GridButtonControl.prototype = _pGridButton;

    //===============================================================
    // nexacro._GridButtonControl : Create & Destroy & Update    
    //===============================================================
    _pGridButton.on_destroy_contents = function ()
    {
        nexacro._CellButtonControl.prototype.on_destroy_contents.call(this);
        this._grid = null;
    };

    //===============================================================
    // nexacro._GridButtonControl : Event Handlers
    //===============================================================
    _pGridButton.on_fire_user_onkeyup = function (key_code, alt_key, ctrl_key, shift_key, from_comp, from_refer_comp, meta_key) // 2013-04-23 pss - override for keyup 'enter' or 'space'
    {
        var ret = nexacro.Component.prototype.on_fire_user_onkeyup.call(this, key_code, alt_key, ctrl_key, shift_key, from_comp, from_refer_comp, meta_key);
        if (key_code == 13 || key_code == 32) // 13 'enter' , 32 'space'
        {
            this.click();
        }
        return ret;
    };

    _pGridButton._on_bubble_touchend = function (touch_manager, touchinfos, changedtouchinfos, event_bubbles, fire_comp, refer_comp, is_userbubble)
    {
        var call = true;
        if (is_userbubble)
            call = this._cellobj._common_lbuttonup(changedtouchinfos, null, null, null, null);

        if (call)
            nexacro.Button.prototype._on_bubble_touchend.call(this, touch_manager, touchinfos, changedtouchinfos, event_bubbles, fire_comp, refer_comp, is_userbubble);

        return true;
    };

    _pGridButton._on_bubble_lbuttonup = function (elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, from_elem, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_lbuttonup(null, elem, canvasX, canvasY, from_elem);

        if (call)
            nexacro.Button.prototype._on_bubble_lbuttonup.call(this, elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, from_elem, bubble_scope, meta_key);

        return true;
    };

    _pGridButton._on_bubble_mouseenter = function (elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseenter();

        if (call)
            nexacro.Button.prototype._on_bubble_mouseenter.call(this, elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridButton._on_bubble_mouseleave = function (elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseleave();

        if (call)
            nexacro.Button.prototype._on_bubble_mouseleave.call(this, elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridButton.on_fire_user_ontouchstart = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        nexacro.Button.prototype.on_fire_user_ontouchstart.call(this, touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        this._cellobj.on_fire_user_ontouchstart(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        return true;
    };

    _pGridButton.on_fire_user_onlbuttondown = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        nexacro.Button.prototype.on_fire_user_onlbuttondown.call(this, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
        this._cellobj.on_fire_user_onlbuttondown(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
        return true;
    };

    _pGridButton.on_fire_user_ontouchend = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        nexacro.Button.prototype.on_fire_user_ontouchend.call(this, touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        this._cellobj.on_fire_user_ontouchend(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        return true;
    };

    _pGridButton.on_fire_user_onlbuttonup = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key)
    {
        nexacro.Button.prototype.on_fire_user_onlbuttonup.call(this, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key);
        this._cellobj.on_fire_user_onlbuttonup(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key);
        return true;
    };

    _pGridButton._on_last_lbuttonup = function ()
    {
        this._cellobj._on_last_lbuttonup();
    };

    _pGridButton._on_last_keyup = function ()
    {
        this._cellobj._on_last_keyup();
    };

    _pGridButton._on_click = function (elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, meta_key)
    {
        if (!this._is_alive)
            return;

        var visible = this._p_visible;
        if (this._displaymode && this._grid._p_selectchangetype == "up")
            visible = true;

        var force = false;
        if (nexacro._isTouchInteraction)    // moblie touchend elem이 touchdown elem과 동일해서 생기는 문제
        {
            if (!visible && this._grid._showEditing)
                force = true;
        }

        if ((force || visible) && this._isEnable() && this.enableevent)
        {
            var clientXY = this._getClientXY(canvasX, canvasY);
            this.on_fire_onclick(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientXY[0], clientXY[1], this, this, meta_key);
        }
    };

    //===============================================================
    // nexacro._GridButtonControl : Logical Part
    //===============================================================
    _pGridButton._setDataset = function (/*async*/)
    {
    };

    _pGridButton = null;

    //===============================================================
    // nexacro._GridHTMLControl : Button
    // description : use Event Notifiers, style control - controlType
    //===============================================================
    nexacro._GridHTMLControl = function (id, left, top, width, height, parent, displaymode, controlmode)
    {
        nexacro._CellHTMLControl.call(this, id, left, top, width, height, parent, displaymode, controlmode);

        if (parent._refinfo)
        {
            this._grid = parent._refinfo._grid;
            this._cellinfo = parent._refinfo;
            this._cellobj = parent;
        }
        else
        {
            this._grid = parent;
            this._cellinfo = null;
            this._cellobj = null;
        }
    };
    var _pGridHTMLControl = nexacro._createPrototype(nexacro._CellHTMLControl, nexacro._GridHTMLControl);
    nexacro._GridHTMLControl.prototype = _pGridHTMLControl;

    //===============================================================
    // nexacro._GridHTMLControl : Create & Destroy & Update
    //===============================================================
    _pGridHTMLControl.on_destroy_contents = function ()
    {
        nexacro._CellHTMLControl.prototype.on_destroy_contents.call(this);
        this._grid = null;
    };

    //===============================================================
    // nexacro._GridHTMLControl : Event Handlers
    //===============================================================
    _pGridHTMLControl._on_bubble_touchend = function (touch_manager, touchinfos, changedtouchinfos, event_bubbles, fire_comp, refer_comp, is_userbubble)
    {
        var call = true;
        if (is_userbubble)
            call = this._cellobj._common_lbuttonup(changedtouchinfos, null, null, null, null);

        if (call)
            nexacro._CellHTMLControl.prototype._on_bubble_touchend.call(this, touch_manager, touchinfos, changedtouchinfos, event_bubbles, fire_comp, refer_comp, is_userbubble);

        return true;
    };

    _pGridHTMLControl._on_bubble_lbuttonup = function (elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, from_elem, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_lbuttonup(null, elem, canvasX, canvasY, from_elem);

        if (call)
            nexacro._CellHTMLControl.prototype._on_bubble_lbuttonup.call(this, elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, from_elem, bubble_scope, meta_key);

        return true;
    };

    _pGridHTMLControl._on_bubble_mouseenter = function (elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseenter();

        if (call)
            nexacro._CellHTMLControl.prototype._on_bubble_mouseenter.call(this, elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridHTMLControl._on_bubble_mouseleave = function (elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseleave();

        if (call)
            nexacro._CellHTMLControl.prototype._on_bubble_mouseleave.call(this, elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridHTMLControl.on_fire_user_ontouchstart = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        nexacro._CellHTMLControl.prototype.on_fire_user_ontouchstart.call(this, touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        this._cellobj.on_fire_user_ontouchstart(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        return true;
    };

    _pGridHTMLControl.on_fire_user_onlbuttondown = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        nexacro._CellHTMLControl.prototype.on_fire_user_onlbuttondown.call(this, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
        this._cellobj.on_fire_user_onlbuttondown(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
        return true;
    };

    _pGridHTMLControl.on_fire_user_ontouchend = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        nexacro._CellHTMLControl.prototype.on_fire_user_ontouchend.call(this, touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        this._cellobj.on_fire_user_ontouchend(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        return true;
    };

    _pGridHTMLControl.on_fire_user_onlbuttonup = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key)
    {
        nexacro._CellHTMLControl.prototype.on_fire_user_onlbuttonup.call(this, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key);
        this._cellobj.on_fire_user_onlbuttonup(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key);
        return true;
    };

    _pGridHTMLControl._on_last_lbuttonup = function ()
    {
        this._cellobj._on_last_lbuttonup();
    };

    _pGridHTMLControl._on_last_keyup = function ()
    {
        this._cellobj._on_last_keyup();
    };

    _pGridHTMLControl._on_click = function (elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, meta_key)
    {
        if (!this._is_alive)
            return;

        var visible = this._p_visible;
        if (this._displaymode && this._grid._p_selectchangetype == "up")
            visible = true;

        var force = false;
        if (nexacro._isTouchInteraction)    // moblie touchend elem이 touchdown elem과 동일해서 생기는 문제
        {
            if (!visible && this._grid._showEditing)
                force = true;
        }

        if ((force || visible) && this._isEnable() && this.enableevent)
        {
            var clientXY = this._getClientXY(canvasX, canvasY);
            this.on_fire_onclick(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientXY[0], clientXY[1], this, this, meta_key);
        }
    };

    //===============================================================
    // nexacro._GridHTMLControl : Logical Part
    //===============================================================
    _pGridHTMLControl._setDataset = function (/*async*/)
    {
    };

    _pGridHTMLControl = null;

    //===============================================================
    // nexacro._GridCustomControl
    //===============================================================
    nexacro._GridCustomControl = function (id, left, top, width, height, parent, displaymode, controlmode)
    {
        nexacro._CellCustomControl.call(this, id, left, top, width, height, parent, displaymode, controlmode);

        if (parent._refinfo)
        {
            this._grid = parent._refinfo._grid;
            this._cellinfo = parent._refinfo;
            this._cellobj = parent;
        }
        else
        {
            this._grid = parent;
            this._cellinfo = null;
            this._cellobj = null;
        }
    };
    var _pGridCustom = nexacro._createPrototype(nexacro._CellCustomControl, nexacro._GridCustomControl);
    nexacro._GridCustomControl.prototype = _pGridCustom;

    //===============================================================
    // nexacro._GridCustomControl : Create & Destroy & Update    
    //===============================================================
    _pGridCustom.on_create_contents = function ()
    {
        nexacro._CellCustomControl.prototype.on_create_contents.call(this);

        var control = this._control;

        control._on_bubble_touchend = function (touch_manager, touchinfos, changedtouchinfos, event_bubbles, fire_comp, refer_comp, is_userbubble)
        {
            var call = true;
            if (is_userbubble)
                call = this._linked_interface._cellobj._common_lbuttonup(changedtouchinfos, null, null, null, null);

            if (call)
                Object.getPrototypeOf(this._linked_interface)._on_bubble_touchend.call(this, touch_manager, touchinfos, changedtouchinfos, event_bubbles, fire_comp, refer_comp, is_userbubble);

            return true;
        };

        control._on_bubble_lbuttonup = function (elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, from_elem, bubble_scope, meta_key)
        {
            var call = true;
            if (bubble_scope)
                call = this._linked_interface._cellobj._common_lbuttonup(null, elem, canvasX, canvasY, from_elem);

            if (call)
                /*this._linked_interface.__proto__*/Object.getPrototypeOf(this._linked_interface)._on_bubble_lbuttonup.call(this, elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, from_elem, bubble_scope, meta_key);

            return true;
        };

        control._on_bubble_mouseenter = function (elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
        {
            var call = true;
            if (bubble_scope)
                call = this._linked_interface._cellobj._common_mouseenter();

            if (call)
                /*this._linked_interface.__proto__*/Object.getPrototypeOf(this._linked_interface)._on_bubble_mouseenter.call(this, elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

            return true;
        };

        control._on_bubble_mouseleave = function (elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
        {
            var call = true;
            if (bubble_scope)
                call = this._linked_interface._cellobj._common_mouseleave();

            if (call)
                /*this._linked_interface.__proto__*/Object.getPrototypeOf(this._linked_interface)._on_bubble_mouseleave.call(this, elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

            return true;
        };

        control.on_fire_user_ontouchstart = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
        {
            /*this._linked_interface.__proto__*/Object.getPrototypeOf(this._linked_interface).on_fire_user_ontouchstart.call(this, touchinfos, changedtouchinfos, from_comp, from_refer_comp);
            this._linked_interface._cellobj.on_fire_user_ontouchstart(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
            return true;
        };

        control.on_fire_user_onlbuttondown = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
        {
            /*this._linked_interface.__proto__*/Object.getPrototypeOf(this._linked_interface).on_fire_user_onlbuttondown.call(this, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
            this._linked_interface._cellobj.on_fire_user_onlbuttondown(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
            return true;
        };

        control.on_fire_user_ontouchend = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
        {
            /*this._linked_interface.__proto__*/Object.getPrototypeOf(this._linked_interface).on_fire_user_ontouchend.call(this, touchinfos, changedtouchinfos, from_comp, from_refer_comp);
            this._linked_interface._cellobj.on_fire_user_ontouchend(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
            return true;
        };

        control.on_fire_user_onlbuttonup = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key)
        {
            /*this._linked_interface.__proto__*/Object.getPrototypeOf(this._linked_interface).on_fire_user_onlbuttonup.call(this, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key);
            this._linked_interface._cellobj.on_fire_user_onlbuttonup(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key);
            return true;
        };

        control._on_last_lbuttonup = function ()
        {
            this._linked_interface._cellobj._on_last_lbuttonup();
        };

        control._on_last_keyup = function ()
        {
            this._linked_interface._cellobj._on_last_keyup();
        };
    };

    _pGridCustom.on_destroy_contents = function ()
    {
        nexacro._CellCustomControl.prototype.on_destroy_contents.call(this);
        this._grid = null;
    };

    //===============================================================
    // nexacro._GridCustomControl : Event Handlers
    //===============================================================


    //===============================================================
    // nexacro._GridCustomControl : Logical Part
    //===============================================================
    _pGridCustom._setDataset = function (/*async*/)
    {
        var view = this._view;
        var retn = true;
        var cellinfo = this.parent._refinfo;
        var datarow = this.parent._getDataRow();
        var edittype = cellinfo._getEdittype(datarow);
        var dataset = this._cellobj._getBindDataset();

        if (edittype == "customcontrol")
        {
            var bind_values = this._control.on_getBindableProperties();
            var controlbindprops = this._getBindWritablePropInfos(datarow);

            if (controlbindprops)
            {
                if (typeof (bind_values) == "string")
                    bind_values = [bind_values];

                for (var i = 0; i < bind_values.length; i++)
                {
                    var colid = controlbindprops[bind_values[i]];
                    var value = this._control[bind_values[i]];

                    if (!colid)
                        continue;

                    view._dsEventOccured = true;

                    var fail = { status: "" };
                    dataset.setColumn(datarow, colid, value, fail);

                    if (fail.status == "cancolumnchange")
                        retn = false;

                    view._dsEventOccured = false;
                }
            }
            else
            {
                if (typeof (bind_values) == "string")
                {
                    var value = this._control[bind_values];
                    this._setValueDataset(value);
                }
            }
        }
        else
        {
            retn = false;
        }
        return retn;
    };

    _pGridCustom._setValueDataset = function (value)
    {
        var retn = true;
        var cellinfo = this._cellinfo;
        var grid = this._grid;
        var datarow = this._cellobj._getDataRow();

        if (!this._p_readonly)
        {
            if (cellinfo.text._bindtype == 1)
            {
                grid._dsEventOccured = true;

                var fail = { status: "" };
                grid._binddataset.setColumn(datarow, cellinfo.text._bindexpr, value, fail);

                if (fail.status == "cancolumnchange")
                    retn = false;

                grid._dsEventOccured = false;
            }
            else if (datarow == -1)
            {
                var cellidx;
                if (this._linked_interface._cellobj._isSubCell)
                {
                    cellidx = this._cellobj._cellidx;
                }
                else
                {
                    cellidx = cellinfo._cellidx;
                }
                var prevalue = cellinfo._value;
                if (cellinfo._setValue(value))
                {
                    grid._on_fire_onheadvaluechanged(prevalue, value, cellidx);
                }
            }
        }
        return retn;
    };

    _pGridCustom = null;

    //===============================================================
    // nexacro._GridProgressBarControl : ProgressBar
    // description : use Event Notifiers, style control - controlType
    //===============================================================
    nexacro._GridProgressBarControl = function (id, left, top, width, height, parent, controlmode)
    {
        nexacro._CellProgressBarControl.call(this, id, left, top, width, height, parent, controlmode);

        if (parent._refinfo)
        {
            this._grid = parent._refinfo._grid;
            this._cellinfo = parent._refinfo;
            this._cellobj = parent;
        }
        else
        {
            this._grid = parent;
        }
    };
    var _pGridBar = nexacro._GridProgressBarControl.prototype = nexacro._createPrototype(nexacro._CellProgressBarControl, nexacro._GridProgressBarControl);

    //===============================================================
    // nexacro._GridProgressBarControl : Style Part    
    //===============================================================

    //===============================================================
    // nexacro._GridProgressBarControl : Create & Destroy & Update
    //===============================================================
    _pGridBar.on_destroy_contents = function ()
    {
        nexacro._CellProgressBarControl.prototype.on_destroy_contents.call(this);
        this._grid = null;
    };

    //===============================================================
    // nexacro._GridProgressBarControl : Event Handlers
    //===============================================================
    _pGridBar._on_bubble_mouseenter = function (elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseenter();

        if (call)
            nexacro.ProgressBar.prototype._on_bubble_mouseenter.call(this, elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridBar._on_bubble_mouseleave = function (elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseleave();

        if (call)
            nexacro.ProgressBar.prototype._on_bubble_mouseleave.call(this, elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridBar._on_last_lbuttonup = function ()
    {
        this._cellobj._on_last_lbuttonup();
    };

    _pGridBar._on_last_keyup = function ()
    {
        this._cellobj._on_last_keyup();
    };

    _pGridBar = null;

    //===============================================================
    // nexacro._GridEditControl : Edit
    // description : use Event Notifiers, style control - controlType
    //===============================================================
    nexacro._GridEditControl = function (id, left, top, width, height, parent, displaymode, controlmode)
    {
        nexacro._CellEditControl.call(this, id, left, top, width, height, parent, displaymode, controlmode);

        if (parent._refinfo)
        {
            this._grid = parent._refinfo._grid;
            this._cellinfo = parent._refinfo;
            this._cellobj = parent;
        }
        else
        {
            this._grid = parent;
        }
    };

    var _pGridEdit = nexacro._createPrototype(nexacro._CellEditControl, nexacro._GridEditControl);
    nexacro._GridEditControl.prototype = _pGridEdit;

    //===============================================================
    // nexacro._GridEditControl : Create & Destroy & Update
    //===============================================================
    _pGridEdit.on_destroy_contents = function ()
    {
        nexacro._CellEditControl.prototype.on_destroy_contents.call(this);
        this._grid = null;

    };

    //===============================================================
    // nexacro._GridEditControl : Properties
    //===============================================================
    _pGridEdit.on_apply_autoskip = function ()
    {
        this._grid._moveToCell("next", true);
    };

    //===============================================================
    // nexacro._GridEditControl : Event Handlers
    //===============================================================
    _pGridEdit._on_bubble_touchend = function (touch_manager, touchinfos, changedtouchinfos, event_bubbles, fire_comp, refer_comp, is_userbubble)
    {
        var call = true;
        if (is_userbubble)
            call = this._cellobj._common_lbuttonup(changedtouchinfos, null, null, null, null);

        if (call)
            nexacro.Edit.prototype._on_bubble_touchend.call(this, touch_manager, touchinfos, changedtouchinfos, event_bubbles, fire_comp, refer_comp, is_userbubble);

        return true;
    };

    _pGridEdit._on_bubble_lbuttonup = function (elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, from_elem, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_lbuttonup(null, elem, canvasX, canvasY, from_elem);

        if (call)
            nexacro.Edit.prototype._on_bubble_lbuttonup.call(this, elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, from_elem, bubble_scope, meta_key);

        return true;
    };

    _pGridEdit._on_bubble_mouseenter = function (elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseenter();

        if (call)
            nexacro.Edit.prototype._on_bubble_mouseenter.call(this, elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridEdit._on_bubble_mouseleave = function (elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseleave();

        if (call)
            nexacro.Edit.prototype._on_bubble_mouseleave.call(this, elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);
        return true;
    };

    _pGridEdit.on_fire_onkillfocus = function (newobj, newreferobj)
    {
        return this._cellobj.on_fire_onkillfocus(newobj, newreferobj);
    };

    _pGridEdit.on_fire_user_ontouchend = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        nexacro.Edit.prototype.on_fire_user_ontouchend.call(this, touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        this._cellobj.on_fire_user_ontouchend(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        return true;
    };

    _pGridEdit.on_fire_user_onlbuttonup = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key)
    {
        nexacro.Edit.prototype.on_fire_user_onlbuttonup.call(this, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key);
        this._cellobj.on_fire_user_onlbuttonup(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key);
        return true;
    };

    _pGridEdit.on_fire_user_ontouchstart = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        nexacro.Edit.prototype.on_fire_user_ontouchstart.call(this, touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        this._cellobj.on_fire_user_ontouchstart(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        return true;
    };

    _pGridEdit.on_fire_user_onlbuttondown = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        nexacro.Edit.prototype.on_fire_user_onlbuttondown.call(this, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
        this._cellobj.on_fire_user_onlbuttondown(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
        return true;
    };

    _pGridEdit.on_fire_onclick = function (obj, caretpos, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key, clickitem)
    {
        nexacro.Edit.prototype.on_fire_onclick.call(this, obj, caretpos, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
        this._cellobj.on_fire_onclick(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key, clickitem);
        return true;
    };

    if (nexacro._Browser == "Gecko" || nexacro._Browser == "Opera") // input류에서 두 브라우저에서는 lbutton down elem과 up의 elem이 동일하여 그리드 내부에서 click이벤트를 call해줄 수 없는 문제 때문에 오버라이딩 함.
    {
        _pGridEdit._on_click = function (elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, meta_key)
        {
            if (!this._is_alive)
                return;

            var visible = this._p_visible;

            if (this._displaymode)
                visible = true;

            if (visible && this._isEnable() && this.enableevent)
            {
                var caretPos = this.getCaretPos();
                var clientXY = this._getClientXY(canvasX, canvasY);
                this.on_fire_onclick(this, caretPos, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientXY[0], clientXY[1], this, this, meta_key, "control");
            }
        };
    }
    else
    {
        _pGridEdit._on_click = function (elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, meta_key)
        {
            if (!this._is_alive)
                return;

            var visible = this._p_visible;
            if (this._displaymode && this._grid._p_selectchangetype == "up")
                visible = true;

            if (visible && this._isEnable() && this.enableevent)
            {
                var caretPos = this.getCaretPos();
                var clientXY = this._getClientXY(canvasX, canvasY);
                this.on_fire_onclick(this, caretPos, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientXY[0], clientXY[1], this, this, meta_key, "control");
            }
        };
    }

    _pGridEdit._on_last_lbuttonup = function ()
    {
        this._cellobj._on_last_lbuttonup();
    };

    _pGridEdit._on_last_keyup = function ()
    {
        this._cellobj._on_last_keyup();
    };

    //===============================================================
    // nexacro._GridEditControl : Logical Part
    //===============================================================
    _pGridEdit._setDataset = function (b_async, row)
    {
        var cellinfo = this._cellinfo;
        var grid = this._grid;
        var datarow = this._update_datarow;

        if (row != undefined)
            datarow = row;

        var retn = true;

        if (this._input_element && grid._hide_applydata)
        {
            if (this._input_element.isComposing())
            {
                this._input_element.on_complete_composition_value();
            }
        }

        if (cellinfo.text._bindtype == 1)
        {
            grid._is_async_recreate = b_async;
            grid._dsEventOccured = true;

            var fail = { status: "" };
            grid._binddataset.setColumn(datarow, cellinfo.text._bindexpr, this.value, fail);

            if (fail.status == "cancolumnchange")
                retn = false;

            grid._is_async_recreate = false;
            grid._dsEventOccured = false;
        }
        else if (datarow == -1)
        {
            var cellidx;
            if (this._cellobj._isSubCell)
            {
                cellidx = this._cellobj.parent._cellidx;
            }
            else
            {
                cellidx = cellinfo._cellidx;
            }
            var prevalue = cellinfo._value;
            if (cellinfo._setValue(this.value))
                grid._on_fire_onheadvaluechanged(prevalue, this.value, cellidx);
        }
        return retn;
    };

    _pGridEdit = null;

    //===============================================================
    // nexacro._GridTextAreaControl : TextArea
    // description : use Event Notifiers, style control - controlType
    //===============================================================
    nexacro._GridTextAreaControl = function (id, left, top, width, height, parent, displaymode, controlmode)
    {
        nexacro._CellTextAreaControl.call(this, id, left, top, width, height, parent, displaymode, controlmode);

        if (parent._refinfo)
        {
            this._grid = parent._refinfo._grid;
            this._cellinfo = parent._refinfo;
            this._cellobj = parent;
        }
        else
        {
            this._grid = parent;
        }
    };

    var _pGridTextArea = nexacro._createPrototype(nexacro._CellTextAreaControl, nexacro._GridTextAreaControl);
    nexacro._GridTextAreaControl.prototype = _pGridTextArea;

    //===============================================================
    // nexacro._GridTextAreaControl : Create & Destroy & Update
    //===============================================================
    _pGridTextArea.on_destroy_contents = function ()
    {
        nexacro._CellTextAreaControl.prototype.on_destroy_contents.call(this);
        this._grid = null;
    };

    //===============================================================
    // nexacro._GridTextAreaControl : Properties
    //===============================================================    


    //===============================================================
    // nexacro._GridTextAreaControl : Event Handlers
    //===============================================================
    _pGridTextArea._on_bubble_touchend = function (touch_manager, touchinfos, changedtouchinfos, event_bubbles, fire_comp, refer_comp, is_userbubble)
    {
        var call = true;
        if (is_userbubble)
            call = this._cellobj._common_lbuttonup(changedtouchinfos, null, null, null, null);

        if (call)
            nexacro.TextArea.prototype._on_bubble_touchend.call(this, touch_manager, touchinfos, changedtouchinfos, event_bubbles, fire_comp, refer_comp, is_userbubble);

        return true;
    };

    _pGridTextArea._on_bubble_lbuttonup = function (elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, from_elem, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_lbuttonup(null, elem, canvasX, canvasY, from_elem);

        if (call)
            nexacro.TextArea.prototype._on_bubble_lbuttonup.call(this, elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, from_elem, bubble_scope, meta_key);

        return true;
    };

    _pGridTextArea._on_bubble_mouseenter = function (elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseenter();

        if (call)
            nexacro.TextArea.prototype._on_bubble_mouseenter.call(this, elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridTextArea._on_bubble_mouseleave = function (elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseleave();

        if (call)
            nexacro.TextArea.prototype._on_bubble_mouseleave.call(this, elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridTextArea.on_fire_user_ontouchend = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        nexacro.TextArea.prototype.on_fire_user_ontouchend.call(this, touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        this._cellobj.on_fire_user_ontouchend(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        return true;
    };

    _pGridTextArea.on_fire_user_onlbuttonup = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key)
    {
        nexacro.TextArea.prototype.on_fire_user_onlbuttonup.call(this, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key);
        this._cellobj.on_fire_user_onlbuttonup(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key);
        return true;
    };

    _pGridTextArea.on_fire_user_ontouchstart = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        nexacro.TextArea.prototype.on_fire_user_ontouchstart.call(this, touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        this._cellobj.on_fire_user_ontouchstart(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        return true;
    };

    _pGridTextArea.on_fire_user_onlbuttondown = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        nexacro.TextArea.prototype.on_fire_user_onlbuttondown.call(this, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
        this._cellobj.on_fire_user_onlbuttondown(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
        return true;
    };

    _pGridTextArea.on_fire_onclick = function (obj, caretpos, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key, clickitem)
    {
        nexacro.TextArea.prototype.on_fire_onclick.call(this, obj, caretpos, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
        this._cellobj.on_fire_onclick(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key, clickitem);
        return true;
    };

    if (nexacro._Browser == "Gecko" || nexacro._Browser == "Opera") // input류에서 두 브라우저에서는 lbutton down elem과 up의 elem이 동일하여 그리드 내부에서 click이벤트를 call해줄 수 없는 문제 때문에 오버라이딩 함.
    {
        _pGridTextArea._on_click = function (elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, meta_key)
        {
            if (!this._is_alive)
                return;

            var visible = this._p_visible;
            if (this._displaymode)
                visible = true;

            if (visible && this._isEnable() && this.enableevent)
            {
                var caretPos = this.getCaretPos();
                var clientXY = this._getClientXY(canvasX, canvasY);
                this.on_fire_onclick(this, caretPos, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientXY[0], clientXY[1], this, this, meta_key, "control");
            }
        };
    }
    else
    {
        _pGridTextArea._on_click = function (elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, meta_key)
        {
            if (!this._is_alive)
                return;

            var visible = this._p_visible;
            if (this._displaymode && this._grid._p_selectchangetype == "up")
                visible = true;

            if (visible && this._isEnable() && this.enableevent)
            {
                var caretPos = this.getCaretPos();
                var clientXY = this._getClientXY(canvasX, canvasY);

                this.on_fire_onclick(this, caretPos, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientXY[0], clientXY[1], this, this, meta_key, "control");
            }
        };
    }

    _pGridTextArea._on_last_lbuttonup = function ()
    {
        this._cellobj._on_last_lbuttonup();
    };

    _pGridTextArea._on_last_keyup = function ()
    {
        this._cellobj._on_last_keyup();
    };

    //===============================================================
    // nexacro._GridTextAreaControl : Logical Part
    //===============================================================
    _pGridTextArea._setDataset = function (b_async, row)
    {
        var cellinfo = this._cellinfo;
        var grid = this._grid;
        var datarow = this._update_datarow;

        if (row != undefined)
            datarow = row;

        var retn = true;

        if (this._input_element && grid._hide_applydata)
        {
            if (this._input_element.isComposing())
                this._input_element.on_complete_composition_value();
        }

        if (!this._p_readonly)
        {
            if (cellinfo.text._bindtype == 1)
            {
                grid._is_async_recreate = b_async;
                grid._dsEventOccured = true;

                var fail = { status: "" };
                grid._binddataset.setColumn(datarow, cellinfo.text._bindexpr, this.value, fail);

                if (fail.status == "cancolumnchange")
                    retn = false;

                grid._is_async_recreate = false;
                grid._dsEventOccured = false;
            }
            else if (datarow == -1)
            {
                var cellidx;
                if (this._cellobj._isSubCell)
                {
                    cellidx = this._cellobj.parent._cellidx;
                }
                else
                {
                    cellidx = cellinfo._cellidx;
                }
                var prevalue = cellinfo._value;
                if (cellinfo._setValue(this.value))
                    grid._on_fire_onheadvaluechanged(prevalue, this.value, cellidx);
            }
        }
        return retn;
    };

    _pGridTextArea = null;

    //===============================================================
    // nexacro._GridMaskEditControl : MaskEdit
    // description : use Event Notifiers, style control - controlType
    //===============================================================
    nexacro._GridMaskEditControl = function (id, left, top, width, height, parent, controlmode)
    {
        nexacro._CellMaskEditControl.call(this, id, left, top, width, height, parent, controlmode);

        if (parent._refinfo)
        {
            this._grid = parent._refinfo._grid;
            this._cellinfo = parent._refinfo;
            this._cellobj = parent;
        }
        else
        {
            this._grid = parent;
        }
    };

    var _pGridMaskEdit = nexacro._createPrototype(nexacro._CellMaskEditControl, nexacro._GridMaskEditControl);
    nexacro._GridMaskEditControl.prototype = _pGridMaskEdit;

    //===============================================================
    // nexacro._GridMaskEditControl : Create & Destroy & Update
    //===============================================================
    _pGridMaskEdit.on_destroy_contents = function ()
    {
        nexacro._CellMaskEditControl.prototype.on_destroy_contents.call(this);
        this._grid = null;
    };

    //===============================================================
    // nexacro._GridMaskEditControl : Properties
    //===============================================================
    _pGridMaskEdit.on_apply_autoskip = function ()
    {
        this._grid._moveToCell("next", true);
    };

    //===============================================================
    // nexacro._GridMaskEditControl : Event Handlers
    //===============================================================
    _pGridMaskEdit._on_bubble_touchend = function (touch_manager, touchinfos, changedtouchinfos, event_bubbles, fire_comp, refer_comp, is_userbubble)
    {
        var call = true;
        if (is_userbubble)
            call = this._cellobj._common_lbuttonup(changedtouchinfos, null, null, null, null);

        if (call)
            nexacro.MaskEdit.prototype._on_bubble_touchend.call(this, touch_manager, touchinfos, changedtouchinfos, event_bubbles, fire_comp, refer_comp, is_userbubble);

        return true;
    };

    _pGridMaskEdit._on_bubble_lbuttonup = function (elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, from_elem, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_lbuttonup(null, elem, canvasX, canvasY, from_elem);

        if (call)
            nexacro.MaskEdit.prototype._on_bubble_lbuttonup.call(this, elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, from_elem, bubble_scope, meta_key);

        return true;
    };

    _pGridMaskEdit._on_bubble_mouseenter = function (elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseenter();

        if (call)
            nexacro.MaskEdit.prototype._on_bubble_mouseenter.call(this, elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridMaskEdit._on_bubble_mouseleave = function (elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseleave();

        if (call)
            nexacro.MaskEdit.prototype._on_bubble_mouseleave.call(this, elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridMaskEdit.on_fire_user_ontouchend = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        nexacro.MaskEdit.prototype.on_fire_user_ontouchend.call(this, touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        this._cellobj.on_fire_user_ontouchend(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        return true;
    };

    _pGridMaskEdit.on_fire_user_onlbuttonup = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key)
    {
        nexacro.MaskEdit.prototype.on_fire_user_onlbuttonup.call(this, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key);
        this._cellobj.on_fire_user_onlbuttonup(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key);
        return true;
    };

    _pGridMaskEdit.on_fire_user_ontouchstart = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        nexacro.MaskEdit.prototype.on_fire_user_ontouchstart.call(this, touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        this._cellobj.on_fire_user_ontouchstart(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        return true;
    };

    _pGridMaskEdit.on_fire_user_onlbuttondown = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        nexacro.MaskEdit.prototype.on_fire_user_onlbuttondown.call(this, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
        this._cellobj.on_fire_user_onlbuttondown(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
        return true;
    };

    _pGridMaskEdit.on_fire_onclick = function (obj, caretpos, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key, clickitem)
    {
        nexacro.MaskEdit.prototype.on_fire_onclick.call(this, obj, caretpos, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
        this._cellobj.on_fire_onclick(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key, clickitem);
        return true;
    };

    if (nexacro._Browser == "Gecko" || nexacro._Browser == "Opera") // input류에서 두 브라우저에서는 lbutton down elem과 up의 elem이 동일하여 그리드 내부에서 click이벤트를 call해줄 수 없는 문제 때문에 오버라이딩 함.
    {
        _pGridMaskEdit._on_click = function (elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, meta_key)
        {
            if (!this._is_alive)
                return;

            var visible = this._p_visible;
            if (this._displaymode)
                visible = true;

            if (visible && this._isEnable() && this.enableevent)
            {
                var caretPos = this.getCaretPos();
                var clientXY = this._getClientXY(canvasX, canvasY);
                this.on_fire_onclick(this, caretPos, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientXY[0], clientXY[1], this, this, meta_key, "control");
            }
        };
    }
    else
    {
        _pGridMaskEdit._on_click = function (elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, meta_key)
        {
            if (!this._is_alive)
                return;

            var visible = this._p_visible;
            if (this._displaymode && this._grid._p_selectchangetype == "up")
                visible = true;

            if (visible && this._isEnable() && this.enableevent)
            {
                var caretPos = this.getCaretPos();
                var clientXY = this._getClientXY(canvasX, canvasY);
                this.on_fire_onclick(this, caretPos, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientXY[0], clientXY[1], this, this, meta_key, "control");
            }
        };
    }

    _pGridMaskEdit._on_last_lbuttonup = function ()
    {
        this._cellobj._on_last_lbuttonup();
    };

    _pGridMaskEdit._on_last_keyup = function ()
    {
        this._cellobj._on_last_keyup();
    };

    //===============================================================
    // nexacro._GridMaskEditControl : Logical Part
    //===============================================================
    _pGridMaskEdit._setDataset = function (b_async, row)
    {
        var cellinfo = this._cellinfo;
        var grid = this._grid;
        var datarow = this._update_datarow;

        if (row != undefined)
            datarow = row;

        var retn = true;

        if (cellinfo.text._bindtype == 1)
        {
            grid._is_async_recreate = b_async;
            grid._dsEventOccured = true;

            var fail = { status: "" };
            grid._binddataset.setColumn(datarow, cellinfo.text._bindexpr, this.value, fail);

            if (fail.status == "cancolumnchange")
                retn = false;

            grid._is_async_recreate = false;
            grid._dsEventOccured = false;
        }
        else if (datarow == -1)
        {
            var cellidx;
            if (this._cellobj._isSubCell)
            {
                cellidx = this._cellobj.parent._cellidx;
            }
            else
            {
                cellidx = cellinfo._cellidx;
            }
            var prevalue = cellinfo._value;
            if (cellinfo._setValue(this.value))
                grid._on_fire_onheadvaluechanged(prevalue, this.value, cellidx);
        }
        return retn;
    };

    _pGridMaskEdit = null;

    //===============================================================
    // nexacro._GridCalendarControl : Calendar
    // description : use Event Notifiers, style control - controlType
    //===============================================================
    nexacro._GridCalendarControl = function (id, left, top, width, height, parent, displaymode, controlmode)
    {
        nexacro._CellCalendarControl.call(this, id, left, top, width, height, parent, displaymode, controlmode);

        if (parent._refinfo)
        {
            this._grid = parent._refinfo._grid;
            this._cellinfo = parent._refinfo;
            this._cellobj = parent;
        }
        else
        {
            //parent is grid
            this._grid = parent;
        }
    };

    var _pGridCalendar = nexacro._createPrototype(nexacro._CellCalendarControl, nexacro._GridCalendarControl);
    nexacro._GridCalendarControl.prototype = _pGridCalendar;

    _pGridCalendar._properties = [
        { name: "innerdataset" },
        { name: "backgroundcolumn" },
        { name: "bordercolumn" },
        { name: "datecolumn" },
        { name: "textcolorcolumn" }
    ];

    //===============================================================
    // nexacro._GridCalendarControl : Create & Destroy & Update
    //===============================================================
    _pGridCalendar.on_destroy_contents = function ()
    {
        nexacro._CellCalendarControl.prototype.on_destroy_contents.call(this);
        this._grid = null;
    };

    //===============================================================
    // nexacro._GridCalendarControl : Override
    //===============================================================
    _pGridCalendar.set_innerdataset = function (str)
    {
        var ret = nexacro._CellCalendarControl.prototype.set_innerdataset.call(this, str);

        if (this._controlmode)
        {
            var grid = this._grid;
            if (grid)
            {
                for (var i = 0, n = grid.getCellCount("body"); i < n; i++)
                {
                    grid.setCellProperty("body", i, "calendarinnerdataset", str);
                }

                if (grid._currentCellEditor && grid._currentCellEditor instanceof nexacro._GridCalendarControl)
                    grid._currentCellEditor.set_innerdataset(str);
            }
        }
        return ret;
    };

    _pGridCalendar.set_backgroundcolumn = function (str)
    {
        nexacro._CellCalendarControl.prototype.set_backgroundcolumn.call(this, str);
        if (this._controlmode)
        {
            var grid = this._grid;
            if (grid)
            {
                for (var i = 0, n = grid.getCellCount("body"); i < n; i++)
                {
                    grid.setCellProperty("body", i, "calendarbackgroundcolumn", str);
                }
            }
        }
    };

    _pGridCalendar.set_bordercolumn = function (str)
    {
        nexacro._CellCalendarControl.prototype.set_bordercolumn.call(this, str);
        if (this._controlmode)
        {
            var grid = this._grid;
            if (grid)
            {
                for (var i = 0, n = grid.getCellCount("body"); i < n; i++)
                {
                    grid.setCellProperty("body", i, "calendarbordercolumn", str);
                }
            }
        }
    };

    _pGridCalendar.set_datecolumn = function (str)
    {
        nexacro._CellCalendarControl.prototype.set_datecolumn.call(this, str);
        if (this._controlmode)
        {
            var grid = this._grid;
            if (grid)
            {
                for (var i = 0, n = grid.getCellCount("body"); i < n; i++)
                {
                    grid.setCellProperty("body", i, "calendardatecolumn", str);
                }
            }
        }
    };

    _pGridCalendar.set_textcolorcolumn = function (str)
    {
        nexacro._CellCalendarControl.prototype.set_textcolorcolumn.call(this, str);
        if (this._controlmode)
        {
            var grid = this._grid;
            if (grid)
            {
                for (var i = 0, n = grid.getCellCount("body"); i < n; i++)
                {
                    grid.setCellProperty("body", i, "calendartextcolorcolumn", str);
                }
            }
        }
    };

    //===============================================================
    // nexacro._GridCalendarControl : Event Handlers
    //===============================================================
    _pGridCalendar._on_bubble_touchend = function (touch_manager, touchinfos, changedtouchinfos, event_bubbles, fire_comp, refer_comp, is_userbubble)
    {
        var call = true;
        if (is_userbubble)
            call = this._cellobj._common_lbuttonup(changedtouchinfos, null, null, null, null);

        if (call)
            nexacro.Calendar.prototype._on_bubble_touchend.call(this, touch_manager, touchinfos, changedtouchinfos, event_bubbles, fire_comp, refer_comp, is_userbubble);

        return true;
    };

    _pGridCalendar._on_bubble_lbuttonup = function (elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, from_elem, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_lbuttonup(null, elem, canvasX, canvasY, from_elem);

        if (call)
            nexacro.Calendar.prototype._on_bubble_lbuttonup.call(this, elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, from_elem, bubble_scope, meta_key);

        return true;
    };

    _pGridCalendar._on_mouseenter = function (elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, meta_key)
    {
        if (this._isPopupVisible())
        {
            var cellobj = this._cellobj;
            if (cellobj)
            {
                var grid = cellobj._grid;
                grid._lastmouseentercell = null;
            }
        }
        return nexacro.Component.prototype._on_mouseenter.call(this, elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, meta_key);

    };

    _pGridCalendar._on_bubble_mouseenter = function (elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseenter();

        if (call)
            nexacro.Calendar.prototype._on_bubble_mouseenter.call(this, elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridCalendar._on_bubble_mouseleave = function (elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseleave();

        if (call)
            nexacro.Calendar.prototype._on_bubble_mouseleave.call(this, elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridCalendar.on_notify_onkeydown = function (obj, e)
    {
        var grid = this._grid;

        if (e.keycode == nexacro.Event.KEY_DOWN && e.altkey)
        {
            grid._is_editor_keyaction = false;
        }
        if (!obj._displaymode)
        {
            return (nexacro.Calendar.prototype.on_notify_onkeydown.call(this, obj, e));
        }
    };

    _pGridCalendar.on_fire_onchanged = function (obj, pre_text, pre_value, post_text, post_value)
    {
        if (!obj._displaymode)
        {
            if (this._grid._p_autoupdatetype == "dateselect" || this._grid._p_autoupdatetype == "itemselect" || this._cellobj._band.id == "head")
            {
                // on_fire_onchanged는 발생되었지만 dataset은 갱신 안된 상태.
                this._setDataset(true, undefined, false, post_text, post_value, pre_value);
            }
            return (nexacro.Calendar.prototype.on_fire_onchanged.call(this, obj, pre_text, pre_value, post_text, post_value));
        }
    };

    _pGridCalendar.on_fire_user_ontouchend = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        var touchinfo = nexacro._getFirstTouchInfo(changedtouchinfos);

        if (this._isSubCell)
        {
            touchinfo.canvasx -= from_refer_comp._adjust_left;
            touchinfo.canvasy -= from_refer_comp._adjust_top;
            touchinfo.clientx -= from_refer_comp._adjust_left;
            touchinfo.clienty -= from_refer_comp._adjust_top;
        }

        nexacro.Calendar.prototype.on_fire_user_ontouchend.call(this, touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        this._cellobj.on_fire_user_ontouchend(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        return true;
    };

    _pGridCalendar.on_fire_user_onlbuttonup = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key)
    {
        if (from_refer_comp != this)
        {
            canvasX -= from_refer_comp._adjust_left;
            clientX -= from_refer_comp._adjust_left;
            canvasY -= from_refer_comp._adjust_top;
            clientY -= from_refer_comp._adjust_top;
        }

        nexacro.Calendar.prototype.on_fire_user_onlbuttonup.call(this, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key);
        this._cellobj.on_fire_user_onlbuttonup(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key);
        return true;
    };

    _pGridCalendar.on_fire_user_ontouchstart = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        var touchinfo = nexacro._getFirstTouchInfo(changedtouchinfos);

        if (this._isSubCell)
        {
            touchinfo.canvasx -= from_refer_comp._adjust_left;
            touchinfo.canvasy -= from_refer_comp._adjust_top;
            touchinfo.clientx -= from_refer_comp._adjust_left;
            touchinfo.clienty -= from_refer_comp._adjust_top;
        }

        nexacro.Calendar.prototype.on_fire_user_ontouchstart.call(this, touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        this._cellobj.on_fire_user_ontouchstart(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        return true;
    };

    _pGridCalendar.on_fire_user_onlbuttondown = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        if (from_refer_comp != this)
        {
            canvasX -= from_refer_comp._adjust_left;
            clientX -= from_refer_comp._adjust_left;
            canvasY -= from_refer_comp._adjust_top;
            clientY -= from_refer_comp._adjust_top;
        }

        nexacro.Calendar.prototype.on_fire_user_onlbuttondown.call(this, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
        this._cellobj.on_fire_user_onlbuttondown(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
        return true;
    };

    _pGridCalendar._on_edit_oneditclick = function (obj, e)
    {
        var padding = this._getCurrentStylePadding();
        var canvasX = e.canvasx + (padding ? padding.left : 0);
        var canvasY = e.canvasy + (padding ? padding.top : 0);
        var clientXY = this._getClientXY(canvasX, canvasY);
        this.on_fire_oneditclick(obj, e.caretpos, e.button, e.altkey, e.ctrlkey, e.shiftkey, e.screenx, e.screeny, e.canvasx, e.canvasy, e.clientx, e.clienty, e.fromobject, e.fromreferenceobject, e.metakey);
        var ret = this._cellobj.on_fire_onclick(e.button, e.altkey, e.ctrlkey, e.shiftkey, e.screenx, e.screeny, canvasX, canvasY, clientXY[0], clientXY[1], e.fromobject, e.fromreferenceobject, e.metakey, "control");
        if (this._type == "system")
        {

            var control_elem = this.getElement();
            if (control_elem)
            {
                var calendar = this._cellobj._editor;
                if (!calendar)
                {
                    calendar = this;
                }
                calendar.calendaredit._prevent_clickevent = false;

                var isdropdown = this._cellobj.on_fire_ondropdown(obj);
                if (isdropdown)
                {
                    nexacro._openSystemCalendar(calendar, this.value, "_on_notify_mobile_valuechanged");
                }

                calendar.calendaredit._prevent_clickevent = true;
            }
        }

        return ret;
    };

    _pGridCalendar._on_drop_onclick = function (obj, e)
    {
        nexacro.Calendar.prototype._on_drop_onclick.call(this, obj, e);

        var padding = this._getCurrentStylePadding();
        var canvasX = e.canvasx + (padding ? padding.left : 0);
        var canvasY = e.canvasy + (padding ? padding.top : 0);
        var clientXY = this._getClientXY(canvasX, canvasY);

        return this._cellobj.on_fire_onclick(e.button, e.altkey, e.ctrlkey, e.shiftkey, e.screenx, e.screeny, canvasX, canvasY, clientXY[0], clientXY[1], e.fromobject, e.fromreferenceobject, e.metakey, "control");
    };
    _pGridCalendar._on_drop_mobile_onclick = function (obj, e)
    {
        nexacro.Calendar.prototype._on_drop_mobile_onclick.call(this, obj, e);

        var padding = this._getCurrentStylePadding();
        var canvasX = e.canvasx + (padding ? padding.left : 0);
        var canvasY = e.canvasy + (padding ? padding.top : 0);
        var clientXY = this._getClientXY(canvasX, canvasY);

        return this._cellobj.on_fire_onclick(e.button, e.altkey, e.ctrlkey, e.shiftkey, e.screenx, e.screeny, canvasX, canvasY, clientXY[0], clientXY[1], e.fromobject, e.fromreferenceobject, e.metakey, "control");
    };

    _pGridCalendar._on_click = function (elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, meta_key)
    {
        if (!this._is_alive)
            return;

        var visible = this._p_visible;
        if (this._displaymode && this._grid._p_selectchangetype == "up")
            visible = true;

        if (visible && this._isEnable() && this.enableevent)
        {
            var clientXY = this._getClientXY(canvasX, canvasY);
            this.on_fire_onclick(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientXY[0], clientXY[1], this, this, meta_key, "control");
        }
    };

    _pGridCalendar._on_last_lbuttonup = function ()
    {
        this._cellobj._on_last_lbuttonup();
    };

    _pGridCalendar._on_last_keyup = function ()
    {
        this._cellobj._on_last_keyup();
    };


    //===============================================================
    // nexacro._GridCalendarControl : Logical Part
    //===============================================================
    _pGridCalendar._setDataset = function (b_async, row, fire, post_text, post_value, oldvalue)
    {
        var cellinfo = this._cellinfo;
        var grid = this._grid;
        var datarow = this._update_datarow;

        if (fire == undefined)
            fire = true;

        this._setValueCtrl(fire, post_text, post_value);

        if (row != undefined)
            datarow = row;

        var retn = true;

        if (this._is_value_changed)
        {
            if (cellinfo.text._bindtype == 1)
            {
                grid._is_async_recreate = b_async;
                grid._dsEventOccured = true;

                var fail = { status: "" };
                grid._binddataset.setColumn(datarow, cellinfo.text._bindexpr, this.value, fail);

                if (fail.status == "cancolumnchange")
                {
                    this._setValue(oldvalue);
                    retn = false;
                }
                grid._is_async_recreate = false;
                grid._dsEventOccured = false;
            }
            else if (datarow == -1)
            {
                var cellidx;

                if (oldvalue == undefined)
                    oldvalue = this._default_value;

                if (this._cellobj._isSubCell)
                {
                    cellidx = this._cellobj.parent._cellidx;
                }
                else
                {
                    cellidx = cellinfo._cellidx;
                }
                if (cellinfo._setValue(this.value))
                    grid._on_fire_onheadvaluechanged(oldvalue, this.value, cellidx);
            }
        }
        return retn;
    };

    nexacro._defineProperties(_pGridCalendar, _pGridCalendar._properties);

    _pGridCalendar = null;

    //===============================================================
    // nexacro._GridComboControl : Combo
    // description : use Event Notifiers, style control - controlType
    //===============================================================
    nexacro._GridComboControl = function (id, left, top, width, height, parent, displaymode, controlmode)
    {
        nexacro._CellComboControl.call(this, id, left, top, width, height, parent, displaymode, controlmode);
        if (parent._refinfo)
        {
            this._grid = parent._refinfo._grid;
            this._cellinfo = parent._refinfo;
            this._cellobj = parent;
        }
        else
        {
            //parent is grid
            this._grid = parent;
        }
    };

    var _pGridCombo = nexacro._createPrototype(nexacro._CellComboControl, nexacro._GridComboControl);
    nexacro._GridComboControl.prototype = _pGridCombo;

    //===============================================================
    // nexacro._GridComboControl : Create & Destroy & Update
    //===============================================================
    _pGridCombo.on_destroy_contents = function ()
    {
        nexacro._CellComboControl.prototype.on_destroy_contents.call(this);
        this._grid = null;
    };

    //===============================================================
    // nexacro._GridComboControl : Event Handlers
    //===============================================================
    _pGridCombo._on_bubble_touchend = function (touch_manager, touchinfos, changedtouchinfos, event_bubbles, fire_comp, refer_comp, is_userbubble)
    {
        var call = true;
        if (is_userbubble)
            call = this._cellobj._common_lbuttonup(changedtouchinfos, null, null, null, null);

        if (call)
            nexacro.Combo.prototype._on_bubble_touchend.call(this, touch_manager, touchinfos, changedtouchinfos, event_bubbles, fire_comp, refer_comp, is_userbubble);

        return true;
    };

    _pGridCombo._on_bubble_lbuttonup = function (elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, from_elem, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_lbuttonup(null, elem, canvasX, canvasY, from_elem);

        if (call)
            nexacro.Combo.prototype._on_bubble_lbuttonup.call(this, elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, from_elem, bubble_scope, meta_key);

        return true;
    };

    _pGridCombo._on_mouseenter = function (elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, meta_key)
    {
        if (this._isPopupVisible())
        {
            var cellobj = this._cellobj;
            if (cellobj)
            {
                var grid = cellobj._grid;
                grid._lastmouseentercell = null;
            }
        }
        return nexacro.Component.prototype._on_mouseenter.call(this, elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, meta_key);

    };

    _pGridCombo._on_bubble_mouseenter = function (elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseenter();

        if (call)
            nexacro.Combo.prototype._on_bubble_mouseenter.call(this, elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridCombo._on_bubble_mouseleave = function (elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseleave();

        if (call)
            nexacro.Combo.prototype._on_bubble_mouseleave.call(this, elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridCombo.on_fire_user_ontouchend = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        var touchinfo = nexacro._getFirstTouchInfo(changedtouchinfos);

        if (this._isSubCell)
        {
            touchinfo.canvasx -= from_refer_comp._adjust_left;
            touchinfo.canvasy -= from_refer_comp._adjust_top;
            touchinfo.clientx -= from_refer_comp._adjust_left;
            touchinfo.clienty -= from_refer_comp._adjust_top;
        }

        nexacro.Combo.prototype.on_fire_user_ontouchend.call(this, touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        this._cellobj.on_fire_user_ontouchend(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        return true;
    };

    _pGridCombo.on_fire_user_onlbuttonup = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key)
    {
        if (from_refer_comp != this)
        {
            canvasX -= from_refer_comp._adjust_left;
            clientX -= from_refer_comp._adjust_left;
            canvasY -= from_refer_comp._adjust_top;
            clientY -= from_refer_comp._adjust_top;
        }

        nexacro.Combo.prototype.on_fire_user_onlbuttonup.call(this, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key);
        this._cellobj.on_fire_user_onlbuttonup(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key);
        return true;
    };

    _pGridCombo.on_fire_user_ontouchstart = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        var touchinfo = nexacro._getFirstTouchInfo(changedtouchinfos);

        if (this._isSubCell)
        {
            touchinfo.canvasx -= from_refer_comp._adjust_left;
            touchinfo.canvasy -= from_refer_comp._adjust_top;
            touchinfo.clientx -= from_refer_comp._adjust_left;
            touchinfo.clienty -= from_refer_comp._adjust_top;
        }

        nexacro.Combo.prototype.on_fire_user_ontouchstart.call(this, touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        this._cellobj.on_fire_user_ontouchstart(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        return true;
    };

    _pGridCombo.on_fire_user_onlbuttondown = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        if (from_refer_comp != this)
        {
            canvasX -= from_refer_comp._adjust_left;
            clientX -= from_refer_comp._adjust_left;
            canvasY -= from_refer_comp._adjust_top;
            clientY -= from_refer_comp._adjust_top;
        }

        nexacro.Combo.prototype.on_fire_user_onlbuttondown.call(this, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
        this._cellobj.on_fire_user_onlbuttondown(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
        return true;
    };

    _pGridCombo.on_fire_onitemchanged = function (obj, preindex, pretext, prevalue, postindex, posttext, postvalue)
    {
        if (!obj._displaymode)
        {
            if (this._grid._p_autoupdatetype == "comboselect" || this._grid._p_autoupdatetype == "itemselect" || this._cellobj._band.id == "head")
                this._setDataset(true, undefined, prevalue);

            return (nexacro.Combo.prototype.on_fire_onitemchanged.call(this, obj, preindex, pretext, prevalue, postindex, posttext, postvalue));
        }
    };

    _pGridCombo._on_edit_oneditclick = function (obj, e)
    {
        var padding = this._getCurrentStylePadding();
        var canvasX = e.canvasx + (padding ? padding.left : 0);
        var canvasY = e.canvasy + (padding ? padding.top : 0);
        var clientXY = this._getClientXY(canvasX, canvasY);

        return this._cellobj.on_fire_onclick(e.button, e.altkey, e.ctrlkey, e.shiftkey, e.screenx, e.screeny, canvasX, canvasY, clientXY[0], clientXY[1], e.fromobject, e.fromreferenceobject, e.metakey, "control");
    };

    _pGridCombo._on_edit_mobile_oneditclick = function (obj, e)
    {
        nexacro.Combo.prototype._on_edit_mobile_oneditclick.call(this, obj, e);

        var padding = this._getCurrentStylePadding();
        var canvasX = e.canvasx + (padding ? padding.left : 0);
        var canvasY = e.canvasy + (padding ? padding.top : 0);
        var clientXY = this._getClientXY(canvasX, canvasY);

        return this._cellobj.on_fire_onclick(e.button, e.altkey, e.ctrlkey, e.shiftkey, e.screenx, e.screeny, canvasX, canvasY, clientXY[0], clientXY[1], e.fromobject, e.fromreferenceobject, e.metakey, "control");
    };

    _pGridCombo._on_drop_mobile_onclick = function (obj, e)
    {
        nexacro.Combo.prototype._on_drop_mobile_onclick.call(this, obj, e);

        var padding = this._getCurrentStylePadding();
        var canvasX = e.canvasx + (padding ? padding.left : 0);
        var canvasY = e.canvasy + (padding ? padding.top : 0);
        var clientXY = this._getClientXY(canvasX, canvasY);

        return this._cellobj.on_fire_onclick(e.button, e.altkey, e.ctrlkey, e.shiftkey, e.screenx, e.screeny, canvasX, canvasY, clientXY[0], clientXY[1], e.fromobject, e.fromreferenceobject, e.metakey, "control");
    };

    _pGridCombo._on_drop_onclick = function (obj, e)
    {
        nexacro.Combo.prototype._on_drop_onclick.call(this, obj, e);

        var padding = this._getCurrentStylePadding();
        var canvasX = e.canvasx + (padding ? padding.left : 0);
        var canvasY = e.canvasy + (padding ? padding.top : 0);
        var clientXY = this._getClientXY(canvasX, canvasY);

        return this._cellobj.on_fire_onclick(e.button, e.altkey, e.ctrlkey, e.shiftkey, e.screenx, e.screeny, canvasX, canvasY, clientXY[0], clientXY[1], e.fromobject, e.fromreferenceobject, e.metakey, "control");
    };

    _pGridCombo._on_click = function (elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, meta_key)
    {
        if (!this._is_alive)
            return;

        var visible = this._p_visible;
        if (this._displaymode && this._grid._p_selectchangetype == "up")
            visible = true;

        if (visible && this._isEnable() && this.enableevent)
        {
            var clientXY = this._getClientXY(canvasX, canvasY);
            this.on_fire_onclick(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientXY[0], clientXY[1], this, this, meta_key);
        }
    };

    _pGridCombo._on_last_lbuttonup = function ()
    {
        this._cellobj._on_last_lbuttonup();
    };

    _pGridCombo._on_last_keyup = function ()
    {
        this._cellobj._on_last_keyup();
    };

    //===============================================================
    // nexacro._GridComboControl : Logical Part
    //===============================================================
    _pGridCombo._setDataset = function (b_async, row, prevalue)
    {
        var cellinfo = this._cellinfo;
        var grid = this._grid;
        var datarow = this._update_datarow;

        if (row != undefined)
            datarow = row;

        var retn = true;

        if (cellinfo.text._bindtype == 1)
        {
            grid._is_async_recreate = b_async;
            grid._dsEventOccured = true;

            var fail = { status: "" };
            grid._binddataset.setColumn(datarow, cellinfo.text._bindexpr, this.value, fail);

            if (fail.status == "cancolumnchange")
            {
                this.set_value(prevalue);
                retn = false;
            }
            grid._is_async_recreate = false;
            grid._dsEventOccured = false;
        }
        else if (datarow == -1)
        {
            var cellidx;
            if (this._cellobj._isSubCell)
            {
                cellidx = this._cellobj.parent._cellidx;
            }
            else
            {
                cellidx = cellinfo._cellidx;
            }
            if (cellinfo._setValue(this.value))
                grid._on_fire_onheadvaluechanged(prevalue, this.value, cellidx);
        }
        return retn;
    };

    _pGridCombo = null;


    //===============================================================
    // nexacro._GridMultiComboControl : MultiCombo
    // description : use Event Notifiers, style control - controlType
    //===============================================================
    nexacro._GridMultiComboControl = function (id, left, top, width, height, parent, displaymode, controlmode)
    {
        nexacro._CellMultiComboControl.call(this, id, left, top, width, height, parent, displaymode, controlmode);
        if (parent._refinfo)
        {
            this._grid = parent._refinfo._grid;
            this._cellinfo = parent._refinfo;
            this._cellobj = parent;
        }
        else
        {
            //parent is grid
            this._grid = parent;
        }
    };

    var _pGridMultiCombo = nexacro._createPrototype(nexacro._CellMultiComboControl, nexacro._GridMultiComboControl);
    nexacro._GridMultiComboControl.prototype = _pGridMultiCombo;

    //===============================================================
    // nexacro._GridMultiComboControl : Create & Destroy & Update
    //===============================================================
    _pGridMultiCombo.on_destroy_contents = function ()
    {
        nexacro._CellMultiComboControl.prototype.on_destroy_contents.call(this);
        this._grid = null;
    };

    //===============================================================
    // nexacro._GridMultiComboControl : Event Handlers
    //===============================================================
    _pGridMultiCombo._on_bubble_touchend = function (touch_manager, touchinfos, changedtouchinfos, event_bubbles, fire_comp, refer_comp, is_userbubble)
    {
        var call = true;
        if (is_userbubble)
            call = this._cellobj._common_lbuttonup(changedtouchinfos, null, null, null, null);

        if (call)
            nexacro.MultiCombo.prototype._on_bubble_touchend.call(this, touch_manager, touchinfos, changedtouchinfos, event_bubbles, fire_comp, refer_comp, is_userbubble);

        return true;
    };

    _pGridMultiCombo._on_bubble_lbuttonup = function (elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, from_elem, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_lbuttonup(null, elem, canvasX, canvasY, from_elem);

        if (call)
            nexacro.MultiCombo.prototype._on_bubble_lbuttonup.call(this, elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, from_elem, bubble_scope, meta_key);

        return true;
    };

    _pGridMultiCombo._on_mouseenter = function (elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, meta_key)
    {
        if (this._isPopupVisible())
        {
            var cellobj = this._cellobj;
            if (cellobj)
            {
                var grid = cellobj._grid;
                grid._lastmouseentercell = null;
            }
        }
        return nexacro.Component.prototype._on_mouseenter.call(this, elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, meta_key);

    };

    _pGridMultiCombo._on_bubble_mouseenter = function (elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseenter();

        if (call)
            nexacro.MultiCombo.prototype._on_bubble_mouseenter.call(this, elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridMultiCombo._on_bubble_mouseleave = function (elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseleave();

        if (call)
            nexacro.MultiCombo.prototype._on_bubble_mouseleave.call(this, elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridMultiCombo.on_fire_user_ontouchend = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        var touchinfo = nexacro._getFirstTouchInfo(changedtouchinfos);

        if (this._isSubCell)
        {
            touchinfo.canvasx -= from_refer_comp._adjust_left;
            touchinfo.canvasy -= from_refer_comp._adjust_top;
            touchinfo.clientx -= from_refer_comp._adjust_left;
            touchinfo.clienty -= from_refer_comp._adjust_top;
        }

        nexacro.MultiCombo.prototype.on_fire_user_ontouchend.call(this, touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        this._cellobj.on_fire_user_ontouchend(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        return true;
    };

    _pGridMultiCombo.on_fire_user_onlbuttonup = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key)
    {
        if (from_refer_comp != this)
        {
            canvasX -= from_refer_comp._adjust_left;
            clientX -= from_refer_comp._adjust_left;
            canvasY -= from_refer_comp._adjust_top;
            clientY -= from_refer_comp._adjust_top;
        }

        nexacro.MultiCombo.prototype.on_fire_user_onlbuttonup.call(this, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key);
        this._cellobj.on_fire_user_onlbuttonup(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key);
        return true;
    };

    _pGridMultiCombo.on_fire_user_ontouchstart = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        var touchinfo = nexacro._getFirstTouchInfo(changedtouchinfos);

        if (this._isSubCell)
        {
            touchinfo.canvasx -= from_refer_comp._adjust_left;
            touchinfo.canvasy -= from_refer_comp._adjust_top;
            touchinfo.clientx -= from_refer_comp._adjust_left;
            touchinfo.clienty -= from_refer_comp._adjust_top;
        }

        nexacro.MultiCombo.prototype.on_fire_user_ontouchstart.call(this, touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        this._cellobj.on_fire_user_ontouchstart(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        return true;
    };

    _pGridMultiCombo.on_fire_user_onlbuttondown = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        if (from_refer_comp != this)
        {
            canvasX -= from_refer_comp._adjust_left;
            clientX -= from_refer_comp._adjust_left;
            canvasY -= from_refer_comp._adjust_top;
            clientY -= from_refer_comp._adjust_top;
        }

        nexacro.MultiCombo.prototype.on_fire_user_onlbuttondown.call(this, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
        this._cellobj.on_fire_user_onlbuttondown(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
        return true;
    };

    _pGridMultiCombo.on_fire_onitemchanged = function (obj, preindex, pretext, prevalue, postindex, posttext, postvalue)
    {
        if (!obj._displaymode)
        {
            if (this._grid._p_autoupdatetype == "comboselect" || this._grid._p_autoupdatetype == "itemselect" || this._cellobj._band.id == "head")
                this._setDataset(true, undefined, prevalue);

            return (nexacro.MultiCombo.prototype.on_fire_onitemchanged.call(this, obj, preindex, pretext, prevalue, postindex, posttext, postvalue));
        }
    };

    _pGridMultiCombo._on_edit_oneditclick = function (obj, e)
    {
        var padding = this._getCurrentStylePadding();
        var canvasX = e.canvasx + (padding ? padding.left : 0);
        var canvasY = e.canvasy + (padding ? padding.top : 0);
        var clientXY = this._getClientXY(canvasX, canvasY);

        return this._cellobj.on_fire_onclick(e.button, e.altkey, e.ctrlkey, e.shiftkey, e.screenx, e.screeny, canvasX, canvasY, clientXY[0], clientXY[1], e.fromobject, e.fromreferenceobject, e.metakey, "control");
    };

    _pGridMultiCombo._on_edit_mobile_oneditclick = function (obj, e)
    {
        nexacro.MultiCombo.prototype._on_edit_mobile_oneditclick.call(this, obj, e);

        var padding = this._getCurrentStylePadding();
        var canvasX = e.canvasx + (padding ? padding.left : 0);
        var canvasY = e.canvasy + (padding ? padding.top : 0);
        var clientXY = this._getClientXY(canvasX, canvasY);

        return this._cellobj.on_fire_onclick(e.button, e.altkey, e.ctrlkey, e.shiftkey, e.screenx, e.screeny, canvasX, canvasY, clientXY[0], clientXY[1], e.fromobject, e.fromreferenceobject, e.metakey, "control");
    };

    _pGridMultiCombo._on_drop_mobile_onclick = function (obj, e)
    {
        nexacro.MultiCombo.prototype._on_drop_mobile_onclick.call(this, obj, e);

        var padding = this._getCurrentStylePadding();
        var canvasX = e.canvasx + (padding ? padding.left : 0);
        var canvasY = e.canvasy + (padding ? padding.top : 0);
        var clientXY = this._getClientXY(canvasX, canvasY);

        return this._cellobj.on_fire_onclick(e.button, e.altkey, e.ctrlkey, e.shiftkey, e.screenx, e.screeny, canvasX, canvasY, clientXY[0], clientXY[1], e.fromobject, e.fromreferenceobject, e.metakey, "control");
    };

    _pGridMultiCombo._on_drop_onclick = function (obj, e)
    {
        nexacro.MultiCombo.prototype._on_drop_onclick.call(this, obj, e);

        var padding = this._getCurrentStylePadding();
        var canvasX = e.canvasx + (padding ? padding.left : 0);
        var canvasY = e.canvasy + (padding ? padding.top : 0);
        var clientXY = this._getClientXY(canvasX, canvasY);

        return this._cellobj.on_fire_onclick(e.button, e.altkey, e.ctrlkey, e.shiftkey, e.screenx, e.screeny, canvasX, canvasY, clientXY[0], clientXY[1], e.fromobject, e.fromreferenceobject, e.metakey, "control");
    };

    _pGridMultiCombo._on_click = function (elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, meta_key)
    {
        if (!this._is_alive)
            return;

        var visible = this._p_visible;
        if (this._displaymode && this._grid._p_selectchangetype == "up")
            visible = true;

        if (visible && this._isEnable() && this.enableevent)
        {
            var clientXY = this._getClientXY(canvasX, canvasY);
            this.on_fire_onclick(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientXY[0], clientXY[1], this, this, meta_key);
        }
    };

    _pGridMultiCombo._on_last_lbuttonup = function ()
    {
        this._cellobj._on_last_lbuttonup();
    };

    _pGridMultiCombo._on_last_keyup = function ()
    {
        this._cellobj._on_last_keyup();
    };

    //===============================================================
    // nexacro._GridMultiComboControl : Logical Part
    //===============================================================
    _pGridMultiCombo._setDataset = function (b_async, row, prevalue)
    {
        var cellinfo = this._cellinfo;
        var grid = this._grid;
        var datarow = this._update_datarow;

        if (row != undefined)
            datarow = row;

        var retn = true;

        if (cellinfo.text._bindtype == 1)
        {
            grid._is_async_recreate = b_async;
            grid._dsEventOccured = true;

            var fail = { status: "" };
            grid._binddataset.setColumn(datarow, cellinfo.text._bindexpr, this.value, fail);

            if (fail.status == "cancolumnchange")
            {
                this.set_value(prevalue);
                retn = false;
            }
            grid._is_async_recreate = false;
            grid._dsEventOccured = false;
        }
        else if (datarow == -1)
        {
            var cellidx;
            if (this._cellobj._isSubCell)
            {
                cellidx = this._cellobj.parent._cellidx;
            }
            else
            {
                cellidx = cellinfo._cellidx;
            }
            if (cellinfo._setValue(this.value))
                grid._on_fire_onheadvaluechanged(prevalue, this.value, cellidx);
        }
        return retn;
    };

    _pGridMultiCombo = null;

    //===============================================================
    // nexacro._GridCellControlCheckbox : CheckBox
    // description : use Event Notifiers, style control - controlType
    //===============================================================
    nexacro._GridCellControlCheckbox = function (id, left, top, width, height, parent)
    {
        nexacro._CellCheckboxControlBase.call(this, id, left, top, width, height, parent);
    };

    var _pGridCellCheckbox = nexacro._createPrototype(nexacro._CellCheckboxControlBase, nexacro._GridCellControlCheckbox);
    nexacro._GridCellControlCheckbox.prototype = _pGridCellCheckbox;

    //===============================================================
    // nexacro._GridCellControlCheckbox : Create & Destroy & Update
    //===============================================================

    //===============================================================
    // nexacro._GridCellControlCheckbox : Event Handlers
    //===============================================================
    _pGridCellCheckbox.on_notify_checkbox_onkeydown = function (/*obj, e*/)
    {
    };

    _pGridCellCheckbox._on_last_lbuttonup = function ()
    {
        this._cellobj._on_last_lbuttonup();
    };

    _pGridCellCheckbox._on_last_keyup = function ()
    {
        this._cellobj._on_last_keyup();
    };

    //===============================================================
    // nexacro._GridCellControlCheckbox : Logical Part
    //===============================================================

    _pGridCellCheckbox = null;

    //===============================================================
    // nexacro._GridCheckboxControl : GridCellCheckBox
    // description : use Event Notifiers, style control - controlType
    //===============================================================
    nexacro._GridCheckboxControl = function (id, left, top, width, height, parent, controlmode)
    {
        nexacro._GridCellControlCheckbox.call(this, id, left, top, width, height, parent);
        this._controlmode = (controlmode) ? true : false;
        this._grid = this._view;
    };

    var _pGridCheckbox = nexacro._createPrototype(nexacro._GridCellControlCheckbox, nexacro._GridCheckboxControl);
    nexacro._GridCheckboxControl.prototype = _pGridCheckbox;

    _pGridCheckbox.on_destroy_contents = function ()
    {
        nexacro._GridCellControlCheckbox.prototype.on_destroy_contents.call(this);
        this._grid = null;
    };


    //===============================================================
    // nexacro._GridCheckboxControl : Properties
    //===============================================================


    //===============================================================
    // nexacro._GridCheckboxControl : Event Handlers
    //===============================================================
    _pGridCheckbox._on_bubble_mouseenter = function (elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseenter();

        if (call)
            nexacro._GridCellControlCheckbox.prototype._on_bubble_mouseenter.call(this, elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridCheckbox._on_bubble_mouseleave = function (elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseleave();

        if (call)
            nexacro._GridCellControlCheckbox.prototype._on_bubble_mouseleave.call(this, elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridCheckbox._common_fire_lbuttondown = function (/*from_comp*/)
    {
        var grid = this._grid;

        if (grid)
        {
            var datarow = grid._getDataRow(this._cellobj._rowidx);
            if (grid._isFakeCell(datarow))
                return false;
        }
    };

    _pGridCheckbox.on_fire_user_ontouchstart = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        this._common_fire_lbuttondown();
        return this._cellobj.on_fire_user_ontouchstart(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
    };

    _pGridCheckbox.on_fire_user_onlbuttondown = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        this._common_fire_lbuttondown();
        return this._cellobj.on_fire_user_onlbuttondown(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
    };

    _pGridCheckbox.on_fire_user_ontouchend = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        nexacro._GridCellControlCheckbox.prototype.on_fire_user_ontouchend.call(this, touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        this._cellobj.on_fire_user_ontouchend(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        return true;
    };

    _pGridCheckbox.on_fire_user_onlbuttonup = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key)
    {
        nexacro._GridCellControlCheckbox.prototype.on_fire_user_onlbuttonup.call(this, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key);
        this._cellobj.on_fire_user_onlbuttonup(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key);
        return true;
    };

    _pGridCheckbox.on_fire_onclick = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        var grid = this._grid;

        if (grid)
        {
            var datarow = grid._getDataRow(this._cellobj._rowidx);
            if (grid._isFakeCell(datarow))
                return false;
        }

        if (grid._p_selectchangetype != "down")
        {
            if (nexacro._toBoolean(grid._p_readonly) == false)
                this._toggleCheck();
        }

        if (!this._is_alive)
            return;

        return this._cellobj.on_fire_onclick(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key, "control");
    };

    _pGridCheckbox.on_fire_ondblclick = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        var grid = this._grid;
        if (grid)
        {
            var datarow = grid._getDataRow(this._cellobj._rowidx);
            if (grid._isFakeCell(datarow))
                return false;
        }

        return this._cellobj.on_fire_ondblclick(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key, "control");
    };

    //===============================================================
    // nexacro._GridCheckboxControl : Logical Part
    //===============================================================
    _pGridCheckbox._toggleCheck = function ()
    {
        var cellobj = this._cellobj;
        var cellinfo = this._cellinfo;
        var grid = this._grid;
        var datarow = grid._getDataRow(cellobj._rowidx);
        var editType = cellinfo._getEdittype(datarow);

        if (editType == "checkbox")
        {
            var v = this._isChecked(this.value);

            if (v)
                v = nexacro._isNull(this.falsevalue) ? 0 : this.falsevalue;
            else
                v = nexacro._isNull(this.truevalue) ? 1 : this.truevalue;

            if (datarow >= 0)
            {
                grid._dsEventOccured = true;
                //cellinfo._grid._binddataset.setColumn(datarow, cellinfo.text._bindexpr, v);
                grid._setCheck(cellinfo._col, datarow, cellinfo._row, v, this.falsevalue);
                grid._dsEventOccured = false;
            }
            else if (datarow < 0)
            {
                this.set_value(v);

                var cellidx;
                if (this._cellobj._isSubCell)
                    cellidx = this._cellobj.parent._cellidx;
                else
                    cellidx = cellinfo._cellidx;

                var prevalue = cellinfo._value;

                if (datarow == -1)
                {
                    if (cellinfo._setValue(this.value))
                        grid._on_fire_onheadvaluechanged(prevalue, this.value, cellidx);
                }
            }
        }
    };

    _pGridCheckbox._getCheckValue = function ()
    {
        var cellobj = this._cellobj;
        var datarow = cellobj._getDataRow();

        if (datarow < 0)
            return nexacro._GridCellControlCheckbox.prototype._getCheckValue.call(this);

        var grid = this._grid;
        var cellinfo = this._cellinfo;

        var v = grid._getCheck(cellinfo._col, datarow, cellinfo._row);

        return v;
    };

    _pGridCheckbox._getDisplayText = function ()
    {
        if (this.parent)
        {
            return this.parent._getDisplayText();
        }
        return "";
    };

    _pGridCheckbox = null;

    //===============================================================
    // nexacro._CellRadioItemControl
    //===============================================================
    nexacro._GridRadioItemControl = function (id, left, top, width, height, parent, controlmode)
    {
        nexacro._CellRadioItemControl.call(this, id, left, top, width, height, parent);
        this._controlmode = (controlmode) ? true : false;
        this._grid = this._view;
    };

    var _pGridRadioItem = nexacro._createPrototype(nexacro._CellRadioItemControl, nexacro._GridRadioItemControl);
    nexacro._GridRadioItemControl.prototype = _pGridRadioItem;

    _pGridRadioItem.on_destroy_contents = function ()
    {
        nexacro._CellRadioItemControl.prototype.on_destroy_contents.call(this);
        this._grid = null;
    };

    _pGridRadioItem._on_bubble_mouseenter = function (elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseenter();

        if (call)
            nexacro._CellRadioItemControl.prototype._on_bubble_mouseenter.call(this, elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridRadioItem._on_bubble_mouseleave = function (elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseleave();

        if (call)
            nexacro._CellRadioItemControl.prototype._on_bubble_mouseleave.call(this, elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridRadioItem._common_fire_lbuttondown = function (/*from_comp*/)
    {
        var grid = this._grid;

        if (grid)
        {
            var datarow = grid._getDataRow(this._cellobj._rowidx);
            if (grid._isFakeCell(datarow))
                return false;
        }
    };

    _pGridRadioItem.on_fire_user_ontouchstart = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        this._common_fire_lbuttondown();
        return this._cellobj.on_fire_user_ontouchstart(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
    };

    _pGridRadioItem.on_fire_user_onlbuttondown = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        this._common_fire_lbuttondown();
        return this._cellobj.on_fire_user_onlbuttondown(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
    };

    _pGridRadioItem.on_fire_user_ontouchend = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        nexacro._CellRadioItemControl.prototype.on_fire_user_ontouchend.call(this, touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        this._cellobj.on_fire_user_ontouchend(touchinfos, changedtouchinfos, from_comp, from_refer_comp);
        return true;
    };

    _pGridRadioItem.on_fire_user_onlbuttonup = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key)
    {
        nexacro._CellRadioItemControl.prototype.on_fire_user_onlbuttonup.call(this, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key);
        this._cellobj.on_fire_user_onlbuttonup(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key);
        return true;
    };

    _pGridRadioItem.on_fire_onclick = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        var grid = this._grid;

        if (grid)
        {
            var datarow = grid._getDataRow(this._cellobj._rowidx);
            if (grid._isFakeCell(datarow))
                return false;
        }

        if (grid._p_selectchangetype != "down")
        {
            if (nexacro._toBoolean(grid._p_readonly) == false)
                this._itemSelect();
        }

        if (!this._is_alive)
            return;

        return this._cellobj.on_fire_onclick(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key, "control");
    };

    _pGridRadioItem.on_fire_ondblclick = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        var grid = this._grid;
        if (grid)
        {
            var datarow = grid._getDataRow(this._cellobj._rowidx);
            if (grid._isFakeCell(datarow))
                return false;
        }

        return this._cellobj.on_fire_ondblclick(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key, "control");
    };

    _pGridRadioItem = null;
    //===============================================================
    // nexacro._GridImageControl    
    //===============================================================
    nexacro._GridImageControl = function (id, left, top, width, height, parent)
    {
        nexacro._CellImageControl.call(this, id, left, top, width, height, parent);

        if (parent._refinfo)
        {
            this._grid = parent._refinfo._grid;
            this._cellinfo = parent._refinfo;
            this._cellobj = parent;
        }
    };

    var _pGridImage = nexacro._createPrototype(nexacro._CellImageControl, nexacro._GridImageControl);
    nexacro._GridImageControl.prototype = _pGridImage;

    //===============================================================
    // nexacro._GridImageControl : Create & Destroy & Update
    //===============================================================
    _pGridImage.on_destroy_contents = function ()
    {
        nexacro._CellImageControl.prototype.on_destroy_contents.call(this);
        this._grid = null;
    };

    //===============================================================
    // nexacro._GridImageControl : Event Handlers
    //===============================================================
    _pGridImage._on_bubble_mouseenter = function (elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseenter();

        if (call)
            nexacro.Component.prototype._on_bubble_mouseenter.call(this, elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridImage._on_bubble_mouseleave = function (elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseleave();

        if (call)
            nexacro.Component.prototype._on_bubble_mouseleave.call(this, elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridImage.on_fire_onclick = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        return this.parent.on_fire_onclick(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key, "image");
    };

    _pGridImage.on_fire_user_onlbuttondown = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        return this.parent.on_fire_user_onlbuttondown(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, this, from_refer_comp, meta_key);
    };

    _pGridImage.on_fire_user_ontouchend = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        return this.parent.on_fire_user_ontouchend(touchinfos, changedtouchinfos, this, from_refer_comp);
    };

    _pGridImage.on_fire_user_onlbuttonup = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key)
    {
        return this.parent.on_fire_user_onlbuttonup(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, this, from_refer_comp, from_elem, meta_key);
    };

    _pGridImage.on_fire_user_onkeydown = function (key_code, alt_key, ctrl_key, shift_key, from_comp, from_refer_comp, meta_key)
    {
        return this.parent.on_fire_user_onkeydown(key_code, alt_key, ctrl_key, shift_key, this, from_refer_comp, meta_key);
    };

    _pGridImage.on_fire_user_onkeyup = function (key_code, alt_key, ctrl_key, shift_key, from_comp, from_refer_comp, meta_key)
    {
        return this.parent.on_fire_user_onkeyup(key_code, alt_key, ctrl_key, shift_key, this, from_refer_comp, meta_key);
    };

    _pGridImage._on_last_lbuttonup = function ()
    {
        this._cellobj._on_last_lbuttonup();
    };

    _pGridImage._on_last_keyup = function ()
    {
        this._cellobj._on_last_keyup();
    };

    _pGridImage._on_fire_onimageerror = function (url)
    {
        var grid = this._grid;
        var cellobj = this._cellobj;
        if (grid && cellobj)
        {
            var row = grid._getDataRow(cellobj._rowidx);
            var cell = cellobj._cellidx;
            return grid.on_fire_onimageerror(grid, url, row, cell);
        }
    };

    //===============================================================
    // nexacro._GridImageControl : Logical Part
    //===============================================================

    _pGridImage = null;

    //===============================================================
    // nexacro._GridSelectorButtonControl
    //===============================================================
    nexacro._GridSelectorButtonControl = function (id, left, top, width, height, right, bottom, parent, target, idx)
    {
        nexacro.Button.call(this, id, left, top, width, height, right, bottom, null, null, null, null, target);
        this._real_parent = parent;
        this._band = parent._band;
        this._grid = target;
        this._idx = idx;
        this._point = { x: 0, y: 0, w: 0, h: 0 };
        this._minibox = null;
        this._minibox_size = 8;
        this._minibox_wgap = 0;
        this._minibox_hgap = 0;
        this._minibox_backcolor = "black";
        this._is_track = true;
        this._setControl();
    };
    var _pGridSelectorButtonControl = nexacro._GridSelectorButtonControl.prototype = nexacro._createPrototype(nexacro.Button, nexacro._GridSelectorButtonControl);
    _pGridSelectorButtonControl._is_subcontrol = true;

    _pGridSelectorButtonControl._updateMiniBox = function ()
    {
        if (!this.image || !this._image_width || !this._image_height)
        {
            var x = (this._adjust_height - this._minibox_size) / 2;

            this._minibox_wgap = x;
            this._minibox_hgap = x;

            if (!this._minibox)
            {
                this._minibox = new nexacro.Component("minibox", x, x, this._minibox_size, this._minibox_size, null, null, null, null, null, null, this);
                this._minibox._is_simple_control = true;
                this._minibox._is_track = true;
                this._minibox.set_background(this._minibox_backcolor);

                this._minibox._on_starttrack = function ()
                {
                    return this.parent._on_starttrack();
                };
                this._minibox._on_movetrack = function (x, y, dragdata)
                {
                    return this.parent._on_movetrack(x, y, dragdata);
                };
                this._minibox._on_endtrack = function (x, y, dragdata)
                {
                    return this.parent._on_endtrack(x, y, dragdata);
                };

                this._minibox.createComponent();
            }
            else
            {
                this._minibox.move(x, x, this._minibox_size, this._minibox_size);
            }
        }
        else
        {
            if (this._minibox)
            {
                this._minibox.destroy();
                this._minibox = null;
            }
            if (this._img_elem)
            {
                this._minibox_wgap = (this._adjust_width - this._image_width) / 2;
                this._minibox_hgap = (this._adjust_height - this._image_height) / 2;

                // image가 크면 buttonsize로 고정
                if (this._minibox_wgap < 0)
                    this._minibox_wgap = 0;
                if (this._minibox_hgap < 0)
                    this._minibox_hgap = 0;
            }
        }
    };

    _pGridSelectorButtonControl.on_fire_onsize = function (/*width, height*/)
    {
        this._updateMiniBox();
    };

    _pGridSelectorButtonControl.on_create_contents = function ()
    {
        nexacro.Button.prototype.on_create_contents.call(this);
        this._updateMiniBox();
    };

    _pGridSelectorButtonControl.on_created_contents = function (win)
    {
        nexacro.Button.prototype.on_created_contents.call(this, win);

        if (this._minibox)
        {
            this._minibox.on_created();
        }
    };

    _pGridSelectorButtonControl.on_destroy_contents = function ()
    {
        this._band = null;
        this._grid = null;
        this._minibox = null;
        this._real_parent = null;
        nexacro.Button.prototype.on_destroy_contents.call(this);
    };

    _pGridSelectorButtonControl._on_starttrack = function ()
    {
        var p = this._real_parent;
        p._is_tracking = true;
        p._track_reset_scroll = false;
        p._track_up_scroll = false;

        var scroll_top = this._grid._getScrollTop();
        var scroll_left = this._grid._getScrollLeft();

        this._point.hgap = 0;
        this._point.wgap = 0;
        this._point.scrolltop = scroll_top;
        this._point.scrollleft = scroll_left;

        this._point.x = p._area_pos.l;
        this._point.y = p._area_pos.t;
        this._point.w = p._area_pos.w;
        this._point.h = p._area_pos.h;


        var start_row = -1, end_row = -1; //start_col = -1, end_col = -1;
        var select_area = this._grid._selectinfo.area;
        if (select_area.length > 0)
        {
            var area = select_area[select_area.length - 1];
            start_row = area.begrow;
            end_row = area.endrow;
            //start_col = area.begrow;
            //end_col = area.endrow;

            if (this._idx != p._pre_idx)
            {
                var areainfo = this._grid._selectinfo.areainfo;
                var ctrlpoint = this._grid._selectinfo.ctrlpoint;
                var cellinfo;
                if (areainfo)
                {
                    var format = this._grid._curFormat;
                    var subrowlen = format._bodyrows.length;
                    if (this._idx == 0)
                    {
                        cellinfo = format._bodycells[areainfo.ecell];
                        ctrlpoint._set(cellinfo, areainfo.erow, subrowlen);
                    }
                    else if (this._idx == 1)
                    {
                        cellinfo = format._bodycells[areainfo.scell];
                        ctrlpoint._set(cellinfo, areainfo.srow, subrowlen);
                    }
                    else if (this._idx == 2)
                    {
                        cellinfo = format._bodycells[areainfo.ecell];
                        ctrlpoint._set(cellinfo, areainfo.srow, subrowlen);
                    }
                    else if (this._idx == 3)
                    {
                        cellinfo = format._bodycells[areainfo.scell];
                        ctrlpoint._set(cellinfo, areainfo.erow, subrowlen);
                    }
                }
            }
        }


        if (this._grid._fixed_rowcnt > 0)
        {
            //var headheight = this._grid._getHeadHeight();
            //var fixedheight = this._grid._fixed_height;
            //var fixedbottom = headheight + fixedheight;

            if (start_row >= this._grid._fixed_startrow && start_row <= this._grid._fixed_endrow)
            {
                this._point.y = p._area_pos.t += this._point.scrolltop;

                if (end_row > this._grid._fixed_endrow && scroll_top > 0)
                {
                    if (p._end_scroll_top >= 0)
                    {
                        this._point.h = p._area_pos.h -= scroll_top;
                    }

                }
            }
        }

        p.set_visible(true);
        p._trackbar[0].set_visible(false);
        p._trackbar[1].set_visible(false);
        p._trackbar[2].set_visible(false);
        p._trackbar[3].set_visible(false);

        p._start_begarea = this._grid._selectinfo.arearect.barea;
        p._start_endarea = this._grid._selectinfo.arearect.earea;

        if (this._idx == 0)
            this._area = p._start_begarea;
        else
            this._area = p._start_endarea;

        this._grid._track_mode = "areaselect";


        p._callback_start.call(this._grid, p._area_pos, this._idx);
    };

    _pGridSelectorButtonControl._on_movetrack = function (x, y/*, dragdata*/)
    {
        var p = this._real_parent;

        var cur_scrolltop = this._grid._getScrollTop();
        var cur_scrollleft = this._grid._getScrollLeft();

        var scroll_top_gap = 0, scroll_left_gap = 0;

        if (p._start_scroll_top >= 0)
            scroll_top_gap = p._start_scroll_top - cur_scrolltop;
        if (p._start_scroll_left >= 0)
            scroll_left_gap = p._start_scroll_left - cur_scrollleft;

        var ctrl_row = this._grid._selectinfo.ctrlpoint.row;

        var bApply_scroll_top = true;
        if (this._grid._fixed_rowcnt > 0 && ctrl_row >= this._grid._fixed_startrow && ctrl_row <= this._grid._fixed_endrow)
            bApply_scroll_top = false;

        var l, t, w, h;
        if (this._idx == 0)
        {
            l = this._point.x + x;
            t = this._point.y + y;
            w = this._point.w - x + scroll_left_gap;
            h = this._point.h - y + (bApply_scroll_top ? scroll_top_gap : 0);
        }
        else if (this._idx == 1)
        {
            l = this._point.x + scroll_left_gap;
            t = this._point.y + (bApply_scroll_top ? scroll_top_gap : 0);
            w = this._point.w + x - scroll_left_gap;
            h = this._point.h + y - (bApply_scroll_top ? scroll_top_gap : 0);

        }
        else if (this._idx == 2)
        {
            l = this._point.x + x;
            t = this._point.y;
            w = this._point.w - x;
            h = this._point.h + y;
        }
        else if (this._idx == 3)
        {
            l = this._point.x;
            t = this._point.y + y;
            w = this._point.w + x;
            h = this._point.h - y;
        }

        var select_area = this._grid._selectinfo.area;
        if (this._grid._fixed_rowcnt > 0 && select_area.length)
        {
            var border = this._grid._getCurrentStyleBorder();
            var border_top = (border) ? parseInt(border.right._width, 10) : 0;

            var headheight = this._grid._getHeadHeight();
            //var fixedrowcnt = this._grid._fixed_rowcnt;
            var fixedheight = this._grid._fixed_height;
            var fixedbottom = headheight + fixedheight + border_top;

            var cur_area = select_area[select_area.length - 1];
            var cur_srow = cur_area.begrow;
            var cur_erow = cur_area.endrow;

            var ctrlpoint = this._grid._selectinfo.ctrlpoint;
            //var cur_row = ctrlpoint.row;
            //var cur_col = ctrlpoint.col;

            //var fixedsrow = this._grid._fixed_startrow;
            var fixederow = this._grid._fixed_endrow;
            var vscroll = this._grid._vscrollmng;

            if ((t + h) < fixedbottom)
                p._track_reset_scroll = true;

            if (cur_erow > fixederow)
                p._track_up_scroll = true;

            if (p._track_reset_scroll && cur_srow <= fixederow && cur_scrolltop > 0 && (t + h) >= fixedbottom)
            {
                vscroll.setPos(0);
                p._track_reset_scroll = false;
            }
            else if (p._track_up_scroll && ctrlpoint.row <= fixederow && cur_scrolltop > 0 && (t + h) <= (fixedbottom))
            {
                vscroll.setPos(vscroll.pos - 1);
            }
            else if (ctrlpoint.row > fixederow && cur_scrolltop > 0 && t <= fixedbottom)
            {
                vscroll.setPos(vscroll.pos - 1);
            }
        }

        var type = p._setAreaPos(l, t, w, h, true, this._idx);
        //var scroll = false;
        p._adjust_scroll = false;

        if (type[0] != "" || type[1] != "")
        {
            var area = null;
            if (p._onlyarea)
                area = p._curarea;

            var p_l = p._area_pos.l;
            var p_t = p._area_pos.t;
            var p_w = p._area_pos.w;
            var p_h = p._area_pos.h;

            //scroll = p._callback_scroll.call(this._grid, type, area);
            p._callback_scroll.call(this._grid, type, area);

            p._area_pos.l = p_l;
            p._area_pos.t = p_t;
            p._area_pos.w = p_w;
            p._area_pos.h = p_h;

        }

        //if (scroll)
        //{
        //    if (type[1] == "bottomover1" || type[1] == "topover0")
        //    {
        //        ;//this._point.y = p._area_pos.t;
        //        //this._point.h = p._area_pos.h;
        //       // this._point.hgap = p._area_pos.h - this._point.h;
        //    }
        //    if (type[0] == "rightover1" || type[0] == "leftover0")
        //    {
        //        ;
        //        //this._point.x = p._area_pos.l;
        //        //this._point.w = p._area_pos.w;
        //       // this._point.wgap = p._area_pos.w - this._point.w;

        //    }


        //}
        p._callback.call(this._grid, p._area_pos, this._idx, true);
    };

    _pGridSelectorButtonControl._on_endtrack = function (x, y/*, dragdata*/)
    {
        var p = this._real_parent;
        p._is_tracking = false;
        p._adjust_scroll = true;
        p.set_visible(false);
        p._trackbar[0].set_visible(true);
        p._trackbar[1].set_visible(true);
        //p._trackbar[2].set_visible(true);
        //p._trackbar[3].set_visible(true);
        p._start_begarea = this._grid._selectinfo.arearect.barea;
        p._start_endarea = this._grid._selectinfo.arearect.earea;

        if (this._idx == 0)
            this._area = p._start_begarea;
        else
            this._area = p._start_endarea;

        p._end_scroll_top = this._grid._getScrollTop();
        p._end_scroll_left = this._grid._getScrollLeft();
        p._pre_idx = this._idx;

        var select_area = this._grid._selectinfo.area;
        if (this._grid._fixed_rowcnt > 0 && select_area.length)
        {
            var cur_area = select_area[select_area.length - 1];
            var cur_erow = cur_area.endrow;

            var fixederow = this._grid._fixed_endrow;

            if (cur_erow > fixederow)
                p._track_up_scroll = true;
            else
                p._track_up_scroll = false;
        }

        this._grid._track_mode = "";

        this._grid._updateSelector();
    };

    _pGridSelectorButtonControl = null;

    //===============================================================
    // nexacro._GridSelector
    //===============================================================
    nexacro._GridSelector = function (id, left, top, width, height, right, bottom, parent)
    {
        nexacro.Component.call(this, id, left, top, width, height, right, bottom, null, null, null, null, parent);
        this._is_subcontrol = true;

        this._is_simple_control = true;

        this._callback_start = null;
        this._callback = null;
        this._callback_scroll = null;
        this._trackbar = [];
        this._grid = parent;
        this._band = parent._bodyBand;
        this._area_pos = { l: 0, t: 0, w: 0, h: 0, empty: true };
        this._curarea = "";
        this._onlyarea = false;
        this._start_begarea = "";
        this._start_endarea = "";
        this._start_scroll_top = -1;
        this._start_scroll_left = -1;
        this._end_scroll_top = -1;
        this._end_scroll_left = -1;
        this._pre_idx = -1;
    };

    var _pGridSelector = nexacro._createPrototype(nexacro.Component, nexacro._GridSelector);
    nexacro._GridSelector.prototype = _pGridSelector;
    _pGridSelector._is_subcontrol = true;
    _pGridSelector._type_name = "GridSelectorControl";

    _pGridSelector._trackbar_size = 22;

    //===============================================================
    // nexacro._GridSelector : Create & Destroy & Update
    //===============================================================
    _pGridSelector.on_create_contents = function ()
    {
    };

    _pGridSelector.on_created_contents = function (/*win*/)
    {
        if (this._trackbar[0])
        {
            this._trackbar[0].on_created();
            this._trackbar[1].on_created();
            this._trackbar[2].on_created();
            this._trackbar[3].on_created();
        }
    };

    _pGridSelector.on_destroy_contents = function ()
    {
        this._trackbar[0].destroy();
        this._trackbar[1].destroy();
        this._trackbar[0] = null;
        this._trackbar[1] = null;
        this._trackbar[2] = null;
        this._trackbar[3] = null;
        this._trackbar = null;
        this._band = null;
        this._grid = null;
    };

    //===============================================================
    // nexacro._GridSelector : Logical Part
    //===============================================================
    _pGridSelector._createButton = function ()
    {
        if (!this._trackbar[0])
        {
            this._trackbar[0] = new nexacro._GridSelectorButtonControl("selectortrackbar1", 0, 0, 0, 0, null, null, this, this.parent, 0);
            this._trackbar[0].createComponent();
            this._trackbar[1] = new nexacro._GridSelectorButtonControl("selectortrackbar2", 0, 0, 0, 0, null, null, this, this.parent, 1);
            this._trackbar[1].createComponent();
            this._trackbar[2] = new nexacro._GridSelectorButtonControl("selectortrackbar3", 0, 0, 0, 0, null, null, this, this.parent, 2);
            this._trackbar[2].createComponent();
            this._trackbar[3] = new nexacro._GridSelectorButtonControl("selectortrackbar4", 0, 0, 0, 0, null, null, this, this.parent, 3);
            this._trackbar[3].createComponent();

            this._trackbar[0]._no_slide_scroll = true;
            this._trackbar[1]._no_slide_scroll = true;
            this._trackbar[2]._no_slide_scroll = true;
            this._trackbar[3]._no_slide_scroll = true;
            this._recalcarea();
        }
    };

    _pGridSelector._updateAll = function ()
    {
        //        if (this._trackbar[0])
        //        {
        //            ;
        ////             this._trackbar[0].on_apply_custom_pseudo(this._trackbar[0]._pseudo);
        ////             this._trackbar[1].on_apply_custom_pseudo(this._trackbar[1]._pseudo);
        ////             this._trackbar[2].on_apply_custom_pseudo(this._trackbar[2]._pseudo);
        ////             this._trackbar[3].on_apply_custom_pseudo(this._trackbar[3]._pseudo);
        //        }
    };

    _pGridSelector._recalcarea = function (mode)
    {
        if (!this._trackbar[0])
            return;

        if (this._area_pos.empty)
        {
            this._trackbar[0].set_visible(false);
            this._trackbar[1].set_visible(false);
            this._trackbar[2].set_visible(false);
            this._trackbar[3].set_visible(false);
            return;
        }

        if (mode != "hscroll" && mode != "vscroll")
            this.__showbutton(false);

        var fullsize = this._trackbar_size;
        var halfsize = fullsize / 2;
        var grid = this._grid;
        var format = grid._curFormat;
        var leftwidth = format.leftWidth;
        var rightstart = grid._getClientWidth() - format.rightWidth;
        var hmin, hmax, vmin, vmax;
        var l, t, r, b;
        var adjust_top;

        vmin = this._band._adjust_top;
        vmax = this._band.getOffsetBottom();

        hmin = [];
        hmax = [];

        if (this._start_begarea == "left")
        {
            hmin[0] = 0;
            hmax[0] = leftwidth;
        }
        else if (this._start_begarea == "right")
        {
            hmin[0] = rightstart;
            hmax[0] = grid._getClientWidth();
        }
        else
        {
            hmin[0] = leftwidth;
            hmax[0] = rightstart;
        }

        if (this._start_endarea == "left")
        {
            hmin[1] = 0;
            hmax[1] = leftwidth;
        }
        else if (this._start_endarea == "right")
        {
            hmin[1] = rightstart;
            hmax[1] = grid._getClientWidth();
        }
        else
        {
            hmin[1] = leftwidth;
            hmax[1] = rightstart;
        }

        //var border = this._grid._getCurrentStyleBorder();
        //var border_top = (border) ? parseInt(border.right._width, 10) : 0;

        //var headheight = this._grid._getHeadHeight();
        var fixedheight = this._grid._fixed_height;
        //var fixedbottom = headheight + fixedheight + border_top;

        var fixed_srow = this._grid._fixed_startrow;
        //var fixed_erow = this._grid._fixed_endrow;
        var fixed_rowcnt = this._grid._fixed_rowcnt;
        var infixedrows = [false, false, false, false];
        var scroll_top = this._grid._scroll_top;

        if (fixed_rowcnt)
        {
            var area = this._grid._selectinfo.area;
            var srow, erow;
            if (area.length > 0)
            {
                srow = area[area.length - 1].begrow;
                erow = area[area.length - 1].endrow;

                if (srow <= (fixed_srow + fixed_rowcnt))
                {
                    infixedrows[0] = infixedrows[3] = true;
                }

                if (erow <= (fixed_srow + fixed_rowcnt))
                {
                    infixedrows[1] = infixedrows[2] = true;
                }
            }
        }

        adjust_top = infixedrows[0] ? scroll_top : 0;
        l = this._area_pos.l - halfsize;
        t = this._area_pos.t - halfsize + adjust_top;
        r = l + fullsize;
        b = t + fullsize;

        this._trackbar[0].move(l, t, fullsize, fullsize);

        var wgap = this._trackbar[0]._minibox_wgap;
        var hgap = this._trackbar[0]._minibox_hgap;

        var lastfocus = grid._find_lastFocused();

        if (lastfocus == grid)
        {
            if (r - wgap < hmin[0] || b - hgap < vmin || l + wgap > hmax[0] || t + hgap > vmax || t + hgap < fixedheight)
                this._trackbar[0]._p_visible = infixedrows[0] || false;  // 성능의 이유로 set_visible 사용 안하고 직접제어.
            else
                this._trackbar[0]._p_visible = true;
        }
        else
        {
            this._trackbar[0]._p_visible = false;
        }

        adjust_top = infixedrows[1] ? scroll_top : 0;
        l = this._area_pos.l + this._area_pos.w - halfsize;
        t = this._area_pos.t + this._area_pos.h - halfsize + adjust_top;
        r = l + fullsize;
        b = t + fullsize;

        this._trackbar[1].move(l, t, fullsize, fullsize);

        if (lastfocus == grid)
        {
            if (r - wgap < hmin[1] || b - hgap < vmin || l + wgap > hmax[1] || t + hgap > vmax || t + hgap < fixedheight)
                this._trackbar[1]._p_visible = infixedrows[1] || false;
            else
                this._trackbar[1]._p_visible = true;
        }
        else
        {
            this._trackbar[1]._p_visible = false;
        }

        adjust_top = infixedrows[2] ? scroll_top : 0;
        l = this._area_pos.l - halfsize;
        t = this._area_pos.t + this._area_pos.h - halfsize + adjust_top;
        r = l + fullsize;
        b = t + fullsize;

        this._trackbar[2].move(l, t, fullsize, fullsize);

        if (lastfocus == grid)
        {
            if (r - wgap < hmin[0] || b - hgap < vmin || l + wgap > hmax[0] || t + hgap > vmax || t + hgap < fixedheight)
                this._trackbar[2]._p_visible = false;
            //else
            //    this._trackbar[2]._p_visible = true;
        }

        adjust_top = infixedrows[3] ? scroll_top : 0;
        l = this._area_pos.l + this._area_pos.w - halfsize;
        t = this._area_pos.t - halfsize + adjust_top;
        r = l + fullsize;
        b = t + fullsize;

        this._trackbar[3].move(l, t, fullsize, fullsize);

        if (lastfocus == grid)
        {
            if (r - wgap < hmin[1] || b - hgap < vmin || l + wgap > hmax[1] || t + hgap > vmax || t + hgap < fixedheight)
                this._trackbar[3]._p_visible = false;
            //else
            //    this._trackbar[3]._p_visible = true;
        }

        this.__showbutton(true);
    };

    if (nexacro._OS == "Android" && (nexacro._Browser == "Safari" || nexacro._Browser == "MobileSafari"))
    {
        _pGridSelector.__showbutton = function (v)  // select시 버튼이 따라오지 않는 경우가 있어 timer사용
        {
            if (this._trackbar[0])
            {
                if (!v)
                {
                    this._trackbar[0]._control_element.setElementVisible(false);
                    this._trackbar[1]._control_element.setElementVisible(false);
                    this._trackbar[2]._control_element.setElementVisible(false);
                    this._trackbar[3]._control_element.setElementVisible(false);
                }
                else
                {
                    nexacro._OnceCallbackTimer.callonce(this, function ()
                    {
                        this._trackbar[0]._control_element.setElementVisible(this._trackbar[0]._p_visible);
                        this._trackbar[1]._control_element.setElementVisible(this._trackbar[1]._p_visible);
                        //this._trackbar[2]._control_element.setElementVisible(this._trackbar[2]._p_visible);
                        //this._trackbar[3]._control_element.setElementVisible(this._trackbar[3]._p_visible);
                    }, 10);
                }
            }
        };
    }
    else
    {
        _pGridSelector.__showbutton = function (v)
        {
            if (this._trackbar[0])
            {
                if (!v)
                {
                    this._trackbar[0]._control_element.setElementVisible(false);
                    this._trackbar[1]._control_element.setElementVisible(false);
                    this._trackbar[2]._control_element.setElementVisible(false);
                    this._trackbar[3]._control_element.setElementVisible(false);
                }
                else
                {
                    this._trackbar[0]._control_element.setElementVisible(this._trackbar[0]._p_visible);
                    this._trackbar[1]._control_element.setElementVisible(this._trackbar[1]._p_visible);
                    //this._trackbar[2]._control_element.setElementVisible(this._trackbar[2]._p_visible);
                    //this._trackbar[3]._control_element.setElementVisible(this._trackbar[3]._p_visible);
                }
            }
        };
    }

    _pGridSelector._trackingHScroll = function (idx, left, right, bodystart, rightstart, scroll_left, scroll_max)
    {
        if (!this._adjust_scroll && (this._grid.scrolltype == "none" || this._grid.scrolltype == "vertical"))
            return [0, 0];

        return this._grid._trackingHScroll(idx, left, right, this._start_begarea, this._start_endarea, bodystart, rightstart, scroll_left, scroll_max);
    };

    _pGridSelector._setAreaPos = function (left, top, width, height, is_track, idx)
    {
        var retn = ["", ""];
        var grid = this._grid;
        this._curarea = grid._selectinfo.ctrlpoint.area;

        if (is_track)
        {

            var typeinfo = this._grid._getTrackType(this, left, top, width, height, idx, this._onlyarea);

            left = typeinfo.adjust_l;
            top = typeinfo.adjust_t;
            width = typeinfo.adjust_w;
            height = typeinfo.adjust_h;

            retn[0] = typeinfo.type[0];
            retn[1] = typeinfo.type[1];
        }

        var empty = (grid._selectinfo.area.length > 0) ? false : true;

        if (width <= 0)
            width = 1;
        if (height <= 0)
            height = 1;

        this._area_pos.l = left;
        this._area_pos.t = top;
        this._area_pos.w = width;
        this._area_pos.h = height;
        this._area_pos.area = this._curarea;
        this._area_pos.empty = empty;
        if (is_track)
        {
            this._area_pos.scrolltop = grid._getScrollTop();
        }
        return retn;
    };

    _pGridSelector.move = function (left, top, width, height, mode)
    {
        if (!this._is_tracking)
        {
            if (left > this._grid._getClientWidth())
                return;

            this._start_begarea = this._grid._selectinfo.arearect.barea;
            this._start_endarea = this._grid._selectinfo.arearect.earea;
            this._setAreaPos(left, top, width, height);
            this._recalcarea(mode);
        }
        else
        {
            this._setAreaPos(left, top, width, height);
        }

        return nexacro.Component.prototype.move.call(this, left, top, width, height, undefined, undefined);
    };

    _pGridSelector._setCallbackFn = function (startfn, applyfn, scrollfn)
    {
        this._callback_start = startfn;
        this._callback = applyfn;
        this._callback_scroll = scrollfn;
    };

    _pGridSelector._initTrackInfo = function ()
    {
        this._start_scroll_top = -1;
        this._start_scroll_left = -1;
        this._end_scroll_top = -1;
        this._end_scroll_left = -1;
        this._pre_idx = -1;
    };

    _pGridSelector = null;

    //===============================================================
    // nexacro._OverlayControl
    //===============================================================
    nexacro._OverlayControl = function (left, top, width, height, right, bottom, parent, org_left, org_top, org_width, org_height, use_ext_ctrl, id, use_event, is_left, is_headsumm, styles)
    {
        nexacro.Component.call(this, ((id) ? id : "overlaycontrol"), left, top, width, height, right, bottom, null, null, null, null, parent);
        this._org_left = org_left;  // left 포함
        this._org_top = org_top;    // body만
        this._org_width = org_width;
        this._org_height = org_height;
        this._use_event = use_event;
        this._is_subcontrol = true;
        this._skip_mobile_tabfocus = true;
        this._is_left = is_left;
        this._is_headsumm = is_headsumm;
        this._styles = styles;

        if (!use_ext_ctrl)
        {
            this._ctrl = new nexacro.Static("ctrl", 0, 0, this._org_width, this._org_height, null, null, null, null, null, null, this);
            if (styles)
                this._ctrl.set_textAlign(styles.textalign);
        }
    };

    var _pOverlayControl = nexacro._createPrototype(nexacro.Component, nexacro._OverlayControl);
    nexacro._OverlayControl.prototype = _pOverlayControl;
    _pOverlayControl._is_subcontrol = true;
    _pOverlayControl._type_name = "OverlayControl";

    _pOverlayControl.on_create_contents = function ()
    {
        nexacro.Component.prototype.on_create_contents.call(this);

        if (!this._use_event)
            this._control_element.setElementPointerEvents("none");

        this._ctrl.createComponent(true);

        var ctrl = this._ctrl;
        for (var attr in ctrl)
        {
            if (attr.indexOf("set_") >= 0)
            {
                var str = "this." + attr + " = function(v)\n";
                str += "{";
                str += "    this._ctrl." + attr + "(v);";
                str += "}";
                var fn = new Function(str);
                fn.call(this);
            }
        }
    };

    _pOverlayControl.on_created_contents = function ()
    {
        nexacro.Component.prototype.on_created_contents.call(this);

        if (!this._use_event)
            this._control_element.setElementPointerEvents("none");

        this._ctrl.on_created();

        if (!this._use_event)
            this._ctrl._control_element.setElementPointerEvents("none");
    };

    _pOverlayControl.on_attach_contents_handle = function (win)
    {
        nexacro.Component.on_attach_contents_handle(this, win);
        this._ctrl.attachHandle(win);

        if (!this._use_event)
            this._ctrl._control_element.setElementPointerEvents("none");
    };

    _pOverlayControl.setControlElemPosition = function (left, top, width, height, fixed_area_scroll, autofit_col)
    {
        var grid = this.parent;
        var hpos = this._org_left - ((this._is_left) ? 0 : grid._getScrollLeft());
        var vpos = this._org_top - ((this._is_headsumm || fixed_area_scroll) ? 0 : grid._getScrollTop());
        var format = grid._curFormat;
        var leftWidth = (this._is_left) ? 0 : format.leftWidth;
        var paddtop = (this._padding) ? this._padding.top : 0;

        if (hpos < leftWidth)
            this._ctrl.move(hpos - leftWidth, this._ctrl.top);
        else
            this._ctrl.move(0, this._ctrl.top);

        if (vpos < 0)
            this._ctrl.move(this._ctrl.left, vpos + paddtop);
        else
            this._ctrl.move(this._ctrl.left, 0);

        if (autofit_col)
            this._ctrl.set_width(width);

        this._control_element.setElementPosition(left, top);
        this._control_element.setElementSize(width, height);
    };

    _pOverlayControl._on_last_lbuttonup = function ()
    {
        this.parent._on_last_lbuttonup();
    };

    _pOverlayControl._on_last_keyup = function ()
    {
        this.parent._on_last_keyup();
    };

    // not use
    _pOverlayControl.move = nexacro._emptyFn;

    _pOverlayControl = null;

    //===============================================================
    // nexacro._GridSelectionControl
    //===============================================================
    nexacro._GridSelectionControl = function (left, top, width, height, right, bottom, parent, id)
    {
        nexacro.Component.call(this, ((id) ? id : "selection"), left, top, width, height, right, bottom, null, null, null, null, parent);
    };

    var _pGridSelectionControl = nexacro._createPrototype(nexacro.Component, nexacro._GridSelectionControl);
    nexacro._GridSelectionControl.prototype = _pGridSelectionControl;
    _pGridSelectionControl._is_subcontrol = true;
    _pGridSelectionControl._is_nc_control = true;
    _pGridSelectionControl._is_simple_control = true;
    _pGridSelectionControl._type_name = "GridSelectionControl";

    _pGridSelectionControl.on_create_contents = function ()
    {
        nexacro.Component.prototype.on_create_contents.call(this);

        if (!this._use_event)
        {
            this._control_element.setElementPointerEvents("none");
        }
    };

    // node create
    _pGridSelectionControl.on_created_contents = function ()
    {
        nexacro.Component.prototype.on_created_contents.call(this);

        if (!this._use_event)
        {
            this._control_element.setElementPointerEvents("none");
        }
    };

    _pGridSelectionControl = null;

    //===============================================================
    // nexacro._GridResizerControl
    //===============================================================
    nexacro._GridResizerControl = function (id, left, top, width, height, right, bottom, parent)
    {
        nexacro.Component.call(this, id, left, top, width, height, right, bottom, null, null, null, null, parent);
        this._is_simple_control = true;
        this._is_track = true;

        this._callback = null;
        this._index = -1;
        this._direction = "";
        this._tracksize = -1;
        this._is_range = false;
        this._movedPos = 0;
        this._is_tracking = false;
        this._no_slide_scroll = true;
    };

    var _pGridResizer = nexacro._createPrototype(nexacro.Component, nexacro._GridResizerControl);
    nexacro._GridResizerControl.prototype = _pGridResizer;
    _pGridResizer._is_subcontrol = true;
    _pGridResizer._type_name = "GridControlResizerControl";

    //===============================================================
    // nexacro._GridResizerControl : Create & Destroy & Update
    //===============================================================
    _pGridResizer.on_create_contents = function ()
    {

    };

    _pGridResizer.on_created_contents = function (/*win*/)
    {
        this.set_visible(false);
        this._on_apply_tracksize();

        this.set_background("gray");

        var direction = this._direction;
        var resize_cursor;

        if (direction == "horizon")
        {
            resize_cursor = nexacro.CursorObject("col-resize");
        }
        else
        {
            resize_cursor = nexacro.CursorObject("row-resize");
        }

        this._control_element.setElementCursor(resize_cursor);
    };

    //===============================================================
    // nexacro._GridResizerControl : Logical Part
    //===============================================================
    _pGridResizer._setCallbackFn = function (fn)
    {
        this._callback = fn;
    };

    _pGridResizer._setIndex = function (idx)
    {
        this._index = idx;
    };

    _pGridResizer._setDirection = function (dir)
    {
        if (this._direction != dir)
        {
            this._direction = dir;
            this._on_apply_direction();
        }
    };

    _pGridResizer._on_apply_direction = function ()
    {
        var control_elem = this.getElement();
        if (control_elem)
        {
            this._on_apply_tracksize();

            var direction = this._direction;
            var resize_cursor;

            if (direction == "horizon")
                resize_cursor = nexacro.CursorObject("col-resize");
            else
                resize_cursor = nexacro.CursorObject("row-resize");

            this.on_apply_cursor(resize_cursor);
        }
    };

    _pGridResizer._setTracksize = function (size)
    {
        if (this._tracksize != size)
        {
            this._tracksize = size;
            this._on_apply_tracksize();
        }
    };

    _pGridResizer._on_apply_tracksize = function ()
    {
        var control_elem = this.getElement();
        if (control_elem)
        {
            var size = this._tracksize;
            var direction = this._direction;
            if (direction == "horizon")
            {
                this.resize(1, size);
            }
            else if (direction == "vertical")
            {
                this.resize(size, 1);
            }

            var remove_l = false, remove_t = false, remove_r = false, remove_b = false;
            if (direction == "horizon")
            {
                remove_t = true;
                remove_r = true;
                remove_b = true;
            }
            else
            {
                remove_l = true;
                remove_r = true;
                remove_b = true;
            }

            control_elem.setElementBorderNone(remove_l, remove_t, remove_r, remove_b);
        }
    };

    _pGridResizer._moveLeftTo = function (left)
    {
        this.left = left = left || 0;
        this.move(left, this.top);
    };

    _pGridResizer._moveTopTo = function (top)
    {
        this.top = top = top || 0;
        this.move(this.left, top);
    };

    _pGridResizer._on_starttrack = function ()
    {
        if (!this._is_alive) return;
        this._movedPos = 0;
        this._is_tracking = true;
    };

    _pGridResizer._on_movetrack = function (x, y/*, data*/)
    {
        if (!this._is_alive) return;

        var parent = this.parent;
        if (parent.ondrag && parent.ondrag.defaultprevented == true)
            return;
        if (parent.ondragmove && parent.ondragmove.defaultprevented == true)
            return;

        if (!this._p_visible)
        {
            this.set_visible(true);
        }
        if (this._direction == "horizon")
        {
            var _x = x - this._movedPos;
            this._moveLeftTo(this.left + _x);
            this._movedPos = x;
        }
        else if (this._direction == "vertical")
        {
            var _y = y - this._movedPos;
            this._moveTopTo(this.top + _y);
            this._movedPos = y;
        }
    };

    _pGridResizer._on_endtrack = function (x, y/*, data*/)
    {
        if (!this._is_alive) return;

        var control_elem = this.getElement();
        if (control_elem)
        {
            nexacro._initDragInfo();

            if (this._p_visible)
            {
                this.set_visible(false);
            }

            var parent = this.parent;
            if ((parent.ondrag && parent.ondrag.defaultprevented == true) || (parent.ondragmove && parent.ondragmove.defaultprevented == true))
            {
                //  parent._setGlobalCursor(null, parent);
            }
            else
            {
                if (this._callback && this._movedPos != 0)
                {
                    if (this._direction == "horizon")
                    {
                        this._callback.call(this.parent, x, this._index);
                    }
                    else if (this._direction == "vertical")
                    {
                        this._callback.call(this.parent, y, this._index);
                    }
                }
                /*
                nexacro._OnceCallbackTimer.callonce(parent, function ()
                {
                    this._setGlobalCursor(null, this);
                }, 10);*/
            }
        }
        this._is_tracking = false;
    };

    _pGridResizer._applyElementVisible = function (v) // HTML visibility vs display
    {
        if (this._control_element)
            this._control_element.setElementDisplay(v ? "" : "none");
    };

    _pGridResizer = null;

    //===============================================================
    // nexacro._CellTreeItemControl
    //===============================================================
    nexacro._CellTreeItemControl = function (id, left, top, width, height, right, bottom, parent)
    {
        nexacro._CellTreeControl.call(this, id, left, top, width, height, right, bottom, parent);
        this._grid = this._view;
        this._checkboxObj = "_GridCellControlCheckbox";
    };

    var _pGridTree = nexacro._createPrototype(nexacro._CellTreeControl, nexacro._CellTreeItemControl);
    nexacro._CellTreeItemControl.prototype = _pGridTree;
    /*
    _pGridTree._makeCssRefInfo = function ()
    {
        return (this._grid._makeCssRefInfoCtrl(this));
    };
    */
    //===============================================================
    // nexacro._CellTreeItemControl : Create & Destroy & Update
    //===============================================================
    _pGridTree.on_destroy_contents = function ()
    {
        nexacro._CellTreeControl.prototype.on_destroy_contents.call(this);
        this._grid = null;
    };

    //===============================================================
    // nexacro._CellTreeItemControl : Event Handlers
    //===============================================================    
    _pGridTree._on_bubble_mouseenter = function (elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseenter();

        if (call)
            nexacro.Component.prototype._on_bubble_mouseenter.call(this, elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridTree._on_bubble_mouseleave = function (elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseleave();

        if (call)
            nexacro.Component.prototype._on_bubble_mouseleave.call(this, elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridTree._on_last_lbuttonup = function ()
    {
        this._cellobj._on_last_lbuttonup();
    };

    _pGridTree._on_last_keyup = function ()
    {
        this._cellobj._on_last_keyup();
    };

    _pGridTree._common_fire_lbuttondown = function (canvasX, canvasY, refercomp)
    {
        if (this._isEditTypeTree() && this._btnimg_ctrl && this._grid._p_treeusebutton != "noclick")
        {
            var check = false;

            if (this._btnimg_ctrl._p_visible)
            {
                if ((refercomp instanceof nexacro._TreeItemIconControl) && this._is_elem_area(this._btnimg_ctrl._control_element, canvasX, canvasY))
                    check = true;
            }
            else
            {
                if (this._is_elem_area(this._btnimg_ctrl._control_element, canvasX, canvasY))
                    check = true;
            }

            if (check)
            {
                var grid = this._grid;
                var cellobj = this._cellobj;
                cellobj._tree_lbuttondown = true;

                grid._toggleTreeState(cellobj._rowidx, true);

                if (this._is_alive)
                    cellobj._tree_lbuttondown = false;
            }
        }
    };

    _pGridTree.on_fire_user_ontouchstart = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        var touchinfo = nexacro._getFirstTouchInfo(changedtouchinfos);
        if (touchinfo)
            this._common_fire_lbuttondown(touchinfo.canvasx, touchinfo.canvasy, from_refer_comp);
    };

    _pGridTree.on_fire_user_onlbuttondown = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        this._common_fire_lbuttondown(canvasX, canvasY, from_refer_comp);
    };

    _pGridTree._common_fire_lbuttonup = function ()
    {
        if (this._cellobj._tree_lbuttondown)
        {
            this._cellobj._tree_lbuttondown = false;
        }
    };

    _pGridTree.on_fire_user_ontouchend = function (/*touchinfos, changedtouchinfos, from_comp, from_refer_comp*/)
    {
        this._common_fire_lbuttonup();
    };

    _pGridTree.on_fire_user_onlbuttonup = function (/*button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key*/)
    {
        this._common_fire_lbuttonup();
    };

    _pGridTree._on_treecheckboxclick = function (obj, e)
    {
        var grid = this._grid;

        if (!this._is_alive || grid._p_readonly)
        {
            return;
        }

        if (obj == this._chk_ctrl)
        {
            var cellobj = this._cellobj;
            var cellinfo = this._cellinfo;
            var rowidx = grid._getDataRow(cellobj._rowidx);
            var disprowidx = cellobj._getDisplayRowIdx();

            if (cellinfo.treecheck._bindtype == 1)
            {
                var checked = grid._treeChecked[rowidx];
                var colid = cellinfo.treecheck._bindexpr;
                var v = (checked == 0) ? 1 : 0;
                grid._binddataset.setColumn(rowidx, colid, v);
            }
            else
            {
                if (grid._toggleTreeChecked(cellobj._rowidx))
                {
                    grid._refreshBodyRow(disprowidx);
                }
            }
        }
    };

    _pGridTree.on_fire_onclick = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key, clickitem)
    {
        if (!this._is_alive)
            return;

        var obj = from_refer_comp;
        while (obj)
        {
            if (obj._type_name == "CheckBoxControl")
                break;

            obj = obj.parent;
        }

        if (this._isEditTypeTree())
        {
            this._on_treecheckboxclick(obj);
        }

        return this._cellobj.on_fire_onclick(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key, clickitem);
    };

    //===============================================================
    // nexacro._CellTreeItemControl : Logical Part
    //===============================================================
    _pGridTree._is_elem_area = function (elem, point_x, point_y)
    {
        var scale = this._getCumulativeZoomFactor() / 100.0;

        var left = elem.left;
        var top = elem.top;
        var width = elem.width * scale;
        var height = elem.height * scale;

        if (point_x >= left && point_x <= (left + width))
        {
            return (point_y >= top && point_y <= (top + height));
        }
        else
        {
            return false;
        }
    };

    _pGridTree._lineUpdate = function (rowidx, level)
    {
        if (this._grid._p_treeuseline != this._treeuseline)
        {
            this._createLines();

            if (this._rightline_ctrl)
                this._rightline_ctrl.set_visible(this._grid._p_treeuseline);

            if (this._upline_ctrl)
                this._upline_ctrl.set_visible(this._grid._p_treeuseline);

            if (this._downline_ctrl)
                this._downline_ctrl.set_visible(this._grid._p_treeuseline);

            this._treeuseline = this._grid._p_treeuseline;
        }

        var grid = this._grid;
        var startlevel = this._cellinfo._getTreeStartLevel(rowidx);
        var bExistNextNode = (grid._hasSameNextNode[rowidx]) ? grid._hasSameNextNode[rowidx][1] : false;    // fakecell인 경우 rowidx -9
        var bRootNode = (startlevel >= level) ? true : false;

        this._createLeftLine(rowidx);
        var ctrl;

        if (this._rightline_ctrl)
        {
            ctrl = this._rightline_ctrl;
            ctrl._set_line(false, true);
        }
        if (this._upline_ctrl)
        {
            ctrl = this._upline_ctrl;
            ctrl._set_line(!bRootNode, false);
        }

        if (this._downline_ctrl && !bRootNode && bExistNextNode)
        {
            ctrl = this._downline_ctrl;
            ctrl._set_line(true, false);
        }
        else if (this._downline_ctrl)
        {
            this._downline_ctrl.set_visible(false);
        }

        this._treeline_visible(!this._cellobj._hideInner);
    };

    _pGridTree._getRowParentLevel = function (p_level, startrow)
    {
        var level;
        var cellinfo = this._cellinfo;

        for (var i = startrow; i >= 0; i--)
        {
            level = cellinfo._getTreeLevel(i);

            if (level == p_level)
                return i;
            else if (level < p_level)
                break;
        }
        return -9;
    };

    _pGridTree.__isNextSameLevelInSameParent = function (parentlvl, startrow)
    {
        var rowcount = this._grid._rowcount;
        var cellinfo = this._cellinfo;
        var level;
        var parentrow = this._getRowParentLevel(parentlvl, startrow);

        if (parentrow >= 0)
        {
            var retn = this._grid._hasSameNextNode[parentrow];
            return retn[1];
        }
        else // parent 정보가 없으면 찾음.
        {
            for (var i = startrow; i < rowcount; i++)
            {
                level = cellinfo._getTreeLevel(i);
                if (level < parentlvl)
                    break;
                else if (level == parentlvl)
                    return true;
            }
        }
        return false;
    };

    _pGridTree._createLeftLine = function (rowidx)
    {
        var grid = this._grid;
        var i, n;
        if (!grid._p_treeuseline)
        {
            for (i = 0, n = this._leftline_ctrls.length; i < n; i++)
            {
                this._leftline_ctrls[i].destroy();
            }
            this._leftline_ctrls = [];

            return;
        }

        var level = this._cellinfo._getTreeLevel(rowidx);
        //var startlevel = this._cellinfo._getTreeStartLevel(rowidx);
        var parentlevel = level - 1;
        var bExistNextParentNode;

        i = 0;
        var leftlines = this._leftline_ctrls;

        while (grid._rootlevel < parentlevel)
        {
            bExistNextParentNode = this.__isNextSameLevelInSameParent(parentlevel, rowidx);

            if (bExistNextParentNode)
            {
                var parentheight = this._getLineHeight();
                var ctrl = leftlines[i];

                if (!ctrl)
                {
                    ctrl = new nexacro._CellTreeLineControl("treeleftline", 0, 0, 1, parentheight, null, null, this.parent);
                    ctrl.createComponent();
                    this._leftline_ctrls[i] = ctrl;
                }
                else
                {
                    ctrl.set_height(parentheight);
                }

                ctrl._set_line(true, false);
                ctrl._depth = parentlevel;
                i++;
            }
            parentlevel--;
        }

        while (leftlines.length > i)
        {
            leftlines[leftlines.length - 1].destroy();
            leftlines.splice(leftlines.length - 1, 1);
        }
    };

    _pGridTree = null;

    //===============================================================
    // nexacro._cellRowGroupItemControl
    //===============================================================
    nexacro._cellRowGroupItemControl = function (id, left, top, width, height, right, bottom, parent)
    {
        nexacro._CellRowGroupControl.call(this, id, left, top, width, height, right, bottom, parent);
        this._grid = this._view;
    };

    var _pGridRowGroup = nexacro._createPrototype(nexacro._CellRowGroupControl, nexacro._cellRowGroupItemControl);
    nexacro._cellRowGroupItemControl.prototype = _pGridRowGroup;

    _pGridRowGroup._getGroupTextAreaRect = function ()
    {
        var format = this._grid._curFormat;
        var cell = this._cellobj;
        var row = cell.parent;

        if (row instanceof nexacro._GridCellControl)
            row = row.parent;

        var cellinfo = cell._refinfo;
        var grid = this._grid;
        var area = cell._refinfo._area;
        var l = cell._adjust_left;
        var t = cell._adjust_top;
        var width = format.leftWidth + format.bodyWidth - l;
        var scroll_left = this._grid._getScrollLeft();
        var rowsize = 0;
        var datarow = cell._getDataRow();
        var bodyrowslen = format._bodyrows.length;
        var r = cellinfo._isSubCell ? cell.parent._refinfo._row + cellinfo._row : cellinfo._row;

        for (var i = 0; i < cellinfo._rowspan; i++)
        {
            rowsize += grid._rowSizeListSub[datarow * bodyrowslen + r + i];
        }

        if (area == "body")
        {
            var rowrect = row._getAreaRect();
            rowrect.width -= l;
            l -= scroll_left;
            l += format.leftWidth;

            if (rowrect.width < width)
            {
                width = rowrect.width;
                width += scroll_left;
            }
        }
        else if (area == "left")
        {
            var rowrect = row._getAreaRect();
            rowrect.width += format.leftWidth;
            rowrect.width -= l;

            if (rowrect.width < width)
                width = rowrect.width;
        }

        return { left: l, top: t, width: width, height: rowsize };
    };

    _pGridRowGroup._createText = function (bCreateOnly)
    {
        var cellinfo = this.parent._refinfo;
        this._headtext_ctrl = new nexacro.TextControl("rowgroupheadtext", this._adjust_width, 0, 0, 0, null, null, null, null, null, null, this);
        this._childctrl_setevent(this._headtext_ctrl);
        this._headtext_ctrl.createComponent(bCreateOnly);

        if (cellinfo._groupcol >= 0)
        {
            this._text_ctrl = new nexacro.TextControl("rowgroupheadtext" + cellinfo._row + "_" + cellinfo._groupcol, 0, 0, 0, 0, null, null, null, null, null, null, this.parent.parent); // row의 nc control
            this._text_ctrl._is_nc_control = true;
            this._childctrl_setevent(this._text_ctrl);
            this._text_ctrl.createComponent(bCreateOnly);
            this._text_ctrl.getElement().setElementPointerEvents("none");
        }

        this._subsumtext_ctrl = new nexacro.TextControl("rowgroupsubsumtext", 0, 0, this._getClientWidth(), this._getClientHeight(), null, null, null, null, null, null, this);
        this._childctrl_setevent(this._subsumtext_ctrl);
        this._subsumtext_ctrl.createComponent(bCreateOnly);

        //this._text_ctrl.set_border("1px solid red");  // test
    };

    _pGridRowGroup._getCurrentStyleAlign = function (noflush)
    {
        var align = { textAlign: "center", verticalAlign: "middle" };
        var cell = this._cellobj;
        var dataset = cell._getBindDataset();
        var datarow = cell._getDataRow();

        if (dataset.getRowType(datarow) == 32)
        {
            if (this._subsumtext_ctrl && this._subsumtext_ctrl._cell_elem)
                align = this._subsumtext_ctrl._cell_elem._getComputedStyleAlign(noflush);
        }
        else
        {
            if (this._headtext_ctrl && this._headtext_ctrl._cell_elem)
                align = this._headtext_ctrl._cell_elem._getComputedStyleAlign(noflush);
        }

        return align;
    };

    _pGridRowGroup._setAlign = function (halign, valign)
    {
        if (halign)
        {
            this._headtext_ctrl.set_textAlign(halign);

            if (this._text_ctrl)
                this._text_ctrl.set_textAlign(halign);

            this._subsumtext_ctrl.set_textAlign(halign);
        }
        if (valign)
        {
            this._headtext_ctrl.set_verticalAlign(valign);

            if (this._text_ctrl)
                this._text_ctrl.set_verticalAlign(valign);

            this._subsumtext_ctrl.set_verticalAlign(valign);
        }
    };

    _pGridRowGroup._adjustTextPos = function (offset, width)
    {
        var cell = this.parent;
        var datarow = cell._getDataRow();
        var dataset = cell._getBindDataset();
        var rowtype = dataset ? dataset.getRowType(datarow) : 1;

        if (this._text_ctrl)
        {
            var format = this._grid._curFormat;
            var cell = this.parent;
            var area = cell._refinfo._area;
            var leftwidth = format.leftWidth;

            var textrect = this._getGroupTextAreaRect();
            var l = offset + textrect.left;
            var t = textrect.top;
            var w = textrect.width - offset;
            var h = textrect.height;

            this._text_ctrl.move(l, t, w, h);

            var l_gap = 0;

            if (area == "body" && leftwidth > 0)
            {
                if (l < leftwidth)
                    l_gap = leftwidth - l;

                var path = "inset(0px 0px 0px " + l_gap + "px)";
                this._text_ctrl._control_element.setElementClipPath(path);
            }
            else
            {
                this._text_ctrl._control_element.setElementClipPath("");
            }

            if (rowtype == 16) // subsum
            {
                this._text_ctrl.set_visible(false);
                this._subsumtext_ctrl.set_visible(true);
            }
            else
            {
                this._text_ctrl.set_visible(true);
                this._subsumtext_ctrl.set_visible(false);
            }
        }
        else
        {
            this._headtext_ctrl.move(offset, 0, width - offset, this._getClientHeight());

            if (rowtype == 16) // subsum
            {
                this._subsumtext_ctrl.set_visible(true);
                this._headtext_ctrl.set_visible(false);
            }
            else
            {
                this._subsumtext_ctrl.set_visible(false);
                this._headtext_ctrl.set_visible(true);
            }
        }

        this._subsumtext_ctrl.move(0, 0, this._getClientWidth(), this._getClientHeight());
    };

    _pGridRowGroup._updateTextStyle = function ()
    {
        if (!this._text_ctrl)
            return;

        var cell = this.parent;
        var datarow = cell._getDataRow();
        var cellinfo = this.parent._refinfo;

        var textDecoration = cellinfo._getAttrValue(cellinfo._p_textDecoration, datarow);
        var textAlign = cellinfo._getAttrValue(cellinfo._p_textAlign, datarow);
        var verticalAlign = cellinfo._getAttrValue(cellinfo._p_verticalAlign, datarow);
        var font = cellinfo._getAttrValue(cellinfo._p_font, datarow);
        var color = cellinfo._getAttrValue(cellinfo._p_color, datarow);
        var letterSpacing = cellinfo._getAttrValue(cellinfo._p_letterSpacing, datarow);
        var wordSpacing = cellinfo._getAttrValue(cellinfo._p_wordSpacing, datarow);
        var cursor = cellinfo._getAttrValue(cellinfo._p_cursor, datarow);
        var padding = cellinfo._getAttrValue(cellinfo._p_padding, datarow);
        var wordWrap = cellinfo._getAttrValue(cellinfo._p_wordWrap, datarow);
        var background = cellinfo._getAttrValue(cellinfo._p_background, datarow);
        var border = cellinfo._getAttrValue(cellinfo._p_border, datarow);

        if (!textDecoration)
            textDecoration = this._headtext_ctrl._control_element._getComputedStyle("text-decoration", true);

        this._text_ctrl.set_textDecoration(textDecoration);

        if (!textAlign)
        {
            textAlign = this._headtext_ctrl._control_element._getComputedStyle("justify-content");
            if (textAlign == "flex-start")
                textAlign = "left";
            else if (textAlign == "flex-end")
                textAlign = "right";
        }

        this._text_ctrl.set_textAlign(textAlign);

        if (!verticalAlign)
        {
            verticalAlign = this._headtext_ctrl._control_element._getComputedStyle("align-items");
            if (verticalAlign == "flex-start")
                verticalAlign = "top";
            else if (verticalAlign == "flex-end")
                verticalAlign = "bottom";
            else if (verticalAlign == "center")
                verticalAlign = "middle";
        }

        this._text_ctrl.set_verticalAlign(verticalAlign);

        if (!font)
            font = this._headtext_ctrl._getCurrentStyleInheritValue("font", this._headtext_ctrl._status);

        this._text_ctrl.set_font(font);

        if (!color)
            color = this._headtext_ctrl._getCurrentStyleInheritValue("color", this._headtext_ctrl._status);

        this._text_ctrl.set_color(color);

        if (!letterSpacing)
            letterSpacing = this._headtext_ctrl._getCurrentStyleInheritValue("letterSpacing", this._headtext_ctrl._status);

        this._text_ctrl.set_letterSpacing(letterSpacing);

        if (!wordSpacing)
            wordSpacing = this._headtext_ctrl._getCurrentStyleInheritValue("wordSpacing", this._headtext_ctrl._status);

        this._text_ctrl.set_wordSpacing(color);

        if (!cursor)
            cursor = this._headtext_ctrl._control_element._getComputedStyle("cursor", true);

        this._text_ctrl.set_cursor(cursor);

        if (!padding)
            padding = this._headtext_ctrl._getCSSStyleValue("padding", this._headtext_ctrl._status);

        this._text_ctrl.set_padding(padding);

        if (!wordWrap)
            wordWrap = this._headtext_ctrl._getCSSStyleValue("wordWrap", this._headtext_ctrl._status);

        this._text_ctrl.set_wordWrap(wordWrap);

        if (!background)
            background = this._headtext_ctrl._control_element._getComputedStyleBackgroundColor(true);

        this._text_ctrl.set_background(background);

        if (!border)
            border = this._headtext_ctrl._getCSSStyleValue("border", this._headtext_ctrl._status);

        this._text_ctrl.set_border(border);
    };

    _pGridRowGroup.on_destroy_contents = function ()
    {
        nexacro._CellRowGroupControl.prototype.on_destroy_contents.call(this);

        if (this._headtext_ctrl)
        {
            this._headtext_ctrl.destroy();
            this._headtext_ctrl = null;
        }

        if (this._subsumtext_ctrl)
        {
            this._subsumtext_ctrl.destroy();
            this._subsumtext_ctrl = null;
        }
    };

    _pGridRowGroup.on_created_contents = function (win)
    {
        nexacro._CellRowGroupControl.prototype.on_created_contents.call(this, win);

        if (this._headtext_ctrl)
            this._headtext_ctrl.on_created(win);
        if (this._subsumtext_ctrl)
            this._subsumtext_ctrl.on_created(win);
    };

    _pGridRowGroup._apply_status = function (oldstatus, status, olduserstatus, userstatus, apply, status_param, value_param)
    {
        var rtn = nexacro._CellRowGroupControl.prototype._apply_status.call(this, oldstatus, status, olduserstatus, userstatus, apply, status_param, value_param);
        this._headtext_ctrl._changeStatus(status_param, value_param)
        this._subsumtext_ctrl._changeStatus(status_param, value_param)
        this._updateTextStyle();
        return rtn;
    };

    _pGridRowGroup._textUpdate = function ()
    {
        var txt = this._p_parent._getDisplayText();
        if (this._displaytext != txt)
        {
            if (this._headtext_ctrl)
                this._headtext_ctrl.set_text(txt);

            if (this._text_ctrl)
                this._text_ctrl.set_text(txt);

            if (this._subsumtext_ctrl)
                this._subsumtext_ctrl.set_text(txt);

            this._displaytext = txt;
        }
        this._updateTextStyle();
    };

    _pGridRowGroup._updateHScrolling = function ()
    {
        this._adjustSubCompAlign();
    };

    _pGridRowGroup._on_bubble_mouseenter = function (elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseenter();

        if (call)
            nexacro.Component.prototype._on_bubble_mouseenter.call(this, elem, from_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridRowGroup._on_bubble_mouseleave = function (elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key)
    {
        var call = true;
        if (bubble_scope)
            call = this._cellobj._common_mouseleave();

        if (call)
            nexacro.Component.prototype._on_bubble_mouseleave.call(this, elem, to_comp, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, bubble_scope, meta_key);

        return true;
    };

    _pGridRowGroup._on_last_lbuttonup = function ()
    {
        this._cellobj._on_last_lbuttonup();
    };

    _pGridRowGroup._on_last_keyup = function ()
    {
        this._cellobj._on_last_keyup();
    };

    _pGridRowGroup._common_fire_lbuttondown = function (canvasX, canvasY, refercomp)
    {
        if (this._isEditTypeTree() && this._btnimg_ctrl)
        {
            var check = false;

            if (this._btnimg_ctrl._p_visible)
            {
                if ((refercomp instanceof nexacro._RowGroupExpandButtonControl) && this._is_elem_area(this._btnimg_ctrl._control_element, canvasX, canvasY))
                    check = true;
            }
            else
            {
                if (this._is_elem_area(this._btnimg_ctrl._control_element, canvasX, canvasY))
                    check = true;
            }

            if (check)
            {
                var grid = this._grid;
                var cellobj = this._cellobj;
                cellobj._tree_lbuttondown = true;

                grid._toggleTreeState(cellobj._rowidx, true);

                if (this._is_alive)
                    cellobj._tree_lbuttondown = false;
            }
        }
    };

    _pGridRowGroup.on_fire_user_ontouchstart = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        var touchinfo = nexacro._getFirstTouchInfo(changedtouchinfos);
        if (touchinfo)
            this._common_fire_lbuttondown(touchinfo.canvasx, touchinfo.canvasy, from_refer_comp);
    };

    _pGridRowGroup.on_fire_user_onlbuttondown = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        this._common_fire_lbuttondown(canvasX, canvasY, from_refer_comp);
    };

    _pGridRowGroup._common_fire_lbuttonup = function ()
    {
        if (this._cellobj._tree_lbuttondown)
        {
            this._cellobj._tree_lbuttondown = false;
        }
    };

    _pGridRowGroup.on_fire_user_ontouchend = function (/*touchinfos, changedtouchinfos, from_comp, from_refer_comp*/)
    {
        this._common_fire_lbuttonup();
    };

    _pGridRowGroup.on_fire_user_onlbuttonup = function (/*button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key*/)
    {
        this._common_fire_lbuttonup();
    };

    _pGridRowGroup.on_fire_onclick = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key, clickitem)
    {
        if (!this._is_alive)
            return;

        return this._cellobj.on_fire_onclick(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key, clickitem);
    };

    _pGridRowGroup._is_elem_area = function (elem, point_x, point_y)
    {
        var scale = this._getCumulativeZoomFactor() / 100.0;

        var left = elem.left;
        var top = elem.top;
        var width = elem.width * scale;
        var height = elem.height * scale;

        if (point_x >= left && point_x <= (left + width))
        {
            return (point_y >= top && point_y <= (top + height));
        }
        else
        {
            return false;
        }
    };

    _pGridRowGroup._getRowParentLevel = function (p_level, startrow)
    {
        var level;
        var cellinfo = this._cellinfo;

        for (var i = startrow; i >= 0; i--)
        {
            level = cellinfo._getGroupRowLevel(i);

            if (level == p_level)
                return i;
            else if (level < p_level)
                break;
        }
        return -9;
    };

    _pGridRowGroup.__isNextSameLevelInSameParent = function (parentlvl, startrow)
    {
        var rowcount = this._grid._rowcount;
        var cellinfo = this._cellinfo;
        var level;
        var parentrow = this._getRowParentLevel(parentlvl, startrow);

        if (parentrow >= 0)
        {
            var retn = this._grid._hasSameNextNode[parentrow];
            return retn[1];
        }
        else // parent 정보가 없으면 찾음.
        {
            for (var i = startrow; i < rowcount; i++)
            {
                level = cellinfo._getGroupRowLevel(i);
                if (level < parentlvl)
                    break;
                else if (level == parentlvl)
                    return true;
            }
        }
        return false;
    };

    _pGridRowGroup = null;

    nexacro._GridCoverControl = function (parent, grid)
    {
        nexacro.Component.call(this, "gridblur", 0, 0, 0, 0, 0, 0, null, null, null, null, parent);
        this._grid = grid;
    };

    var _pGridCoverControl = nexacro._createPrototype(nexacro.Component, nexacro._GridCoverControl);
    nexacro._GridCoverControl.prototype = _pGridCoverControl;
    _pGridCoverControl._type_name = "GridCoverControl";

    _pGridCoverControl._is_subcontrol = true;
    _pGridCoverControl._is_scrollable = false;
    _pGridCoverControl._is_nc_control = true;
    _pGridCoverControl._is_simple_control = true;

    _pGridCoverControl.on_create_contents = function ()
    {
        this.set_visible(false);
        this.set_background("#ffffff");
        this.set_opacity("0.8");
    };

    _pGridCoverControl.on_destroy_contents = function ()
    {
        this._grid = null;
    };

    _pGridCoverControl._coverOn = function (srow, erow)
    {
        var grid = this._grid;
        var rowsize = grid._bodyrowheight;
        var body = this.parent;
        var top = body._getClientTop() + grid._fixed_height;
        var left = body._getClientLeft();
        var width = body._getClientWidth();
        var height = body._getClientHeight();
        var tpos = srow * rowsize;

        if (erow != undefined)
        {
            var epos = erow * rowsize;
            height = epos - tpos;
        }
        else
        {
            height -= tpos;
        }

        this.move(left, top + tpos, width, height);

        this.set_visible(true);
    };

    _pGridCoverControl._coverOff = function ()
    {
        if (this._p_visible)
        {
            this.set_visible(false);
            return true;
        }
        return false;
    };

    _pGridCoverControl = null;

    //==============================================================================
    // nexacro._GridRowControl
    //==============================================================================
    nexacro._GridRowControl = function (parent, left, top, width, height, rowidx, temp, floating, right, bottom)
    {
        nexacro.Component.call(this, "gridrow_" + rowidx, left, top, width, height, right, bottom, null, null, null, null, parent);

        /* internal variable */
        this._grid = parent.parent;
        this._band = parent;
        this._cells = [];
        this._rowidx = rowidx;
        this._row_sizes = [];
        this._row_tops = [];
        this._row_bottoms = [];
        this._format_rows = [];
        this._format_cols = [];
        this._format_cells = [];
        this._noupdate_remain_cells = [];
        this._fixed = false;
        this._is_temp = !!temp;
        this._use_translate_move = true;
        this._use_translate_scroll = true;
        this._is_nc_control = this._floating = !!floating;
        this._colsubrowscells = [];

        this._p_accessibilityrole = "rowgroup"; //사용자에게 노출되지 않음
    };

    var _pGridRow = nexacro._createPrototype(nexacro.Component, nexacro._GridRowControl);
    nexacro._GridRowControl.prototype = _pGridRow;

    _pGridRow._is_subcontrol = true;
    _pGridRow._is_scrollable = false;

    _pGridRow._type_name = "GridRowControl";
    _pGridRow._makeCssRefInfo = function ()
    {
        return (this._grid._makeCssRefInfoCtrl(this));
    };

    //==============================================================================
    // nexacro._GridRowControl : Create & Destroy & Update
    //==============================================================================
    _pGridRow.createCommand = function ()
    {
        var str = "";
        if (!this._is_loading)
        {
            // showModal시 createComponent는 실패한채 created가 먼저 처리되는 문제가 있어
            // createComponent와 동일 조건으로 created를 방지함. 이 두 함수 모두 modal callback에서 다시 호출됨.

            //처음 생성시에 enable = false인 경우에만 disable 이되도록 수정
            //set_enable _is_created 된후에만 real_enable 값 설정
            var enable = this._isEnable();

            if ((this._real_enable == null && enable == false) || (this._real_enable && this._real_enable != enable))
            {
                this._real_enable = enable;
                this._changeStatus("disabled", !enable);
                this.on_apply_prop_enable(enable);
            }
            else
            {
                this._real_enable = enable;
            }

            var control_elem = this._control_element;
            if (control_elem)
            {
                str = control_elem.createCommandStart();

                str += control_elem.createCommandAreaStart("left");
                str += this.on_create_contents_command("left");
                str += control_elem.createCommandAreaEnd("left");

                str += control_elem.createCommandAreaStart("body");
                str += this.on_create_contents_command("body");
                str += control_elem.createCommandAreaEnd("body");

                str += control_elem.createCommandAreaStart("right");
                str += this.on_create_contents_command("right");
                str += control_elem.createCommandAreaEnd("right");

                str += control_elem.createCommandEnd();
            }

            if (!this._is_subcontrol)
                this._registerHotkey();

            this._is_create_commandstr = true;
        }
        return str;
    };

    _pGridRow.on_create_contents = function ()
    {
        if (this._is_temp)
            return;

        this._init(this._grid._curFormat);
        this._createCellComponents();
    };

    _pGridRow.on_created_contents = function (win)
    {
        if (this._is_temp)
            return;

        var format = this._grid._curFormat;
        var scroll_width = format.bodyWidth;
        var control_elem = this._control_element;

        control_elem._setContainerMaxWidth(scroll_width);
        control_elem.setElementHScrollPos(this._grid._getScrollLeft());

        if (control_elem.setInnerHTML && this._grid._use_innerhtml && !this._is_nc_control)
        {
            this._is_create_commandstr = true;
            var str = "";

            str += control_elem.createCommandAreaStart("left");
            str += this._createCellElements(0, true, "left");
            str += control_elem.createCommandAreaEnd("left");

            str += control_elem.createCommandAreaStart("body");
            str += this._createCellElements(0, true, "body");
            str += control_elem.createCommandAreaEnd("body");

            str += control_elem.createCommandAreaStart("right");
            str += this._createCellElements(0, true, "right");
            str += control_elem.createCommandAreaEnd("right");

            control_elem.setInnerHTML(str);
            this.attachHandle(win);
        }
        else
        {
            this._createCellElements(0, false);
        }

        if (this._env._p_enableaccessibility)
        {
            this._on_created_accessibility_contents(win);
        }
    };

    _pGridRow.on_create_contents_command = function (area)
    {
        return this._createCellElements(0, true, area);
    };

    _pGridRow.on_attach_contents_handle = function (win)
    {
        var cells = this._cells;
        var cells_len = cells.length;

        if (cells_len == 0)
            return;

        var subcells, subcells_len;

        //var datarow = grid._getDataRow(this._rowidx),
        //    selected, cell_elem, cellinfo;

        for (var i = 0; i < cells_len; i++)
        {
            cells[i].attachHandle(win);

            subcells = cells[i].subcells;
            subcells_len = subcells.length;

            for (var j = 0; j < subcells_len; j++)
            {
                subcells[j].attachHandle(win);
            }
        }

        if (this._env._p_enableaccessibility)
        {
            this._on_attach_accessibility_contents_handle(win);
        }
    };

    _pGridRow.on_destroy_contents = function ()
    {
        var cells = this._cells,
            cells_len = cells.length;

        for (var i = 0; i < cells_len; i++)
        {
            cells[i].destroy();
        }

        this._colsubrowscells = this._grid = this._cells = this._format = this._band = this._cells = this._row_sizes = this._row_tops = this._row_bottoms = this._format_rows = this._format_cols = this._format_cells = this._noupdate_remain_cells = this._hide_hscroll_cells = this._hide_hscroll_cell_indexes = null;
    };

    _pGridRow._on_changeStatus = function (status, value)
    {
        if (!this._is_alive)
            return;

        this._oldstatus = this._status;
        var applystatus = "enabled";

        this._statusmap[status] = value;
        var statusmap = this._statusmap;
        if (statusmap.disabled)
            applystatus = "disabled";

        //this._status = applystatus;
        this._status = this.on_changeStatus(status, value, applystatus, this._status, this._userstatus);

        if (this._oldstatus != this._status)
            this._apply_status(this._oldstatus, this._status, this._olduserstatus, this._userstatus, undefined, status, value);

        if (this._env._p_enableaccessibility)
            this._setAccessibilityStatFlag(this._status, this._userstatus);
    };

    _pGridRow._last_scroll_left = 0;
    _pGridRow._callback_func_onscroll = function (left, top)
    {
        if (this._last_scroll_left != left)
        {
            var delta = this._last_scroll_left - left;
            this._last_scroll_left = left;

            var dir = (delta > 0 ? -1 : (delta < 0 ? 1 : 0));

            var updaterange = this._getColScrollInfo(dir);
            this._grid._adjustGridScrollCols_callback_onscroll_after(dir, left, updaterange[0], updaterange[1]);
        }
    };

    _pGridRow._callback_func_onscroll_node_acivate = function (scrollleft)
    {
        this._grid._hscrollmng.setPos(scrollleft);
    };

    _pGridRow.on_change_containerRect = function (width, height)
    {
        var grid = this._grid;

        if (this._isRtl(grid) && nexacro._Browser == "Runtime")
        {
            var cells = this._cells;
            var cellslen = cells.length;
            var i = 0;

            for (; i < cellslen; i++)
            {
                cells[i]._update_position(true);
            }
        }
        nexacro.Component.prototype.on_change_containerRect.call(this, width, height);
    };

    _pGridRow.on_getIDCSSSelector = function ()
    {
        return "row";
    };

    _pGridRow.on_fire_onclick = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        if (this._is_temp)
            return;

        if (nexacro._isTouchInteraction)
            this._grid._hideEditor();

        // grid nodataclick event
        if (this._band)
        {
            this._band.on_fire_onclick(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
        }
    };

    //==============================================================================
    // nexacro._GridRowControl : Override
    //==============================================================================
    _pGridRow.on_create_control_element = function (parent_elem)
    {
        // create
        var control_elem;
        var gap = 0;

        if (this._floating)
        {
            var border = this._border;
            gap = this._grid._floating_gap + ((border) ? border.left._width : 0);
        }

        if (!this._is_temp)
            control_elem = new nexacro.GridRowControlElement(parent_elem, gap);
        else
            control_elem = new nexacro.ControlElement(parent_elem);

        var format = this._grid._curFormat;

        control_elem.setLinkedControl(this);
        control_elem._left_width = format.leftWidth;
        control_elem._right_width = format.rightWidth;

        if (!this._is_temp)
            control_elem._setContainerMaxWidth(this._band._scrollWidth);

        this._control_element = control_elem;
        return control_elem;
    };

    _pGridRow._apply_setfocus = function (evt_name, self_flag)
    {
        if (self_flag)
            nexacro.Component.prototype._apply_setfocus.call(this, evt_name);
    };

    _pGridRow._getAccessibilityLabel = function ()
    {
        var label = "";
        var grid = this._grid;
        if (grid._isSelectRowType())
        {
            var cellLabel = "";
            var cells = this._cells;

            for (var i = 0, n = cells.length; i < n; i++)
            {
                cellLabel = cells[i]._getAccessibilityLabel(true);
                if (label)
                {
                    if (cellLabel)
                        label += " " + cellLabel;
                }
                else
                {
                    label = cellLabel;
                }
            }
        }
        return label;
    };

    //==============================================================================
    // nexacro._GridRowControl : Logical Part
    //==============================================================================
    _pGridRow._init = function (format)
    {
        var grid = this._grid,
            control_elem = this._control_element;

        control_elem.setArea(format.leftWidth, format.rightWidth);

        if (this._rowidx == -1)
        {
            this._format_rows = format._headrows;
            this._format_cells = format._headcells;
        }
        else if (this._rowidx == -2)
        {
            this._format_rows = format._summrows;
            this._format_cells = format._summcells;
        }
        else
        {
            this._format_rows = format._bodyrows;
            this._format_cells = format._bodycells;
        }

        this._format_cols = format._cols;

        if (!this._format_cols)
            this._format_cols = [];

        if (!this._format_rows)
            this._format_rows = [];

        if (!this._format_cells)
            this._format_cells = [];

        var rowSizeListSub,
            datarow = 0;

        if (this._rowidx == -1)
        {
            rowSizeListSub = grid._rowHeadListSub;
        }
        else if (this._rowidx == -2)
        {
            rowSizeListSub = grid._rowSummListSub;
        }
        else
        {
            datarow = grid._getDataRow(this._rowidx);
            rowSizeListSub = grid._rowSizeListSub;
        }

        var rows = this._format_rows,
            rows_len = rows.length,
            size = 0, top = 0, i;

        this._row_tops = [];
        this._row_sizes = [];
        this._row_bottoms = [];

        if (datarow >= 0)
        {
            var start = datarow * rows_len;

            if (!this._floating)
            {
                for (i = 0; i < rows_len; i++)
                {
                    this._row_tops.push(top);
                    size = (rowSizeListSub.length > 0) ? rowSizeListSub[start + i] : rows[i].size;
                    this._row_sizes.push(size);
                    top += size;
                    this._row_bottoms.push(top);
                }
            }
            else
            {
                for (i = 0; i < rows_len; i++)
                {
                    this._row_tops.push(top);
                    size = rows[i].size;
                    this._row_sizes.push(size);
                    top += size;
                    this._row_bottoms.push(top);
                }
            }
        }
        else
        {
            for (i = 0; i < rows_len; i++)
            {
                this._row_tops.push(top);
                size = (rowSizeListSub.length > 0) ? rowSizeListSub[i] : rows[i].size;
                this._row_sizes.push(size);
                top += size;
                this._row_bottoms.push(top);
            }
        }
    };

    _pGridRow._setTempCursor = function (cursor)
    {
        var cells = this._cells;

        for (var i = 0, n = cells.length; i < n; i++)
        {
            if (cursor)
                cells[i]._temp_cursor = cells[i].cursor;
            else
                cursor = cells[i]._temp_cursor;

            cells[i]._updateCursor(cursor);
        }
        this._updateCursor(cursor);
    };

    _pGridRow._on_last_lbuttonup = function ()
    {
        this.parent._on_last_lbuttonup();
    };

    _pGridRow._on_last_keyup = function ()
    {
        this.parent._on_last_keyup();
    };

    _pGridRow._updateAll = function (status, is_remain_cell, onlycontents, for_select, startcol, removecell)
    {
        var grid = this._grid;
        var cells = is_remain_cell ? this._noupdate_remain_cells : this._cells;
        var cells_len = cells.length;
        var subcells
        var subcells_len;
        var exprbindcells = for_select ? grid._getUseBindExprProp("body") : [];
        var datarow = grid._getDataRow(this._rowidx);
        var cell, cellinfo;
        var selected;

        if (!exprbindcells)
            exprbindcells = [];

        this._noupdate_remain_cells = [];

        var i, j;
        var k = 0;

        for (i = 0; i < cells_len; i++)
        {
            cell = cells[i];
            cellinfo = cell._refinfo;

            if (removecell && removecell == cell)
                continue;

            if (startcol)
            {
                if ((cellinfo._col + cellinfo._colspan - 1) < startcol)
                    continue;
            }

            if (cellinfo._area != "body" || (cell._is_created && cell._isUpdateArea()))
            {
                if (grid._isSelectRowType())
                {
                    if (selected == undefined)
                        selected = grid._isSelectedCell(cell._cellidx, datarow);
                }
                else
                {
                    selected = grid._isSelectedCell(cell._cellidx, datarow);
                }

                subcells = cell.subcells;
                subcells_len = subcells.length;

                for (j = 0; j < subcells_len; j++)
                {
                    subcells[j].selected = selected;
                    // subcell의 updateAll은 cell의 updataAll에서...
                }

                if (cell.selected != selected)
                {
                    cell.selected = selected;
                    cell._updateAll(status, false);

                    if (exprbindcells[k] == cell._cellidx)
                    {
                        k++;
                    }
                }
                else
                {
                    if (for_select)
                    {
                        if (exprbindcells[k] == cell._cellidx)
                        {
                            cell._updateAll(status, onlycontents);
                            k++;
                        }
                    }
                    else
                    {
                        cell._updateAll(status, onlycontents);
                    }
                }
            }
            else
            {
                if (grid._is_performance_scroll && for_select && cellinfo._area == "body")
                {
                    if (grid._isSelectRowType())
                    {
                        if (selected == undefined)
                            selected = grid._isSelectedCell(cell._cellidx, datarow);
                    }
                    else
                    {
                        selected = grid._isSelectedCell(cell._cellidx, datarow);
                    }
                    cell.selected = selected;
                    cell._changeUserStatus("selected", cell._isSelectedColor());
                }

                this._noupdate_remain_cells.push(cell);
            }
        }
    };

    _pGridRow._getAreaRect = function (area)
    {
        var rect = { left: 0, top: 0, width: 0, height: 0 };
        if (!this._is_alive)
            return rect;
        var format = this._grid._curFormat;

        rect.top = this._getClientTop();
        rect.height = this._getClientHeight();

        if (area == "left")
        {
            rect.left = this._getClientLeft();
            rect.width = format.leftWidth;
        }
        else if (area == "right")
        {
            rect.left = this._getClientWidth() - format.rightWidth;
            rect.width = format.rightWidth;
        }
        else
        {
            rect.left = format.leftWidth;
            rect.width = this._getClientWidth() - format.leftWidth - format.rightWidth;
        }
        return rect;
    };

    _pGridRow._changeRow = function (row, init)
    {
        if (this._rowidx == row)
            return false;

        this._rowidx = row;

        if (init)
            this._init(this._grid._curFormat);

        return true;
    };

    _pGridRow._hideArea = function ()
    {
        if (this._fixed)
            return "";

        var band = this._band;
        var grid = this._grid;
        var scrolltop = grid._getScrollTop();

        var t = this._adjust_top;
        var h = this._adjust_height;
        var b = t + h;

        t -= scrolltop;
        b -= scrolltop;

        var bandrc = grid._getAvailableRect(band);
        var border = band._getCurrentStyleBorder();

        b -= border ? border.top._width : 0;
        b -= border ? border.bottom._width : 0;

        if (b <= 0)
            return "top";
        else if (t >= bandrc.bottom)
            return "bottom";

        return "";
    };

    _pGridRow._showfull = function (clickcell)
    {
        if (!this._fixed)
        {
            var band = this._band;
            var grid = this._grid;
            var scrolltop = grid._getScrollTop();

            var t = this._adjust_top;
            var h = this._adjust_height;
            var b = t + h;

            t -= scrolltop;
            b -= scrolltop;

            var vscroll = grid._vscrollmng;
            var bandrc = grid._getAvailableRect(band);
            var border = band._getCurrentStyleBorder();

            b -= border ? border.top._width : 0;
            b -= border ? border.bottom._width : 0;

            if (vscroll)
            {
                if (h < bandrc.height)
                {
                    if (t < 0)
                    {
                        vscroll.setRowPos(grid._toprowpos[0]);
                    }
                    else if (b > bandrc.bottom)
                    {

                        var gap = b - bandrc.bottom
                        var minimumscrolltop = scrolltop + gap; // target이 보이기 위한 최소한의 스크롤 top

                        var newscrollinfo = vscroll._scroll_reverse_convert(minimumscrolltop);
                        var newrowpos = newscrollinfo[0];
                        var newscrolltop = newscrollinfo[1];

                        var rowcnt = grid._getGridRowCount();

                        while (newscrolltop < minimumscrolltop && newrowpos < rowcnt - 1)
                        {
                            var nextrowsize = grid._rowSizeList[newrowpos + 1];

                            newscrolltop += nextrowsize;

                            newscrollinfo = vscroll._scroll_reverse_convert(newscrolltop, false, false, newrowpos);

                            newrowpos = newscrollinfo[0];
                            newscrolltop = newscrollinfo[1];
                        }

                        vscroll.setRowPos(newrowpos);
                    }
                }
            }
        }

        if (clickcell && clickcell._is_alive)
            clickcell._showfull(false);
    };

    _pGridRow._createCellElements_async = function (bCommandMode)
    {
        nexacro._OnceCallbackTimer.callonce(this, function ()
        {
            this._createCellElements(0, bCommandMode);
        });
    };

    _pGridRow._createCellComponents = function ()
    {
        var _cols = this._format_cols,
            _rows = this._format_rows,
            _cells = this._format_cells,
            _row_tops = this._row_tops,
            //  _row_sizes = this._row_sizes,
            _row_bottoms = this._row_bottoms,

            cellcnt = (_cells) ? _cells.length : 0,
            _cellinfo, top = 0, left, width, height, cellitem, id,
            _subcells, _subcellsLen, col, row, subcellitem, selected, _subcellinfo,
            grid = this._grid,
            datarow = grid._getDataRow(this._rowidx);

        var subrow_len = _rows.length;
        var subrowscells = this._colsubrowscells = [];

        for (var i = 0; i < subrow_len; i++)
            subrowscells.push([]);

        for (i = 0; i < cellcnt; i++)
        {
            _cellinfo = _cells[i];

            left = _cols[_cellinfo._col].left;
            top = _row_tops[_cellinfo._row];
            width = _cols[_cellinfo._col + _cellinfo._colspan - 1].right - left;
            height = _row_bottoms[_cellinfo._row + _cellinfo._rowspan - 1] - top;

            if (grid._isSelectRowType())
            {
                if (selected == undefined)
                    selected = grid._isSelectedCell(_cellinfo._cellidx, datarow);
            }
            else
            {
                selected = grid._isSelectedCell(_cellinfo._cellidx, datarow);
            }

            id = "cell_" + this._rowidx + "_" + _cellinfo._cellidx;
            cellitem = new nexacro._GridCellControl(id, left, top, width, height, null, null, this, _cellinfo, this._rowidx, _cellinfo._cellidx);
            cellitem.selected = selected;

            subrowscells[_cellinfo._row][_cellinfo._col] = cellitem;

            var step = 0;
            switch (_cellinfo._area)
            {
                case "left":
                    step = 1;
                    break;
                case "right":
                    step = 2;
                    break;
            }

            cellitem.set_positionstep(step);
            cellitem.createComponent(true);

            if (cellitem._text_elem)
            {
                cellitem._text_elem.setElementPointerEvents();
            }

            this._cells[i] = cellitem;

            _subcells = _cellinfo._subcells;
            _subcellsLen = _subcells.length;

            for (var j = 0; j < _subcellsLen; j++)
            {
                _subcellinfo = _subcells[j];
                col = _cellinfo._col + _subcellinfo._col;
                row = _cellinfo._row + _subcellinfo._row;

                left = _cols[col].left;
                top = _row_tops[row];
                width = _cols[col + _subcellinfo._colspan - 1].right - left;
                height = _row_bottoms[row + _subcellinfo._rowspan - 1] - top;

                left -= _cols[_cellinfo._col].left;
                top -= _row_tops[_cellinfo._row];
                id = "subcell_" + this._rowidx + "_" + _cellinfo._cellidx + "_" + _subcellinfo._cellidx;
                subcellitem = new nexacro._GridSubCellControl(id, left, top, width, height, null, null, cellitem, _subcellinfo, this._rowidx, _subcellinfo._cellidx);
                subcellitem.selected = selected;
                subcellitem.parentcell = cellitem;
                subcellitem.createComponent(true);
                cellitem.subcells[j] = subcellitem;
            }
        }
    };

    _pGridRow._createCellElements = function (startcol, bCommandMode, area, se_info, dir)
    {
        var cells = this._cells;
        var cells_len = cells.length;

        if (cells_len == 0)
            return "";

        var str = "";
        var grid = this._grid,
            update = false,
            datarow = grid._getDataRow(this._rowidx),
            selected, cellinfo;

        if (this._rowidx < 0 || grid._is_created == true)   // grid 생성시점에서 refreshbody 하므로 조건부 call
            update = true;

        var use_recycle_colscroll = grid._use_recycle_colscroll;
        var scol, ecol;

        if (se_info)
        {
            scol = se_info.s;
            ecol = se_info.e;
        }

        var vstart, vend;
        var hlstart = -1, hlend = -1, hrstart = -1;//, hrend = -1;
        var i = (dir < 0) ? cells_len - 1 : 0;

        if (!dir)
            this._clearHideColumnCell();

        var show_start = false;

        while (true)
        {
            cellinfo = cells[i]._refinfo;

            while (true) 
            {
                if (startcol)
                {
                    if ((cellinfo._col + cellinfo._colspan - 1) < startcol)
                        break;
                }

                if (area && cellinfo._area != area)
                    break;

                if (cells[i]._subComp && cells[i]._subComp instanceof nexacro._cellRowGroupItemControl)
                    cells[i]._subComp._updateHScrolling();

                if (cellinfo._area == "body")
                {
                    //cell_elem = cells[i]._control_element;

                    if (this._rowidx >= 0 && scol != undefined)
                    {
                        if (((cellinfo._col + cellinfo._colspan - 1) < scol) || (cellinfo._col > ecol))
                            break;
                    }

                    if (cells[i]._isUpdateArea() || this._floating)
                    {
                        if (grid._isSelectRowType())
                        {
                            if (selected == undefined)
                                selected = grid._isSelectedCell(cells[i]._cellidx, datarow);
                        }
                        else
                        {
                            selected = grid._isSelectedCell(cells[i]._cellidx, datarow);
                        }

                        show_start = true;

                        if (vstart == undefined)
                            vstart = cellinfo._col;

                        vend = cellinfo._col;

                        //---------------------------------------------------------------------------------------------------
                        if (cells[i]._is_created)
                        {
                            if (cells[i]._refresh_display == true)
                            {
                                if (update)
                                {
                                    cells[i].selected = selected;
                                    cells[i]._updateAll();  // 안보이는 영역을 update하지 않으므로 업데이트 처리
                                }

                                // cell_elem.setElementDisplay(""); 
                                cells[i]._refresh_display = false;
                            }
                        }
                        //---------------------------------------------------------------------------------------------------
                        else // cell not created
                        {
                            if (bCommandMode)
                            {
                                if (update)
                                {
                                    cells[i].selected = selected;
                                    cells[i]._updateAll();  // 안보이는 영역을 update하지 않으므로 업데이트 처리
                                }
                                str += cells[i].createCommand();
                            }
                            else if (use_recycle_colscroll)
                            {
                                var currcell = cells[i];
                                var prevcell = this._popHideColumnCell(cellinfo);

                                if (prevcell)
                                {
                                    cells[prevcell._cellidx] = currcell;
                                    prevcell._changeCell(currcell);
                                    cells[i] = prevcell;

                                    if (update)
                                    {
                                        cells[i].selected = selected;
                                        cells[i]._updateAll();  // 안보이는 영역을 update하지 않으므로 업데이트 처리
                                    }
                                }
                                else
                                {
                                    if (update)
                                    {
                                        cells[i].selected = selected;
                                        cells[i]._updateAll();  // 안보이는 영역을 update하지 않으므로 업데이트 처리
                                    }
                                    cells[i].on_created();
                                }
                            }
                            else
                            {
                                if (update)
                                {
                                    cells[i].selected = selected;
                                    cells[i]._updateAll();  // 안보이는 영역을 update하지 않으므로 업데이트 처리
                                }
                                cells[i].on_created();
                            }
                        }
                        //---------------------------------------------------------------------------------------------------
                    }
                    else
                    {
                        if (hlstart == -1)
                            hlstart = cellinfo._col;

                        if (vstart == undefined)
                        {
                            if (hlstart == -1)
                                hlstart = cellinfo._col;

                            hlend = cellinfo._col + cellinfo._colspan - 1;
                        }
                        else
                        {
                            if (hlstart == -1)
                                hrstart = cellinfo._col;

                            //hrend = cellinfo._col + cellinfo._colspan - 1;
                        }

                        if (cells[i]._is_created)
                        {
                            if (use_recycle_colscroll && !show_start)
                            {
                                this._pushHideColumnCell(cells[i]);
                            }

                            if (cells[i]._refresh_display == false)
                            {
                                cells[i]._refresh_display = true;
                                //cell_elem.setElementDisplay("none");  
                            }
                        }
                    }
                }
                else
                {
                    if (cells[i]._is_created)
                        break;

                    if (update)
                        cells[i]._updateAll();
                    if (bCommandMode)
                        str += cells[i].createCommand();
                    else
                        cells[i].on_created();
                }
                break; // 소나큐브무시
            } // end while

            if (dir < 0)
            {
                i--;
                if (i >= 0)
                    continue;
            }
            else
            {
                i++;
                if (i < cells_len)
                    continue;
            }
            break;
        } // end while

        if (se_info)
        {
            se_info.s = vstart;
            se_info.e = vend;
        }

        this._update_scol = vstart;
        this._update_ecol = vend;

        this._hidel_ecol = hlend;
        this._hider_scol = hrstart;

        return str;
    };

    _pGridRow._createsHorzCells = function (col, ani, dir, show_start)
    {
        var cellsrows = this._colsubrowscells;
        var cellsrows_len = cellsrows.length;

        if (cellsrows_len == 0)
            return false;

        var grid = this._grid,
            datarow = grid._getDataRow(this._rowidx),
            selected, cellctrl, cellinfo;
        var cells = this._cells;

        var use_recycle_colscroll = grid._use_recycle_colscroll;

        for (var i = 0; i < cellsrows_len; i++)
        {
            cellctrl = cellsrows[i][col];

            if (!cellctrl)
                continue;

            cellinfo = cellctrl._refinfo;

            if (cellinfo._area == "body")
            {
                if (cellctrl._isUpdateArea())
                {
                    if (grid._isSelectRowType())
                    {
                        if (selected == undefined)
                            selected = grid._isSelectedCell(cellctrl._cellidx, datarow);
                    }
                    else 
                    {
                        selected = grid._isSelectedCell(cellctrl._cellidx, datarow);
                    }

                    show_start = true;
                    cellctrl.selected = selected;
                    cellctrl._updateAll();

                    if (cellctrl._is_created)
                    {
                        if (ani)
                        {
                            if (cellctrl._refresh_display == true)
                            {
                                cellctrl._refresh_display = false;
                                cellctrl._setDisplay(true);
                            }
                        }
                    }
                    else
                    {
                        cellctrl.selected = selected;
                        cellctrl._updateAll();  // 안보이는 영역을 update하지 않으므로 업데이트 처리
                        cellctrl.on_created();
                    }
                }
                else
                {
                    if (cellctrl._is_created)
                    {
                        if (use_recycle_colscroll && !show_start)
                        {
                            this._pushHideColumnCell(cellctrl);
                        }

                        if (ani)
                        {
                            if (cellctrl._refresh_display == false)
                            {
                                cellctrl._setDisplay(false);
                                cellctrl._refresh_display = true;
                            }
                        }
                    }
                }
            }
            else
            {
                cellctrl._updateAll();

                if (!cellctrl._is_created)
                    cellctrl.on_created();
            }
        }
        return show_start;
    };

    _pGridRow._hideHorzCells = function (col) // grid._use_recycle_colscroll == true 일때만 사용
    {
        if (col < 0)
            return;

        var grid = this._grid;
        var cellsrows = this._colsubrowscells;
        var cellsrows_len = cellsrows.length;

        if (cellsrows_len == 0)
            return false;

        var datarow = grid._getDataRow(this._rowidx), cellctrl;

        for (var i = 0; i < cellsrows_len; i++)
        {
            cellctrl = cellsrows[i][col];

            if (!cellctrl)
                continue;

            if (cellctrl._is_created)
            {
                this._pushHideColumnCell(cellctrl);
            }
        }
    };

    _pGridRow._scrollHorzCells = function (col)
    {
        var cellsrows = this._colsubrowscells;
        var cellsrows_len = cellsrows.length;

        if (cellsrows_len == 0)
            return "";

        var grid = this._grid,
            datarow = grid._getDataRow(this._rowidx),
            selected, cellctrl, cellinfo;

        var updated = false;
        for (var i = 0; i < cellsrows_len; i++)
        {
            cellctrl = cellsrows[i][col];

            if (!cellctrl)
                continue;

            cellinfo = cellctrl._refinfo;

            if (cellinfo._area == "body")
            {
                if (grid._isSelectRowType())
                {
                    if (selected == undefined)
                        selected = grid._isSelectedCell(cellctrl._cellidx, datarow);
                }
                else 
                {
                    selected = grid._isSelectedCell(cellctrl._cellidx, datarow);
                }

                cellctrl.selected = selected;
                cellctrl._updateAll();

                if (!cellctrl._is_created)
                {
                    cellctrl.on_created();
                    updated = true;
                }
                else if (cellctrl._refresh_display == true)
                {
                    cellctrl._refresh_display = false;
                    //cellctrl._setDisplay(true);
                    //updated = true;
                }
            }
            else
            {
                cellctrl._updateAll();

                if (!cellctrl._is_created)
                {
                    cellctrl.on_created();
                    updated = true;
                }
            }
        }

        return updated;
    };

    _pGridRow._isUseHideCell = function (cellinfo, datarow)
    {
        if (cellinfo._colspan > 1 || cellinfo._rowspan > 1)
            return false;

        if (cellinfo.expandshow._value != "hide")
            return false;

        return true;
    };

    _pGridRow._clearHideColumnCell = function ()
    {
        this._hide_hscroll_cells = null;
        this._hide_hscroll_cell_indexes = null;
    };

    _pGridRow._pushHideColumnCell = function (cell) // HTML only
    {
        var cellinfo = cell._refinfo;
        var grid = this._grid;
        var datarow = grid._getDataRow(this._rowidx);

        if (!this._isUseHideCell(cellinfo, datarow))
            return false;

        if (cell._editor)
            return false;

        var displaytype = cellinfo._getDisplaytype(datarow);
        var hide_h_cells = this._hide_hscroll_cells;
        var hide_h_cell_indexes = this._hide_hscroll_cell_indexes;
        var h_cells, h_idxes;

        if (!hide_h_cells)
        {
            hide_h_cells = this._hide_hscroll_cells = {};
            hide_h_cell_indexes = this._hide_hscroll_cell_indexes = {};
        }
        if (!hide_h_cells[displaytype])
        {
            hide_h_cells[displaytype] = [];
            hide_h_cell_indexes[displaytype] = new Array(this._cells.length);
        }

        h_cells = hide_h_cells[displaytype];
        h_idxes = hide_h_cell_indexes[displaytype];

        if (!h_idxes[cell._cellidx])
        {
            h_idxes[cell._cellidx] = true;
            h_cells.push(cell);
        }
        return true;
    };

    _pGridRow._popHideColumnCell = function (cellinfo) // HTML only
    {
        var grid = this._grid;
        var datarow = grid._getDataRow(this._rowidx);

        if (!this._isUseHideCell(cellinfo, datarow))
            return null;

        var displaytype = cellinfo._getDisplaytype(datarow);
        var hide_h_cells = this._hide_hscroll_cells;
        var hide_h_cell_indexes = this._hide_hscroll_cell_indexes;
        var cell = null;
        var h_cells, h_idxes;

        if (hide_h_cells && hide_h_cells[displaytype])
        {
            h_cells = hide_h_cells[displaytype];
            h_idxes = hide_h_cell_indexes[displaytype];

            cell = h_cells.pop();
            if (cell) h_idxes[cell._cellidx] = undefined;
        }
        return cell;
    };

    _pGridRow._update_scol = undefined;
    _pGridRow._update_ecol = undefined;
    _pGridRow._hidel_ecol = undefined;
    _pGridRow._hider_scol = undefined;

    _pGridRow._getUpdateColRange = function (dir)
    {
        var cells = this._cells;
        var cells_len = cells.length;
        var cellinfo, vstart, vend, hstart, hend;
        var vs = false, hs = false;

        var prev_hidel = this._hidel_ecol;
        var prev_hider = this._hider_scol;

        for (var i = 0; i < cells_len; i++) 
        {
            cellinfo = cells[i]._refinfo;

            if (cellinfo._area != "body")
                continue;

            var update_area = cells[i]._isUpdateArea();
            if (update_area == false)
            {
                if (!vs)
                {
                    this._hidel_ecol = cellinfo._col;
                }
                else
                {
                    if (!hs)
                    {
                        hs = true;
                        this._hider_scol = cellinfo._col;
                    }
                }
            }
            else
            {
                vs = true;
            }

            if (dir > 0)
            {
                if (cellinfo._col <= this._update_ecol)
                    continue;
            }
            if (dir < 0)
            {
                if (cellinfo._col >= this._update_scol)
                    continue;
            }

            if (cellinfo._area == "body" && update_area)
            {
                if (vstart == undefined)
                    vstart = cellinfo._col;

                vend = cellinfo._col + cellinfo._colspan - 1;
            }
            else if (vstart != undefined)
            {
                break;
            }
        }

        if (dir > 0)
        {
            if (vstart == undefined)
                vstart = this._update_ecol;
            if (vend == undefined)
                vend = vstart;

            hstart = prev_hidel;
            hend = this._hidel_ecol;
        }
        else if (dir < 0)
        {
            if (vend == undefined)
                vend = this._update_scol;
            if (vstart == undefined)
                vstart = vend;

            hstart = this._hider_scol;
            hend = prev_hider;
        }
        else
        {
            if (vstart == undefined)
                vstart = this._update_scol;
            if (vend == undefined)
                vend = this._update_ecol;

            this._hide_scol = this._hide_ecol = undefined;
            hstart = -1;
            hend = -1;
        }

        this._update_scol = vstart;
        this._update_ecol = vend;

        return [[vstart, vend], [hstart, hend]];
    };

    _pGridRow._getColScrollInfo = function (dir)
    {
        var elem = this.getElement();
        var update_left = elem.scroll_left;
        var update_right = update_left + this._grid._adjust_width;

        var cells = this._cells;
        var cells_len = cells.length;
        var cellinfo;
        var start, end;

        for (var i = 0; i < cells_len; i++) 
        {
            cellinfo = cells[i]._refinfo;

            // check inbound
            if (update_left <= cells[i].getOffsetRight() && update_right >= cells[i]._adjust_left)
            {
                start = (start != undefined ? Math.min(start, cellinfo._col) : cellinfo._col);

                if (cellinfo._area == "body")
                {
                    var col = cellinfo._col + cellinfo._colspan - 1;
                    end = (end != undefined ? Math.max(end, col) : col);
                }
                else
                {
                    end = (end != undefined ? Math.max(end, cellinfo._col) : cellinfo._col);
                }
            }
        }

        return [start | 0, end | 0];
    };

    _pGridRow._adjustCellDisplay = function (startcol, endcol)
    {
        var cellsrows = this._colsubrowscells;
        var cellsrows_len = cellsrows.length;

        var cells = this._cells;
        var cells_len = cells.length;
        var cellinfo, cellctrl;

        for (var i = 0; i < cells_len; i++) 
        {
            for (var j = 0; j < cellsrows_len; j++)
            {
                cellctrl = cellsrows[j][i];

                if (!cellctrl)
                    continue;

                cellinfo = cellctrl._refinfo;

                if (cellinfo._area == "body")
                {
                    if (cellctrl._is_created && (cellinfo._col < startcol || cellinfo._col > endcol))
                    {
                        if (cellctrl._refresh_display == false)
                        {
                            cellctrl._refresh_display = true;
                            //cellctrl._setDisplay(false);
                        }
                    }
                }
            }
        }
    };

    _pGridRow._resetCellsSize = function (format, startcol, rowsize_init)
    {
        var cols = this._format_cols, cols_len = cols ? cols.length : 0,
            cells, cells_len, cell, cellinfo, subcells, subcells_len, subcell, subcellinfo,
            left, width, top, height,
            subcol, subrow;

        if (rowsize_init)
            this._init(format);

        this._control_element.setArea(format.leftWidth, format.rightWidth);

        cells = this._cells;
        cells_len = cells.length;

        var _row_tops = this._row_tops,
            // _row_sizes = this._row_sizes,
            _row_bottoms = this._row_bottoms;

        for (var i = 0; i < cells_len; i++)
        {
            cell = cells[i];
            cellinfo = cell._refinfo;

            if (startcol)
            {
                if ((cellinfo._col + cellinfo._colspan - 1) < startcol)
                    continue;
            }

            if (cellinfo._col >= cols_len)
                continue;

            left = cols[cellinfo._col].left;
            top = _row_tops[cellinfo._row];
            width = cols[cellinfo._col + cellinfo._colspan - 1].right - left;
            height = _row_bottoms[cellinfo._row + cellinfo._rowspan - 1] - top;

            cell.move(left, top, width, height);
            // expand도 위치 및 크기 조정
            var expand_ctrl = cell._expandCtrl;
            if (expand_ctrl)
            {
                var border = cell._getCurrentStyleBorder();
                var padding = cell._getCurrentStylePadding();

                left = width - expand_ctrl.width - ((border) ? border.right._width : 0) - ((padding) ? padding.right : 0);
                expand_ctrl.set_left(left);
            }

            subcells = cell.subcells;
            subcells_len = subcells.length;

            for (var j = 0; j < subcells_len; j++)
            {
                subcell = subcells[j];
                subcellinfo = subcell._refinfo;

                subcol = cellinfo._col + subcellinfo._col;
                subrow = cellinfo._row + subcellinfo._row;

                left = cols[subcol].left;
                top = _row_tops[subrow];
                width = cols[subcol + subcellinfo._colspan - 1].right - left;
                height = _row_bottoms[subrow + subcellinfo._rowspan - 1] - top;

                left -= cols[cellinfo._col].left;
                top -= _row_tops[cellinfo._row];

                subcell.move(left, top, width, height);
                // expand도 위치 및 크기 조정
                expand_ctrl = subcell._expandCtrl;
                if (expand_ctrl)
                {
                    left = width - expand_ctrl.width;
                    top = expand_ctrl.top;
                    width = expand_ctrl.width;
                    height = expand_ctrl.height;

                    expand_ctrl.move(left, top, width, height);
                }
            }
        }
    };

    _pGridRow._isEnable = function ()
    {
        if (this._grid)
            return this._grid._enable;

        return true;
    };

    _pGridRow._get_cells = function ()
    {
        return this._cells;
    };

    _pGridRow = null;

    //==============================================================================
    // nexacro._GridMatrixManager
    //==============================================================================
    nexacro._GridMatrixManager = function (grid, band)
    {
        this._width = 0;
        this._height = 0;
        this._grid = grid;
        this._isBody = band._isBody;
        this._rows = [];
        this._band = band;
        this._fixed_rows = [];
    };

    var _pGridMatrixManager = nexacro._createPrototype(nexacro.Object, nexacro._GridMatrixManager);
    nexacro._GridMatrixManager.prototype = _pGridMatrixManager;

    _pGridMatrixManager._is_subcontrol = true;

    //==============================================================================
    // nexacro._GridMatrixManager : Create & Destroy & Update
    //==============================================================================
    _pGridMatrixManager.destroy = function ()
    {
        this._deleteAllRow();
        this._grid = this._band = this._rows = this._fixed_rows = null;
    };

    _pGridMatrixManager._init = function ()
    {
        this._deleteAllRow();
    };

    //==============================================================================
    // nexacro._GridMatrixManager : Logical Part
    //==============================================================================
    _pGridMatrixManager._getBodyRowTopPos = function (rowidx)
    {
        if (rowidx < 0)
            return 0;

        var grid = this._grid,
            top = 0;
        var rowcnt, i;

        if (grid._fixed_endrow >= 0 && rowidx >= grid._fixed_startrow && rowidx <= grid._fixed_endrow)
        {
            if (grid._is_variable_bodyrowsize == false)
            {
                top = grid._bodyrowheight * (rowidx - grid._fixed_startrow);
            }
            else
            {
                rowcnt = grid._fixed_rowcnt;

                for (i = 0; i < rowcnt; i++)
                {
                    if (grid._fixed_startrow + i == rowidx)
                        break;

                    top += grid._getRowSize(grid._fixed_startrow + i);
                }
            }
        }
        else if (rowidx < grid._fixed_startrow)
        {
            rowcnt = grid._getGridRowCount();

            for (i = 0; i < rowcnt; i++)
            {
                var prow = grid._rowToPageRow(i);

                if (prow == grid._fixed_startrow)
                    break;

                top += grid._getRowSize(prow);
            }
            top = -top;
        }
        else
        {
            if (grid._is_variable_bodyrowsize == false)
            {
                top = grid._bodyrowheight * grid._pageRowToRow(rowidx);
            }
            else
            {
                rowcnt = grid._getGridRowCount();

                for (i = 0; i < rowcnt; i++)
                {
                    var prow = grid._rowToPageRow(i);

                    if (prow == rowidx)
                        break;

                    top += grid._getRowSize(prow);
                }
            }

            top -= grid._fixedrow_height;
        }
        return top;
    };

    _pGridMatrixManager._getAllRows = function ()
    {
        var rows;

        if (this._isBody && this._fixed_rows.length)
        {
            rows = [];
            rows = rows.concat(this._fixed_rows);
            rows = rows.concat(this._rows);
        }
        else
        {
            rows = this._rows;
        }
        return rows;
    };

    _pGridMatrixManager._getPhysicalRow = function (rows, rowidx)
    {
        var length = rows.length;

        for (var i = 0; i < length; i++)
        {
            if (rows[i]._rowidx == rowidx)
            {
                return i;
            }
        }
        return null;
    };

    _pGridMatrixManager._adjustTreeDisplay = function (rowidx, collapse)
    {
        var update_rows = [],
            grid = this._grid,
            band = this._band,
            rows = this._rows,
            rows_len = rows.length,
            toprow = 0,
            update_row_phidx = this._getPhysicalRow(this._rows, rowidx), //treerow -> physicalrow
            update_row = rows[update_row_phidx],
            sub = false, i;

        if (!update_row)
        {
            update_row = rows[0];
            update_row_phidx = 0;
        }

        if (update_row)
        {
            if (collapse)
            {
                for (i = rows_len - 1; i >= update_row_phidx; i--)
                {
                    if (update_row._rowidx < rows[i]._rowidx)
                    {
                        this._subtractRow();
                        sub = true;
                    }
                    else
                    {
                        update_rows[0] = rows[i];
                    }
                }
            }
            else
            {
                for (i = update_row_phidx; i < rows_len; i++)
                {
                    if (update_row_phidx == i)
                    {
                        update_rows[0] = rows[i];
                    }
                    else
                    {
                        this._subtractRow();
                        sub = true;
                    }
                }
            }
        }

        if (sub)
        {
            grid._setHscrollElement();
            grid._absolutelyResetScrollPos(true);
            grid._control_element.setElementHScrollPos(grid._scroll_left);
            grid._absolutelyResetScrollPos(false);
        }

        var add = this._adjustRowsDisplay();

        rows_len = rows.length;
        band._update_rows = update_rows;

        if (rows_len)
            toprow = rows[0]._rowidx;

        for (i = 0; i < rows_len; i++)
        {
            rows[i]._rowidx = toprow + i;
        }


        var _vposold = (grid._vscrollmng) ? grid._vscrollmng._pos : 0;

        var change = grid._resetColSizeList();
        if (change || add)
        {
            this._adjustColsDisplay(true);

            if (grid._is_variable_bodyrowsize)
                band._clearScrollDisplayRows();
        }
        else
            grid._resetScrollMax();

        var _vposnew = (grid._vscrollmng) ? grid._vscrollmng._pos : 0;

        var vlimit = Math.ceil(grid._control_element.vscroll_limit);

        if (_vposnew < 0)
            _vposnew = 0;
        else if (_vposnew > vlimit)
            _vposnew = vlimit;

        if (_vposold != _vposnew)
        {
            grid._toprowpos = grid._getScreenTopRowPos(_vposnew);
            grid._bottomrowpos = grid._getScreenBottomRowPos(_vposnew);
        }

        // ._on_refresh_rows <- suppress 여부 판단 
        // 1) ._toprowpos, ._bottomrowpos를  트리가 펼쳐지거나 접힌 후에 변경된 scroll값 기준으로 구해주고 
        // 2) ._on_refresh_rows를 호출하여 toprow 기준으로 suppress row 판단 
        band._on_refresh_rows();

        return change;
    };

    _pGridMatrixManager._adjustRowsDisplay = function (reset_bandsize, is_scrolling)
    {
        var grid = this._grid,
            add = false, sub = false,
            rows = this._rows,
            rows_len = rows.length,
            addcnt, i, n, size, top;
        var rowitem, l, t, w, h, gridrowcnt;
        var is_fillarea = grid._isFillAreatype();

        if (this._isBody)
        {
            if (reset_bandsize)
            {
                gridrowcnt = grid._getGridRowCount();
                for (i = 0; i < rows.length; i++)
                {
                    rowitem = rows[i];

                    if (rowitem._rowidx >= gridrowcnt)
                    {
                        rowitem.destroy();
                        rows[i] = null;
                        rows.splice(i, 1);
                        i--;
                        sub = true;
                    }
                    else
                    {
                        l = rowitem._adjust_left;
                        t = this._getBodyRowTopPos(rowitem._rowidx);
                        w = this._band._getClientWidth();
                        h = grid._getRowSize(rowitem._rowidx);
                        rows[i].move(l, t, w, h);
                    }
                }
                rows_len = rows.length;

                var frows = this._fixed_rows;

                for (i = 0, n = frows.length; i < n; i++)
                {
                    rowitem = frows[i];
                    l = rowitem._adjust_left;
                    t = this._getBodyRowTopPos(rowitem._rowidx);
                    w = this._band._getClientWidth();
                    h = grid._getRowSize(rowitem._rowidx);
                    frows[i].move(l, t, w, h);
                }
            }

            /***** fix area *****/
            if (grid._fixed_endrow >= 0 && this._fixed_rows.length == 0)
            {
                var sfixrow = grid._fixed_startrow;
                var efixrow = grid._fixed_endrow;
                top = 0;

                for (i = sfixrow; i <= efixrow; i++)
                {
                    size = grid._getRowSize(i);
                    if (size < 0)
                        break;

                    this._addRow(top, size, i, false, true);
                    top += size;
                }
            }
            /********************/

            grid._resetDisplayInfo(reset_bandsize);

            var dispcnt = 0;
            var rowcnt = grid._getGridRowCount();

            if (grid._disprowcnt > 0)
            {
                if (rowcnt > 0)
                {
                    addcnt = (grid._disprowcnt % 2) ? 1 : 2;
                    dispcnt = grid._disprowcnt + addcnt;
                }
                else if (is_fillarea)
                {
                    dispcnt = grid._pagerowrealcnt;
                }
            }

            var variable_size = grid._is_variable_bodyrowsize;

            if (dispcnt < 0)
                dispcnt = 0;

            if (rowcnt < rows_len)  // 물리적 갯수보다 data 갯수가 줄어들었을 경우 처리.
            {
                if (this._isBody)
                {
                    var fillrowcnt = 0;
                    if (is_fillarea && rowcnt == 0)
                    {
                        for (i = rows_len - 1; i >= rowcnt; i--)
                        {
                            if (grid._getDataRow(rows[i]._rowidx) == -9)
                                fillrowcnt++;
                        }
                    }

                    rows_len -= fillrowcnt;
                }

                for (i = rows_len - 1; i >= rowcnt; i--)
                {
                    this._subtractRow();
                    sub = true;
                }

                if (sub)
                    rows_len = rows.length;
            }

            if (dispcnt < rows_len)
            {
                if (rows_len % 2 == 0)  // 예) 화면에 보일수 있는 row갯수 4, 실제 data 갯수 5인 경우 무조건 row를 짝수개(6개)로 만들 수 없는 예외가 존재함. 이 경우 라운드로빈 스크롤을 위해 5번째 row를 지우지 않음.
                {
                    for (i = rows_len - 1; i >= dispcnt; i--)
                    {
                        if (!variable_size)
                        {
                            this._subtractRow();
                            sub = true;
                        }
                    }
                }
            }
            else if (dispcnt > rows_len)
            {
                var toprow = 0, lastrow = rowcnt - 1;

                if (rows_len > 0)
                    toprow = rows[0]._rowidx;
                else
                    toprow = grid._toprowpos[0];

                lastrow += grid._rowToPageRow(0);

                var backrow = toprow;
                var newrow, back = false;

                if (rows_len > 0 && toprow > grid._toprowpos[0]) // 위의 빈영역 채우기
                {
                    for (i = grid._toprowpos[0]; i < toprow; i++)
                    {
                        newrow = i;
                        top = this._getBodyRowTopPos(newrow);
                        size = grid._getRowSize(newrow);

                        if (newrow <= lastrow && newrow >= grid._getFixRowCnt() && size > 0)
                        {
                            this._addRow(top, size, newrow, is_scrolling);
                            add = true;
                        }
                    }
                }

                for (i = rows_len; i < dispcnt; i++)
                {
                    if (rowcnt <= i)
                        break;

                    newrow = toprow + i;

                    if (lastrow < newrow)   // 마지막 row이면 위에
                    {
                        newrow = --backrow;
                        back = true;
                    }

                    top = this._getBodyRowTopPos(newrow);
                    size = grid._getRowSize(newrow);

                    if (newrow <= lastrow && newrow >= grid._getFixRowCnt() && size > 0)
                    {
                        this._addRow(top, size, newrow, is_scrolling);
                        add = true;
                    }
                }
                if (back && add)
                {
                    rows.sort(function (a, b) { return a._rowidx - b._rowidx; });
                }
            }

            rows_len = rows.length;

            if (is_fillarea && dispcnt > rows_len)
            {
                top = 0;
                size = this._band._datarowsheight;

                if (rows_len)
                    top = rows[rows_len - 1].getOffsetBottom();

                for (i = rows_len; i < dispcnt; i++)
                {
                    if (!is_scrolling)
                    {
                        this._addRow(top, size, i, is_scrolling);
                        top += size;
                        add = true;
                    }
                }
            }

            if (rows.length > 0)
            {
                grid._begrowpos = rows[0]._rowidx;
                grid._endrowpos = rows[rows.length - 1]._rowidx;
            }
            else
            {
                grid._begrowpos = 0;
                grid._endrowpos = 0;
            }
        }
        else
        {
            if (reset_bandsize)
            {
                for (i = 0; i < rows.length; i++)
                {
                    rowitem = rows[i];

                    l = rowitem._adjust_left;
                    t = rowitem._adjust_top;
                    w = this._band._getClientWidth();
                    h = this._band._getClientHeight();
                    rowitem.move(l, t, w, h);
                }
            }

            if (rows_len == 0)
            {
                if (this._band.id == "head")
                {
                    size = grid._getRowSize(-1);
                    this._addRow(0, size, -1);
                    add = true;
                }
                else if (this._band.id == "summary")
                {
                    size = grid._getRowSize(-2);
                    this._addRow(0, size, -2);
                    add = true;
                }
            }
        }

        if (add || sub || rows.length == 0)
        {
            grid._setHscrollElement();
            grid._absolutelyResetScrollPos(true);
            grid._control_element.setElementHScrollPos(grid._scroll_left);
            grid._absolutelyResetScrollPos(false);

            if (grid._is_variable_bodyrowsize)
                this._band._clearScrollDisplayRows();
        }

        return add;
    };

    _pGridMatrixManager._adjustColsDisplay = function (reset_colsize, scrolling, startcol, dir)
    {
        if (!scrolling)
            this._grid._resetScrollMax();

        var rows = this._getAllRows(),
            rows_len = rows.length;
        var i;

        if (reset_colsize)
        {
            var format = this._grid._curFormat;

            for (i = 0; i < rows_len; i++)
            {
                rows[i]._init(format);
                rows[i].set_width(rows[i].parent._getClientWidth());    // band와 sync를 맞춤.
                rows[i]._resetCellsSize(format, startcol);

                if (!scrolling)
                    rows[i]._updateAll(null, false, undefined, undefined, startcol);

                rows[i]._createCellElements(startcol, undefined, undefined, undefined, dir);
            }
        }
        else
        {
            for (i = 0; i < rows_len; i++)
            {
                if (!scrolling)
                    rows[i]._updateAll(null, true, undefined, undefined, startcol);

                rows[i]._createCellElements(startcol, undefined, undefined, undefined, dir);
            }
        }
    };

    _pGridMatrixManager._adjustColsScrollEnd = function (startcol, endcol)
    {
        var rows = this._getAllRows(),
            rows_len = rows.length;

        for (var rowidx = 0; rowidx < rows_len; rowidx++)
        {
            rows[rowidx]._adjustCellDisplay(startcol, endcol);
        }
    };

    _pGridMatrixManager._adjustColsDisplay2 = function (dir)
    {
        var rows = this._getAllRows(), show_col_range, hide_range,
            rows_len = rows.length;

        var grid = this._grid;
        var perfscroll = grid._is_performance_scroll;

        for (var i = 0; i < rows_len; i++)
        {
            if (!show_col_range)
            {
                var range = rows[i]._getUpdateColRange(dir);
                show_col_range = range[0];
                hide_range = range[1];
            }

            var j;
            var show_start;

            if (dir < 0)
            {
                show_start = false;
                for (j = show_col_range[1]; j >= show_col_range[0]; j--)
                {
                    show_start = rows[i]._createsHorzCells(j, perfscroll, dir, show_start);
                }
            }
            else 
            {
                show_start = false;
                for (j = show_col_range[0]; j <= show_col_range[1]; j++)
                {
                    show_start = rows[i]._createsHorzCells(j, perfscroll, dir, show_start);
                }
            }
        }
    };

    _pGridMatrixManager._adjustColsScroll = function (dir, startcol, endcol, framecnt)
    {
        var rows = this._getAllRows(),
            rows_len = rows.length;

        var updated = false;
        var colidx;
        var rowidx;

        if (dir < 0)
        {
            for (colidx = endcol; colidx >= startcol; colidx--)
            {
                for (rowidx = 0; rowidx < rows_len; rowidx++)
                {
                    updated |= rows[rowidx]._scrollHorzCells(colidx);
                }
                if (updated) framecnt--;
                if (framecnt == 0) return colidx;
                updated = false;
            }
        }
        else if (dir > 0)
        {
            for (colidx = startcol; colidx <= endcol; colidx++)
            {
                for (rowidx = 0; rowidx < rows_len; rowidx++)
                {
                    updated |= rows[rowidx]._scrollHorzCells(colidx);
                }
                if (updated) framecnt--;
                if (framecnt == 0) return colidx;
                updated = false;
            }
        }
        return endcol;
    };

    _pGridMatrixManager._addRow = function (top, height, rowidx, is_scrolling, is_fixed)
    {
        var rect = this._grid._getAvailableRect(this._band),
            row = new nexacro._GridRowControl(this._band, rect.left, top, rect.width, height, rowidx);

        row._fixed = !!is_fixed;
        row.createComponent();

        if (!is_scrolling)
            this._band._create_rows.push(row);

        if (is_fixed)
            this._fixed_rows.push(row);
        else
            this._rows.push(row);
    };

    _pGridMatrixManager._subtractRow = function ()
    {
        if (this._rows.length > 0)
        {
            var rowidx = this._rows.length - 1,
                row = this._rows[rowidx],
                create_rows = this._band._create_rows,
                create_rows_len = create_rows.length;

            for (var i = 0; i < create_rows_len; i++)
            {
                if (create_rows[i] == row)
                {
                    create_rows.splice(i, 1);
                    break;
                }
            }
            row.destroy();
            this._rows.splice(rowidx, 1);
        }
    };

    _pGridMatrixManager._deleteAllRow = function ()
    {
        var rows = this._rows;

        for (var i = 0, n = rows.length; i < n; i++)
            rows[i].destroy();

        this._band._clearScrollDisplayRows();

        var fixed_rows = this._fixed_rows;

        for (i = 0, n = fixed_rows.length; i < n; i++)
            fixed_rows[i].destroy();

        var create_rows = this._band._create_rows;

        for (i = 0, n = create_rows.length; i < n; i++)
            create_rows[i].destroy();

        this._band._create_rows = [];
        this._rows = [];
        this._fixed_rows = [];
        this._grid._setHscrollElement();
        this._grid._is_over_scroll = 0;
        this._grid._destroyResizer();
    };

    _pGridMatrixManager._isShowScreenRow = function (row, scroll_top, client_height)
    {
        if (row._rowidx < 0)
            return true;

        var visible_top = scroll_top,
            visible_bottom = visible_top + client_height;

        if (visible_top < row.getOffsetBottom() && visible_bottom > row._adjust_top)
            return true;

        return false;
    };

    _pGridMatrixManager._getScrollRowsInfo = function (vpos, each, scrollrows)
    {
        var grid = this._grid,
            rows = this._rows, rows_len = rows.length,
            lastPosition = grid._last_scroll_top;

        var update_info = scrollrows || {};

        var _prev_toprowpos = grid._toprowpos;
        var _prev_bottomrowpos = grid._bottomrowpos;
        var _prev_dir = update_info.dir;
        var display_rows;
        var i, n;

        update_info.timestamp = (performance ? performance.now() : (new Date()));
        update_info.starttime = update_info.timestamp;
        update_info.scrollmode = each;
        update_info.framecnt = (each ? each : rows_len);
        update_info.skipped = 0;
        update_info.toprow = grid._getScreenTopRowPos(vpos);
        update_info.bottomrow = grid._getScreenBottomRowPos(vpos);
        update_info.bottomrowex = [update_info.bottomrow, 0];
        update_info.usehidden = true;

        if (!update_info.display_rows) // scroll rows 정보 생성
        {
            update_info.display_rows = display_rows = [];

            for (i = 0, n = rows_len; i < n; i++)
            {
                display_rows.push(rows[i]);
            }

            if (grid._is_variable_bodyrowsize)
                display_rows.sort(function (a, b) { return a._rowidx - b._rowidx; });
        }
        else
        {
            display_rows = update_info.display_rows;
        }

        var toprowpos, bottomrowpos;
        var updaterow;
        var display_cnt;
        var out_cnt;

        if (vpos > lastPosition)
        {
            toprowpos = update_info.toprow[0];
            bottomrowpos = update_info.bottomrow;

            update_info.dir = 1;

            // update 여부는 (toprow[0] + curidx) != row._rowidx 일 경우 display_rows[curidx]를 update하고 curidx 증가
            update_info.curidx = 0;

            if (bottomrowpos < 0)
            {
                update_info.bottomrowex = grid._getScreenBottomRowPosEx(vpos);
            }

            updaterow = Math.max(_prev_bottomrowpos + 1, toprowpos);

            if (updaterow > toprowpos)
            {
                if (_prev_dir < 0 && bottomrowpos > 0)
                {
                    display_cnt = (bottomrowpos - toprowpos + 1);
                    for (i = 0, n = (rows_len - display_cnt); i < n; i++)
                    {
                        display_rows.push(display_rows.shift());
                    }
                }

                out_cnt = (toprowpos - _prev_toprowpos[0]);

                for (i = 0, n = out_cnt; i < n; i++)
                {
                    display_rows.push(display_rows.shift());
                }
            }
        }
        else if (vpos < lastPosition)
        {
            toprowpos = update_info.toprow[0];
            bottomrowpos = update_info.bottomrow;

            update_info.dir = -1;

            // update 여부는 (bottomrow - (row_len-1-i)) != row._rowidx 일 경우 display_rows[curidx]를 update하고 curidx 감소
            update_info.curidx = rows_len - 1;

            updaterow = Math.min(_prev_toprowpos[0] - 1, bottomrowpos);
            if (updaterow < bottomrowpos)
            {
                if (_prev_dir > 0 && toprowpos > 0)
                {
                    display_cnt = (bottomrowpos - toprowpos + 1);
                    for (i = 0, n = (rows_len - display_cnt); i < n; i++)
                    {
                        display_rows.unshift(display_rows.pop());
                    }
                }

                out_cnt = (_prev_toprowpos[0] - toprowpos);//(_prev_bottomrowpos - bottomrowpos);

                for (i = 0, n = out_cnt; i < n; i++)
                {
                    display_rows.unshift(display_rows.pop());
                }
            }
        }

        return update_info;
    };

    _pGridMatrixManager._adjustScrollRows = function (vpos, is_updatecontents, each, startrow, rowsize_init)
    {
        var grid = this._grid;

        if (grid._p_createrowstype === "all")
            return [];

        var totalcnt = grid._getGridRowCount(),
            rows = this._rows, psrow = grid._rowToPageRow(0),
            first_rowidx = grid._getFixRowCnt() + psrow,
            last_rowidx = (totalcnt - 1) + psrow,
            hide_rows = [], hide_row,
            r, l, w, h, t,
            band = this._band,
            variable_size = grid._is_variable_bodyrowsize,
            hide_len = 0,
            dir = 0, hidecnt = 0, target_rowidx,
            lastPosition = grid._last_scroll_top, b_row_sort = false, b_adjust_row = false,
            editor = grid._currentCellEditor,
            swap_row1 = (editor) ? editor.parent.parent : null, swap_row2 = null,
            editing_rowidx = grid._getGridRow(grid._currentCellRow);

        if (editor && editor.parent._is_mergetemp)
        {
            swap_row1 = null;
            editing_rowidx = -1;
        }

        var updateinfo = band._rowscroll_info;
        var usehidden = (updateinfo) ? updateinfo.usehidden : false;

        if (vpos > lastPosition)
            dir = 1;
        else if (vpos < lastPosition)
            dir = -1;

        if (!each)
            each = rows.length;

        var i, n;
        var prev_rowidx;

        if (dir > 0)
        {
            for (i = 0, n = rows.length; i < n; i++)
            {
                if (this._isShowScreenRow(rows[i], vpos, band._getClientHeight()) == true)
                    break;

                if (each > hide_rows.length)
                    hide_rows.push(rows[i]);

                hidecnt++;
            }

            hide_len = hide_rows.length;

            prev_rowidx = null;

            if (hide_len > 0)
            {
                if (rows.length == hidecnt) // hide all rows
                {
                    target_rowidx = grid._toprowpos[0];

                    if (target_rowidx % 2 != hide_rows[0]._rowidx % 2)
                    {
                        hide_rows.push(hide_rows.shift());
                        rows.push(rows.shift());
                    }

                    for (i = 0; i < hide_len; i++)
                    {
                        hide_row = hide_rows[i];

                        if (i == 0 && hide_row._overrow)
                            break;

                        hide_row._overrow = false;
                        r = target_rowidx++;

                        if (r > last_rowidx)
                        {
                            if (prev_rowidx == null)
                                prev_rowidx = grid._toprowpos[0] - 1;

                            r = prev_rowidx--;
                            hide_row._overrow = true;

                            // 여기서 even odd가 틀어질 경우 cell updateall에서 보정함.

                            if (r < 0)
                            {
                                break; // 여기를 탈 경우는 문제가 있음.
                            }
                        }

                        if (r == editing_rowidx)
                            swap_row2 = hide_row;

                        hide_row._changeRow(r, variable_size);
                        l = hide_row._adjust_left;
                        w = hide_row._adjust_width;
                        h = grid._getRowSize(r);
                        t = this._getBodyRowTopPos(r);
                        hide_row.move(l, t, w, h);

                        if (variable_size)
                            hide_row._resetCellsSize(grid._curFormat, undefined, rowsize_init);
                    }
                }
                else
                {
                    target_rowidx = rows[rows.length - 1]._rowidx + 1;

                    for (i = 0; i < hide_len; i++)
                    {
                        hide_row = hide_rows[i];
                        hide_row._overrow = false;
                        r = target_rowidx++;

                        if (r > last_rowidx)
                        {
                            if (!variable_size)
                            {
                                hide_rows.splice(i--, 1);
                                hide_len = hide_rows.length;
                            }
                            continue;
                        }
                        if (r == editing_rowidx)
                            swap_row2 = hide_row;

                        hide_row._changeRow(r, variable_size);
                        l = hide_row._adjust_left;
                        w = hide_row._adjust_width;
                        h = grid._getRowSize(r);
                        t = this._getBodyRowTopPos(r);
                        hide_row.move(l, t, w, h);

                        if (variable_size)
                            hide_row._resetCellsSize(grid._curFormat, undefined, rowsize_init);
                    }
                    b_row_sort = true;
                }
                if (prev_rowidx != null)
                    b_row_sort = true;
            }

            if (variable_size)
                b_adjust_row = true;
        }
        else if (dir < 0)
        {
            for (i = rows.length - 1; i >= 0; i--)
            {
                if (this._isShowScreenRow(rows[i], vpos, band._getClientHeight()) == true)
                    break;

                if (each > hide_rows.length)
                    hide_rows.push(rows[i]);

                hidecnt++;
            }

            hide_len = hide_rows.length;

            if (hide_len > 0)
            {
                if (rows.length == hidecnt)
                {
                    target_rowidx = grid._toprowpos[0];

                    if (target_rowidx % 2 != hide_rows[hide_len - 1]._rowidx % 2)
                    {
                        hide_rows.push(hide_rows.shift());
                        rows.unshift(rows.pop());
                    }

                    for (i = hide_len - 1; i >= 0; i--)
                    {
                        hide_row = hide_rows[i];
                        hide_row._overrow = false;
                        r = target_rowidx++;

                        if (r == editing_rowidx)
                            swap_row2 = hide_row;

                        hide_row._changeRow(r, variable_size);

                        if (variable_size)
                            hide_row._resetCellsSize(grid._curFormat, undefined, rowsize_init);
                    }

                    for (i = 0; i < hide_len; i++)
                    {
                        hide_row = hide_rows[i];
                        r = hide_row._rowidx;
                        l = hide_row._adjust_left;
                        w = hide_row._adjust_width;
                        h = grid._getRowSize(r);
                        t = this._getBodyRowTopPos(r);
                        hide_row.move(l, t, w, h);
                    }
                }
                else
                {
                    target_rowidx = rows[0]._rowidx - 1;

                    for (i = 0; i < hide_len; i++)
                    {
                        hide_row = hide_rows[i];
                        hide_row._overrow = false;
                        r = target_rowidx--;

                        if (r < first_rowidx)
                            continue;

                        if (r == editing_rowidx)
                            swap_row2 = hide_row;

                        hide_row._changeRow(r, variable_size);
                        l = hide_row._adjust_left;
                        w = hide_row._adjust_width;
                        h = grid._getRowSize(r);
                        t = this._getBodyRowTopPos(r);
                        hide_row.move(l, t, w, h);

                        if (variable_size)
                            hide_row._resetCellsSize(grid._curFormat, undefined, rowsize_init);
                    }

                    if (rowsize_init)
                    {
                        for (i = 0; i < rows.length; i++)
                        {
                            h = grid._getRowSize(rows[i]._rowidx);
                            t = this._getBodyRowTopPos(rows[i]._rowidx);
                            rows[i].move(rows[i]._adjust_left, t, rows[i]._adjust_width, h);
                            rows[i]._resetCellsSize(grid._curFormat, undefined, rowsize_init);
                        }
                    }

                    b_row_sort = true;
                }

                if (variable_size)
                    b_adjust_row = true;
            }
        }
        else // dir == 0
        {
            if (is_updatecontents)
            {
                prev_rowidx = null;

                target_rowidx = grid._toprowpos[0];

                var org_row, org_rows = rows, orgrows_len = rows.length;

                if (orgrows_len && target_rowidx % 2 != org_rows[0]._rowidx % 2)
                {
                    var oddrow = org_rows.shift();
                    org_rows.push(oddrow);
                }

                for (i = 0; i < orgrows_len; i++)
                {
                    org_row = org_rows[i];

                    org_row._overrow = false;
                    r = target_rowidx++;

                    if (r > last_rowidx)
                    {
                        if (prev_rowidx == null)
                            prev_rowidx = grid._toprowpos[0] - 1;

                        r = prev_rowidx--;
                        org_row._overrow = true;

                        // 여기서 even odd가 틀어질 경우 cell updateall에서 보정함.

                        if (r < 0)
                        {
                            break; // 여기를 탈 경우는 문제가 있음.
                        }
                    }

                    var change = org_row._changeRow(r, variable_size);

                    if (r == editing_rowidx)
                        swap_row2 = org_row;

                    l = org_row._adjust_left;
                    w = org_row._adjust_width;
                    h = grid._getRowSize(r);
                    t = this._getBodyRowTopPos(r);

                    if (h < 0)
                        continue;

                    org_row.move(l, t, w, h);

                    if (usehidden)
                        org_row._control_element.setElementDisplay("");

                    if (variable_size)
                        org_row._resetCellsSize(grid._curFormat, undefined, rowsize_init);

                    if (change)
                        hide_rows.push(org_row);
                }

                if (prev_rowidx != null)
                    b_row_sort = true;

                if (variable_size)
                    b_adjust_row = true;
            }
        }

        if (rows.length > 0)
        {
            if (swap_row1 && swap_row2 && (swap_row1 != swap_row2)) // round robin 후 editable 상태일 때 focus 유지를 위해 edit를 가진 row를 다시 활용 필요.
            {
                var tr = swap_row1._rowidx;
                var tl = swap_row1._adjust_left;
                var tt = swap_row1._adjust_top;
                var tw = swap_row1._adjust_width;
                var th = swap_row1._adjust_height;

                swap_row1._changeRow(swap_row2._rowidx, variable_size);
                swap_row1.move(swap_row2._adjust_left, swap_row2._adjust_top, swap_row2._adjust_width, swap_row2._adjust_height);

                swap_row2._changeRow(tr, variable_size);
                swap_row2.move(tl, tt, tw, th);

                if (variable_size)
                {
                    swap_row1._resetCellsSize(grid._curFormat, undefined, rowsize_init);
                    swap_row2._resetCellsSize(grid._curFormat, undefined, rowsize_init);
                }

                if (hide_rows.length != rows.length)    // 모든row 갱신이 아닐 경우 swap후 swap_row1 update 필요
                    hide_rows.push(swap_row1);

                b_row_sort = true;
            }

            if (b_row_sort)
                rows.sort(function (a, b) { return a._rowidx - b._rowidx; });

            if (b_adjust_row)
                this._adjustRowsDisplay(false, true);

            grid._begrowpos = rows[0]._rowidx;
            grid._endrowpos = rows[rows.length - 1]._rowidx;
        }

        return hide_rows;
    };

    _pGridMatrixManager._adjustScrollRows2 = function (vpos, is_updatecontents, each)
    {
        var grid = this._grid,
            totalcnt = grid._getGridRowCount(), psrow = grid._rowToPageRow(0),
            first_rowidx = grid._getFixRowCnt() + psrow,
            last_rowidx = (totalcnt - 1) + psrow,
            body = this._band,
            rows = this._rows,
            variable_size = grid._is_variable_bodyrowsize,
            //b_row_sort = false,
            b_adjust_row = false,
            editor = grid._currentCellEditor,
            swap_row1 = (editor) ? editor.parent.parent : null, swap_row2 = null,
            editing_rowidx = grid._getGridRow(grid._currentCellRow);

        if (editor && editor.parent._is_mergetemp)
        {
            swap_row1 = null;
            editing_rowidx = -1;
        }

        var updateinfo = body._rowscroll_info;
        if (!updateinfo) 
        {
            body._update_rows = this._adjustScrollRows(vpos, is_updatecontents, each);
            return (body._update_rows.length > 0);
        }

        if (!this._use_enhance_performance_scrolling)
        {
            body._update_rows = [];
        }

        if (!each)
            each = updateinfo.framecnt;

        var dir = updateinfo.dir;
        var scrollmode = updateinfo.scrollmode;
        var skipped = updateinfo.skipped | 0;
        var framecnt = (scrollmode == 0 ? each : each * (1 + skipped));
        var toprow = updateinfo.toprow[0];
        var bottomrow = updateinfo.bottomrow;
        var usehidden = updateinfo.usehidden;
        var display_rows = updateinfo.display_rows;
        var row_len = display_rows ? display_rows.length : 0;
        var curidx = updateinfo.curidx;
        var editrowidx = -1;
        var editrowswapidx = -1;
        var continue_scroll = false;
        var i;

        var row, rowidx, newidx, l, w, h, t;
        if (dir > 0)
        {
            for (i = curidx; i < row_len; i++)
            {
                row = display_rows[i];
                rowidx = row._rowidx;
                newidx = toprow + i;

                if (swap_row1 && swap_row1 == row)
                    editrowidx = i;

                if (framecnt > 0)
                {
                    if (usehidden)
                        row._control_element.setElementDisplay("");

                    if (newidx != rowidx)
                    {
                        if (!variable_size && newidx > last_rowidx)
                            continue;

                        if (newidx == editing_rowidx)
                        {
                            swap_row2 = row;
                            editrowswapidx = i;
                        }

                        row._changeRow(newidx, variable_size);
                        l = row._adjust_left;
                        w = row._adjust_width;
                        h = grid._getRowSize(newidx);
                        t = this._getBodyRowTopPos(newidx);
                        row.move(l, t, w, h);

                        body._update_rows.push(row);

                        if (variable_size)
                            row._resetCellsSize(grid._curFormat);

                        --framecnt;
                    }
                    updateinfo.curidx++;
                }
                else if (usehidden)
                {
                    row._control_element.setElementDisplay(newidx != rowidx ? "none" : "");
                }
                if (!usehidden && framecnt <= 0) break;
            }
            if (variable_size)
                b_adjust_row = true;

            continue_scroll = (updateinfo.curidx < row_len);
        }
        else if (dir < 0)
        {
            if (variable_size)
                this._adjustRowsDisplay(false, true);

            var borromrowidx = row_len - 1;
            for (i = curidx; i >= 0; i--)
            {
                row = display_rows[i];
                rowidx = row._rowidx;
                //newidx = toprow+i;
                newidx = bottomrow - (borromrowidx - i);

                if (swap_row1 && swap_row1 == row)
                    editrowidx = i;

                var row_elem = row._control_element;
                if (framecnt > 0)
                {
                    if (usehidden)
                        row_elem.setElementDisplay("");

                    if (newidx != rowidx)
                    {
                        if (newidx < first_rowidx)
                            continue;

                        if (newidx == editing_rowidx)
                        {
                            swap_row2 = row;
                            editrowswapidx = i;
                        }

                        row._changeRow(newidx, variable_size);
                        l = row._adjust_left;
                        w = row._adjust_width;
                        h = grid._getRowSize(newidx);
                        t = this._getBodyRowTopPos(newidx);
                        row.move(l, t, w, h);

                        body._update_rows.push(row);

                        if (variable_size)
                            row._resetCellsSize(grid._curFormat);

                        --framecnt;
                    }
                    updateinfo.curidx--;
                }
                else if (usehidden)
                {
                    row_elem.setElementDisplay(newidx != rowidx ? "none" : "");
                }
                if (!usehidden && framecnt <= 0) break;
            }

            continue_scroll = (updateinfo.curidx >= 0);
        }

        if (rows.length > 0)
        {
            if (swap_row1 && swap_row2 && (swap_row1 != swap_row2)) // round robin 후 editable 상태일 때 focus 유지를 위해 edit를 가진 row를 다시 활용 필요.
            {
                var tr = swap_row1._rowidx;
                var tl = swap_row1._adjust_left;
                var tt = swap_row1._adjust_top;
                var tw = swap_row1._adjust_width;
                var th = swap_row1._adjust_height;

                swap_row1._changeRow(swap_row2._rowidx, variable_size);
                swap_row1.move(swap_row2._adjust_left, swap_row2._adjust_top, swap_row2._adjust_width, swap_row2._adjust_height);

                swap_row2._changeRow(tr, variable_size);
                swap_row2.move(tl, tt, tw, th);

                if (variable_size)
                {
                    swap_row1._resetCellsSize(grid._curFormat);
                    swap_row2._resetCellsSize(grid._curFormat);
                }

                display_rows[editrowswapidx] = swap_row1;
                display_rows[editrowidx] = swap_row2;

                body._update_rows.push(swap_row1);

                //b_row_sort = true;
            }

            //if (b_row_sort)
            rows.sort(function (a, b) { return a._rowidx - b._rowidx; });

            if (b_adjust_row)
                this._adjustRowsDisplay(false, true);

            grid._begrowpos = rows[0]._rowidx;
            grid._endrowpos = rows[rows.length - 1]._rowidx;
        }

        return continue_scroll;
    };
    _pGridMatrixManager = null;

    //==============================================================================
    // nexacro._GridBandControl
    //==============================================================================
    nexacro._GridBandControl = function (id, left, top, width, height, right, bottom, parent, refobj)
    {
        nexacro.Component.call(this, id, left, top, width, height, right, bottom, null, null, null, null, parent);

        //--------------internal variable -------------//
        this._isBody = (id == "body");
        this._refinfo = refobj;
        this._grid = parent;
        this._rowsizesperdatarow = null;
        this._datarowsheight = -1;
        this._colinfos = null;
        this._rowinfos = null;
        this._cellsinfo = null;
        this._update_rows = [];
        this._create_rows = [];
        this._text_elem = null;
        this._use_translate_scroll = true;
        this._use_readonly_status = true;

        if (refobj)
        {
            refobj._bandctrl = this;
        }

        this._matrix = new nexacro._GridMatrixManager(this._grid, this);
        this._scrollWidth = 0;
        this._scrollHeight = 0;
        this._recreating = false;
        this.selectborder = "";

        this._p_accessibilityrole = "none";
    };

    var _pGridBand = nexacro._createPrototype(nexacro.Component, nexacro._GridBandControl);
    nexacro._GridBandControl.prototype = _pGridBand;

    _pGridBand._is_subcontrol = true;
    _pGridBand._type_name = "GridBandControl";

    // nexacro._GridBandControl._default_accessibility = nexacro._getCachedStyleObj("accessibility", "none disable all '' '' ''");

    _pGridBand._apply_normalstyleFromInfo = function ()
    {
        var info = this._refinfo;
        var normal_prop = info._property_map;
        var prop, val, datarow = this._grid._currentDSrow;

        for (var i = 0, n = normal_prop.length; i < n; i++)
        {
            if ((normal_prop[i][3] == true) || (normal_prop[i][0].substring(0, 13) == "accessibility"))
            {
                prop = normal_prop[i][0];

                if (normal_prop[i][1] == true)
                    val = info._getAttrValue(info["_p_" + prop], datarow);
                else
                    val = info[prop];

                this["set_" + prop](val);
            }
        }
    };
    /*
        _pGridBand._getElementClassCSSSelector = function ()
        {
    
            var cssarr = nexacro.Component.prototype._getElementClassCSSSelector.call(this);
    
            if (cssarr)
            {
                cssarr.push("dummy");
            }
    
            return cssarr;
        };
     */
    _pGridBand._getClassCSSSelector = function ()
    {
        var cssclassselector = this._p_cssclass || this._cssclass_expr;

        if (cssclassselector)
        {
            if (typeof cssclassselector == "object")
                cssclassselector = cssclassselector.toString();
            return cssclassselector.trim().split(",");  //multi class 
        }
        return "";
    };

    _pGridBand._getElementClassCSSSelector = function ()
    {

        var cssarr = this._getClassCSSSelector();

        if (cssarr)
        {
            cssarr.push("dummy");
        }

        return cssarr;

    };

    //==============================================================================
    // nexacro._GridBandControl : Create & Destroy & Update
    //==============================================================================
    //info create
    _pGridBand.on_create_contents = function ()
    {
        var control_elem = this.getElement();
        var format = this._grid._curFormat;
        if (control_elem && format)
        {
            this._recreate_contents(true);

            if (this._isBody)
            {
                var text_elem = this._text_elem = new nexacro.TextBoxElement(control_elem);
                text_elem.setElementSize(this._getClientWidth(), this._getClientHeight());
                text_elem.setElementVisible(false);
                text_elem.setElementTextAlign("center");
                text_elem.setElementVerticalAlign("middle");

                if (this._get_rows().length == 0)
                {
                    var text = this.parent._p_nodatatext;
                    text_elem.setElementText(text);
                }
            }
        }
    };

    //node create
    _pGridBand.on_created_contents = function (win)
    {
        var control_elem = this.getElement();
        var format = this._grid._curFormat;

        if (control_elem && format)
        {
            var text_elem = this._text_elem;
            if (text_elem) text_elem.create(win);

            var grid = this._grid;

            if (grid._is_created == false && (grid._img_preload_cnt > 0 || grid._p_autosizingtype != "none"))
            {
                // Grid created시 recreate 함.
            }
            else
            {
                this._on_refresh_rows();

                var _hpos = grid._getScrollLeft();
                var _vpos = grid._getScrollTop();

                if (_hpos > 0) 
                {
                    this._matrix._adjustColsDisplay();
                    grid._absolutelyResetScrollPos(true);
                    grid._control_element.setElementHScrollPos(_hpos);
                    grid._absolutelyResetScrollPos(false);
                }

                if (_vpos > 0) 
                {
                    grid._absolutelyResetScrollPos(true);
                    grid._control_element.setElementVScrollPos(_vpos);
                    grid._absolutelyResetScrollPos(false);
                }
            }

            this._on_created_accessibility_contents(win);

            this.on_apply_prop_tooltip();
            this._apply_normalstyleFromInfo();
        }
    };

    _pGridBand._on_apply_status = function (oldstatus, status, olduserstatus, userstatus, apply, status_param, value_param, applycssstatus, applycssuserstatus)
    {
        var grid = this._grid;

        if (status == "mouseover" || status == "focused")
        {
            if (grid._p_mouseovertype == "cell" || grid._p_mouseovertype == "row")
                status = oldstatus;
        }

        nexacro.Component.prototype._on_apply_status.call(this, oldstatus, status, olduserstatus, userstatus, apply, status_param, value_param, applycssstatus, applycssuserstatus);

        if (this._isBody)
        {
            if (this.getElement() && grid._rowcount == 0)
            {
                if (grid._p_nodataimage)
                {
                    var val = "transparent " + grid._p_nodataimage + " center center no-repeat";
                    var background = nexacro.BackgroundObject(val, this);
                    this._control_element.setElementBackground(background);
                }
                else
                {
                    this.on_apply_background(this._background);
                }
            }
            else
            {
                this.on_apply_background(this._background);
            }
        }
    };

    _pGridBand.on_create_contents_command = function ()
    {
        var str = "";
        var control_elem = this.getElement();
        var format = this._grid._curFormat;

        if (control_elem && format)
        {
            var text_elem = this._text_elem;
            if (text_elem) str += text_elem.createCommand();

            if (this._update_rows.length > 0 || this._create_rows.length > 0)
            {
                var update_rows = this._update_rows;
                var create_rows = this._create_rows;

                this._on_refresh_rows_physical(update_rows, create_rows, false, false, false);

                for (var i = 0, n = create_rows.length; i < n; i++)
                {
                    str += create_rows[i].createCommand();
                }
                this._update_rows = [];
            }
        }

        return str;
    };

    _pGridBand.on_attach_contents_handle = function (win)
    {
        var text_elem = this._text_elem;
        if (text_elem) text_elem.attachHandle(win);

        for (var i = 0, n = this._create_rows.length; i < n; i++)
        {
            if (this._create_rows[i]._is_alive)
                this._create_rows[i].attachHandle(win);
        }
        this._create_rows = [];

        this.on_apply_text();
        var grid = this._grid;

        if (this.id == "head")
        {
            grid._applyResizer();
        }

        var _hpos = grid._getScrollLeft();
        var _vpos = grid._getScrollTop();

        if (_hpos > 0)
        {
            this._matrix._adjustColsDisplay();
            grid._absolutelyResetScrollPos(true);
            grid._control_element.setElementHScrollPos(_hpos);
            grid._absolutelyResetScrollPos(false);
        }

        if (_vpos > 0)
        {
            grid._absolutelyResetScrollPos(true);
            grid._control_element.setElementVScrollPos(_vpos);
            grid._absolutelyResetScrollPos(false);
        }

        if (this._env._p_enableaccessibility)
        {
            this._on_attach_accessibility_contents_handle(win);
        }

        this.on_apply_prop_tooltip();
        this._apply_normalstyleFromInfo();
    };

    _pGridBand.on_destroy_contents = function ()
    {
        if (this._text_elem)
        {
            this._text_elem.destroy();
            this._text_elem = null;
        }
        if (this._refinfo)
        {
            this._refinfo._bandctrl = null;
            this._refinfo = null;
        }
        this._rows = null;
        this._grid = null;
        this._matrix.destroy();
        this._matrix = null;

        this._colinfos = null;
        this._rowinfos = null;
        this._cellsinfo = null;
        this._update_rows = null;
        this._create_rows = null;
        this._rowsizesperdatarow = null;
        this._scroll_rect_queue = null;
    };

    _pGridBand._update_rect_useaniframe = false;
    _pGridBand._client_height = -1;

    _pGridBand.on_change_containerRect = function (width, height)
    {
        if (this._recreating)
            return;

        if (this._text_elem)
        {
            var rect = this._grid._getAvailableRect(this);
            this._text_elem.setElementPosition(rect.left, rect.top);
            this._text_elem.setElementSize(rect.width, rect.height);
        }

        var grid = this._grid;

        if (grid._is_contents_recreating)
            return;

        var b_client_change_h = false;

        if (this._client_height < 0 || (grid._p_autofittype != "col" && this._client_height != height))
        {
            this._client_height = height;
            b_client_change_h = true;
        }

        if (grid._is_changingRect)  // 43623
        {
            if (grid._colautofit)
            {
                if (grid._p_autosizingtype == "row" || grid._p_autosizingtype == "both")
                {
                    if (grid._is_body_wordwrap || grid._is_head_wordwrap || grid._is_summ_wordwrap)
                    {
                        grid._resetRowSizeList();
                        grid._resetColSizeList();
                    }
                }
            }
            else if (grid._isLazyAutoVscroll() && (grid._p_autosizingtype == "row" || grid._p_autosizingtype == "both"))
            {
                grid._resetRowSizeList();
                grid._resetColSizeList();
            }

        }

        if (this._is_created || this._update_size_contents)
        {
            if (this._update_rect_useaniframe)
            {
                var pThis = this;

                if (!this._aniframe_clientrect)
                {
                    this._scroll_rect_queue = [];
                    this._aniframe_clientrect = new nexacro.AnimationFrame(this, function () { pThis._callback_update_rect(false, b_client_change_h); });
                }

                var cnt = this._scroll_rect_queue.push(1);

                if (cnt == 1)
                    this._aniframe_clientrect.start();
            }
            else
            {
                this._callback_update_rect(true, b_client_change_h);
            }
        }
    };

    _pGridBand._callback_update_rect = function (no_ani, b_client_change_h)
    {
        if (this._adjust_width == 0 || this._adjust_height == 0)
            return;

        var grid = this._grid;

        if (this._isBody)
        {
            var _vpos = grid._getScrollTop();

            if (_vpos < 0)
                _vpos = 0;

            grid._last_scroll_top = _vpos;
            grid._toprowpos = grid._getScreenTopRowPos(_vpos);
            grid._bottomrowpos = grid._getScreenBottomRowPos(_vpos);

            if (grid._needUpdateExtinner(true) ||
                (grid._isLazyAutoVscroll() && (grid._p_autosizingtype == "row" || grid._p_autosizingtype == "both")))
            {
                grid._recreate_contents_all(false, false, true);
            }
            else
            {
                if (grid._p_autofittype == "col")
                    this._matrix._adjustRowsDisplay(b_client_change_h);
                else
                    this._matrix._adjustRowsDisplay(true);

                this._matrix._adjustColsDisplay();

                this._on_refresh_rows();
                this._update_rows = this._matrix._adjustScrollRows(_vpos, true);
            }
            this._clearScrollDisplayRows();
            grid._updateHighlightrowPos();
        }
        else
        {
            if (grid._p_autofittype == "col")
                this._matrix._adjustRowsDisplay(true);
            else
                this._matrix._adjustRowsDisplay(true);

            this._matrix._adjustColsDisplay();
        }

        this._on_refresh_rows();

        if (!no_ani)
        {
            this._scroll_rect_queue.pop();

            if (this._scroll_rect_queue.length > 0)
                this._aniframe_clientrect.start();
        }
    };

    _pGridBand._clearScrollDisplayRows = function ()
    {
        if (this._isBody && this._rowscroll_info)
            this._rowscroll_info.display_rows = null;
    };

    //==============================================================================
    // nexacro._GridBandControl : Override
    //==============================================================================
    _pGridBand.on_create_control_element = function (parent_elem)
    {
        // create
        var control_elem = new nexacro.GridBandControlElement(parent_elem, this.id);
        control_elem.setLinkedControl(this);
        this._control_element = control_elem;
        return control_elem;
    };

    /* accessibility */
    _pGridBand._apply_setfocus = function (evt_name, self_flag)
    {
        if (self_flag || this._env._p_enableaccessibility)
            nexacro.Component.prototype._apply_setfocus.call(this, evt_name);

        if (this._env._p_enableaccessibility)
        {
            this._grid._currentBand = this.id;

            if (this.id == "head")
            {
                this._grid._currentDSrow = -1;
            }
            else if (this.id == "summary")
            {
                this._grid._currentDSrow = -2;
            }
            else
            {
                this._grid._currentDSrow = 0;
            }
        }
    };

    //==============================================================================
    // nexacro._GridBandControl : Properties
    //==============================================================================
    _pGridBand.on_apply_wordWrap = function ()
    {
        this._refresh_contents();
    };

    _pGridBand.on_apply_prop_tooltip = function ()
    {
        var control_elem = this.getElement();
        this._p_tooltiptext = this._refinfo._getTooltipText();
        this._p_tooltiptype = this._refinfo._p_tooltiptype;

        nexacro.Component.prototype.on_apply_prop_tooltip.call(this);

        if (control_elem)
        {
            var rows = this._get_rows();
            var cells;

            for (var i = 0, n = rows.length; i < n; i++)
            {
                cells = rows[i]._cells;

                for (var j = 0, nn = cells.length; j < nn; j++)
                {
                    cells[j].on_apply_prop_tooltip();
                }
            }
        }
    };

    _pGridBand.on_apply_text = function ()
    {
        if (this._text_elem)
        {
            var text_elem = this._text_elem;
            if (this._isBody)
            {
                if (this._get_rows().length == 0)
                {
                    var text = this.parent._p_nodatatext;
                    text_elem.setElementVisible(text ? true : false);
                    text_elem.setElementText(text);
                    this._grid._text_elem.setElementVisible(false);
                }
                else
                {
                    text_elem.setElementVisible(false);
                }

                this.on_apply_prop_accessibilitylabel();
            }
            else
            {
                text_elem.setElementVisible(false);
            }
        }
    };

    _pGridBand.on_getIDCSSSelector = function ()
    {
        return this.id;
    };

    _pGridBand.on_apply_prop_enable = function (v)
    {
        var control_elem = this.getElement();
        nexacro.Component.prototype.on_apply_prop_enable.call(this, v);

        if (control_elem)
        {
            var rows = this._get_rows();
            var cells;

            for (var i = 0, n = rows.length; i < n; i++)
            {
                rows[i]._setEnable(v);
                cells = rows[i]._cells;

                for (var j = 0, nn = cells.length; j < nn; j++)
                {
                    cells[j]._setEnable(v);
                }
            }
        }
    };

    //==============================================================================
    // nexacro._GridBandControl : Event Handlers
    //==============================================================================    
    _pGridBand.on_fire_onclick = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        var grid = this._grid;
        if (nexacro._isTouchInteraction)
            grid._hideEditor();

        if (grid.onnodataareaclick && grid.onnodataareaclick._has_handlers)
        {
            return grid.on_fire_onnodataareaclick(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, grid, this, meta_key);
        }
        return false;
    };

    _pGridBand.on_fire_ondblclick = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        if (this.parent.onnodataareadblclick && this.parent.onnodataareadblclick._has_handlers)
        {
            return this.parent.on_fire_onnodataareadblclick(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp.parent, from_refer_comp, meta_key);
        }
        return false;
    };

    //==============================================================================
    // nexacro._GridBandControl : Logical Part
    //==============================================================================
    _pGridBand._on_refresh_rows = function (scrolling, no_update_supp, no_after_apply, is_create) // after page create, update
    {
        var grid = this._grid;

        if (grid._p_enableredraw == false)
            return;

        if (this._control_element.handle)
        {
            var update_rows = this._update_rows;
            var create_rows = this._create_rows;

            this._on_refresh_rows_physical(update_rows, create_rows, scrolling, no_update_supp, true);

            this._update_rows = [];
            this._create_rows = [];

            this.on_apply_text();

            if (!no_after_apply)
                grid._applyResizer();

            if (!scrolling)
                grid._adjustOverlayControls(!!is_create);
        }
    };

    _pGridBand._on_refresh_rows_physical = function (update_rows, create_rows, scrolling, no_update_supp, bCreate)
    {
        var update_rows_len = update_rows.length;
        var i, create_rows_len = create_rows.length;

        if (this._isBody)
        {
            var grid = this._grid;
            if (grid._is_created == true)   // grid 생성시점에서 refreshbody call
            {
                var rows = this._get_rows();
                var rows_len = rows.length;

                if (!no_update_supp)
                    grid._suppressUpdate();

                var updated_rows_info = [];

                for (i = 0; i < create_rows_len; i++)
                {
                    var create_row = create_rows[i];

                    if (create_row._is_alive)
                    {
                        create_row._updateAll();
                        updated_rows_info[create_row._rowidx] = true;
                    }
                }

                var onlycontents = false;

                if (rows_len != update_rows_len)
                    onlycontents = (!grid._isUseBindExprStyle("body") && !grid._is_variable_bodyrowsize && !grid._hasVirtualMergeCell() && !grid._groupcount);

                for (i = 0; i < update_rows_len; i++)
                {
                    if (update_rows[i]._is_alive)   // autosize 화면 조절시 delete 되는 경우가 있음.
                    {
                        if (!updated_rows_info[update_rows[i]._rowidx])
                        {
                            update_rows[i]._updateAll(undefined, undefined, onlycontents);

                            if (!onlycontents)
                                updated_rows_info[update_rows[i]._rowidx] = true;
                        }
                    }
                }

                if (grid._is_use_suppress || grid._supphorztype)
                {
                    var cells = grid._curFormat._bodycells;
                    if (cells)
                    {
                        var cells_cnt = cells.length;
                        var rowidx, datarow, rowupdate;

                        for (var j = 0; j < rows_len; j++)
                        {
                            rowidx = rows[j]._rowidx;
                            datarow = (grid._hasTree && grid._treeIndexes) ? grid._treeIndexes[rowidx] : rowidx;
                            rowupdate = false;

                            if (grid._mouseovercell && grid._mouseovercell.row == rowidx)
                                rowupdate = true;

                            var suppcol = [];
                            for (i = 0; i < cells_cnt; i++)
                            {
                                if (rowupdate || cells[i]._p_suppress != 0 || suppcol[cells[i]._col])
                                {
                                    suppcol[cells[i]._col] = true;
                                    this._refreshRowCell(rows, j, i, grid._isSelectedCell(i, datarow));
                                }
                                else if ((grid._supphorztype == 1 || grid._supphorztype == 3) && cells[i]._area == "left")
                                {
                                    this._refreshRowCell(rows, j, i, grid._isSelectedCell(i, datarow));
                                }
                                else if ((grid._supphorztype == 2 || grid._supphorztype == 3) && cells[i]._area == "right") 
                                {
                                    this._refreshRowCell(rows, j, i, grid._isSelectedCell(i, datarow));
                                }
                            }
                        }
                    }

                }
            }
        }
        else
        {
            for (i = 0; i < create_rows_len; i++)
            {
                create_rows[i]._updateAll();
            }

            for (i = 0; i < update_rows_len; i++)
            {
                update_rows[i]._updateAll();
            }
        }

        if (bCreate)
        {
            for (i = 0; i < create_rows_len; i++)
            {
                create_rows[i].on_created();
            }
        }
    };

    _pGridBand._on_last_lbuttonup = function ()
    {
        this.parent._on_last_lbuttonup();
    };

    _pGridBand._on_last_keyup = function ()
    {
        this.parent._on_last_keyup();
    };

    _pGridBand._refreshRowCell = function (rows, displayrow, cellidx, selected, status, onlycontents, for_select)
    {
        var rows;
        if (!rows)
            rows = this._get_rows();

        var cells = rows[displayrow]._cells;
        var cell = cells[cellidx];

        if (!cell)
        {
            return;
        }

        cell.selected = selected;

        var subcells = cell.subcells;
        var subcellsLen = subcells.length;

        for (var i = 0; i < subcellsLen; i++)
        {
            subcells[i].selected = selected;
        }
        cell._updateAll(status, onlycontents, for_select);
    };

    _pGridBand._refreshRow = function (displayrow, status, for_select, removecell)
    {
        var rows = this._get_rows();
        var row = rows[displayrow];
        row._updateAll(status, false, undefined, for_select, null, removecell);
    };

    _pGridBand._refreshCelltype = function (celltype, clearCurstyle)
    {
        var format = this.parent._curFormat;

        function checktype(cells, celltype)
        {
            var cells_len = cells.length;

            for (var i = 0; i < cells_len; i++)
            {
                if (cells[i].celltype == celltype)
                    return true;
            }
            return false;
        }

        if (celltype == "head")
        {
            if (format._bodycells)
            {
                if (checktype(format._bodycells, celltype))
                {
                    this.parent._refreshBody(clearCurstyle);
                }
            }
            if (format._summcells)
            {
                if (checktype(format._summcells, celltype))
                {
                    this.parent._refreshSumm(clearCurstyle);
                }
            }
        }
        else if (celltype == "summary")
        {
            if (format._bodycells)
            {
                if (checktype(format._bodycells, celltype))
                {
                    this.parent._refreshBody(clearCurstyle);
                }
            }
            if (format._headcells)
            {
                if (checktype(format._headcells, celltype))
                {
                    this.parent._refreshHead(clearCurstyle);
                }
            }
        }
        else
        {
            if (format._summcells)
            {
                if (checktype(format._summcells, celltype))
                {
                    this.parent._refreshSumm(clearCurstyle);
                }
            }
            if (format._headcells)
            {
                if (checktype(format._headcells, celltype))
                {
                    this.parent._refreshHead(clearCurstyle);
                }
            }
        }
    };

    _pGridBand._refresh_contents = function (clearCurstyle)
    {/*
        if (clearCurstyle)
        {
            var rows = this._get_rows();
            var rowsLen = rows.length;
            var cells, cellsLen, cell;

            for (var i = 0; i < rowsLen; i++)
            {
                cells = rows[i]._cells;
                f = cells.length;

                for (var j = 0; j < cellsLen; j++)
                {
                    cell = cells[j];
                }
            }
        }
        */
        if (this.id == "head")
        {
            this.parent._refreshHead(clearCurstyle);
            this._refreshCelltype("head", clearCurstyle);
        }
        else if (this.id == "summary")
        {
            this.parent._refreshSumm(clearCurstyle);
            this._refreshCelltype("summary", clearCurstyle);
        }
        else
        {
            this.parent._refreshBody(clearCurstyle);
            this._refreshCelltype("body", clearCurstyle);
        }
    };

    _pGridBand._isEnable = function ()
    {
        if (this._grid)
        {
            return this._grid._isEnable();
        }
        return true;
    };

    _pGridBand._get_cols = function (format)
    {
        var cols = format._cols,
            cols_len = cols.length,
            col,
            left_cols = [],
            right_cols = [],
            body_cols = [];

        for (var i = 0; i < cols_len; i++)
        {
            col = cols[i];
            if (col._area == "left")
            {
                left_cols.push(col.getSize());
            }
            else if (col._area == "right")
            {
                right_cols.push(col.getSize());
            }
            else
            {
                body_cols.push(col.getSize());
            }
        }

        this._colinfos = cols;
        return [body_cols, left_cols, right_cols];
    };

    _pGridBand._recreate_contents = function (init_scroll, scrolling, no_hide_edit, no_update_supp)
    {
        var grid = this._grid,
            format = grid._curFormat,
            rows;

        this._matrix._init();

        if (!format)
            return;

        this._create_rows = [];
        this._update_rows = [];
        this._rowsizesperdatarow = [];
        this._recreating = true;

        if (this.id == "head")
        {
            if (grid._focused_row == -1)
            {
                this._grid._focused_row = undefined;
                this._grid._focused_cell = undefined;
            }
            rows = format._headrows;
            this._datarowsheight = format.headHeight;
        }
        else if (this.id == "summary")
        {
            if (grid._focused_row == -2)
            {
                this._grid._focused_row = undefined;
                this._grid._focused_cell = undefined;
            }
            rows = format._summrows;
            this._datarowsheight = format.summHeight;
        }
        else
        {
            grid._destroyOverlayControls(true);

            if (grid._focused_row >= 0)
            {
                this._grid._focused_row = undefined;
                this._grid._focused_cell = undefined;
            }
            rows = format._bodyrows;
            grid._rowheight = this._datarowsheight = format._body_height;
        }

        var rows_len = rows ? rows.length : 0;

        for (var i = 0; i < rows_len; i++)
        {
            this._rowsizesperdatarow.push(rows[i].size);
        }

        var hpos = (grid._hscrollmng) ? grid._hscrollmng.pos : 0,
            //          vpos = (grid._vscrollmng) ? grid._vscrollmng.pos : 0,
            _vpos = (grid._vscrollmng) ? grid._vscrollmng._pos : 0;
        var controlElement = this._control_element;
        if (controlElement)
        {
            if (this._isBody)
            {
                controlElement._setFixArea(grid._fixed_height);

                if (!scrolling && !no_hide_edit)
                {
                    grid._hideEditor();
                }

                grid._resetScrollMax(); // vlimit를 구해야되서 미리 호출함.
                controlElement._resetExtendContainer(this._scrollHeight);

                var vlimit = Math.ceil(grid._control_element.vscroll_limit);

                if (_vpos < 0)
                    _vpos = 0;
                else if (_vpos > vlimit)
                    _vpos = vlimit;

                grid._toprowpos = grid._getScreenTopRowPos(_vpos);
                grid._bottomrowpos = grid._getScreenBottomRowPos(_vpos);

                this._matrix._adjustRowsDisplay();

                if (!grid._headBand && !grid._summBand)     // head와 summ이 없는 경우에는 위에서 rows가 생성된 후 스크롤을 다시 갱신해야함.
                    grid._setScrollMaxSize(this._scrollWidth, this._scrollHeight, this._band_scroll_tops);

                if (grid._is_created && !grid._autofiting)
                {
                    this._on_refresh_rows(false, no_update_supp, undefined, true);
                    grid._applyAutofittype(true);
                }
            }
            else
            {
                this._scrollWidth = format.bodyWidth;
                this._matrix._adjustRowsDisplay();
                grid._setScrollMaxSize(this._scrollWidth);

                if (grid._is_created && !grid._autofiting)
                {
                    this._on_refresh_rows(false, no_update_supp, undefined, true);
                }
            }
        }

        var lastfocus = grid._find_lastFocused();
        if (lastfocus == grid)
        {
            grid._control_element.setElementFocus();        // 예외처리 : 셀이 재생성 된 이후 DOM의 포커스를 잃어버려 cell의 keydown이 발생 안하는 문제.
        }

        var hlimit = grid._control_element.hscroll_limit;

        if (hpos < 0)
        {
            hpos = 0;
        }
        else if (hpos > hlimit)
        {
            hpos = hlimit;
        }

        if (this._isBody)
        {
            if (hpos > 0)
            {
                if (init_scroll)
                {
                    grid._hscrollmng.setPos(0);
                    grid._control_element.setElementHScrollPos(0);
                }
                else
                {
                    if (grid._control_element._target_hscroll_elements)
                    {
                        this._matrix._adjustColsDisplay();
                        grid._absolutelyResetScrollPos(true);
                        grid._control_element.setElementHScrollPos(hpos);
                        grid._absolutelyResetScrollPos(false);
                    }
                }
            }
            if (_vpos > 0)
            {
                if (init_scroll)
                {
                    grid._vscrollmng.setPos(0);
                    this._control_element.setElementVScrollPos(0);
                    this._is_over_scroll = 0;
                }
                else
                {
                    grid._absolutelyResetScrollPos(true);
                    grid._control_element.setElementVScrollPos(_vpos);
                    grid._absolutelyResetScrollPos(false);
                }
            }
        }
        else
        {
            if (hpos > 0)
            {
                if (init_scroll)
                {
                    grid._hscrollmng.setPos(0);
                    grid._control_element.setElementHScrollPos(0);
                }
                else
                {
                    this._matrix._adjustColsDisplay();
                    grid._absolutelyResetScrollPos(true);
                    grid._control_element.setElementHScrollPos(hpos);
                    grid._absolutelyResetScrollPos(false);

                }
            }
        }
        this._recreating = false;
    };

    _pGridBand._get_rows = function ()
    {
        return this._matrix._getAllRows();
    };

    _pGridBand._get_row = function (dataRowIdx)
    {
        var rows = this._get_rows();
        var rows_len = (rows) ? rows.length : 0;
        var grid = this._grid;
        var datarow;

        for (var i = 0; i < rows_len; i++)
        {
            datarow = grid._getDataRow(rows[i]._rowidx);

            if (dataRowIdx == datarow)
            {
                return rows[i];
            }
        }
        return null;
    };

    _pGridBand._updateAll = function (clearCurstyle)
    {
        if (this.getElement())
        {
            this._apply_status(this._oldstatus, this._status, this._olduserstatus, this._userstatus);
        }
    };

    _pGridBand = null;

    //==============================================================================
    // nexacro.GridScrollManager
    //==============================================================================
    nexacro._GridHScrollManager = function (grid)
    {
        // col
        this.max = 0;
        this.min = 0;
        this.pos = 0;
        this.line = 0;
        this.page = 0;
        this.view = 0;

        // pixel
        this._pos = 0;
        this._min = 0;
        this._max = 0;
        this._orgmax = 0;
        this._grid = grid;
    };

    var _pGridHScrollManager = nexacro._GridHScrollManager.prototype = nexacro._createPrototype(nexacro.Object, nexacro._GridHScrollManager);

    _pGridHScrollManager.setPos = function (v, evt_kind, evtsync)
    {
        if (v < this.min) v = this.min;
        if (v > this.max) v = this.max;

        if (this.pos != v)
        {
            this.pos = v;
            this._pos = this._scroll_convert_pixel(v);
        }
        if (!evtsync)
            this._grid._scrollTo(this._pos, this._grid._vscroll_pos, undefined, true, undefined, evt_kind);
    };

    _pGridHScrollManager.destroy = function ()
    {
        this._grid = null;
    };

    _pGridHScrollManager._scroll_convert_pixel = function (v)
    {
        return v;
    };

    _pGridHScrollManager._scroll_reverse_convert = function (v)
    {
        // [0] 계산된 값, [1] 보정된 pixel값
        return [v, v];
    };

    _pGridHScrollManager._setInfo = function (left, top, width, height, si_min, si_max, si_line, si_page, si_view, si_pos)
    { // pixel input

        var posarr = this._scroll_reverse_convert(si_min);
        this.min = posarr[0];
        this._min = posarr[1];

        posarr = this._scroll_reverse_convert(si_max, false, true);
        this.max = posarr[0];
        this._max = posarr[1];
        this._orgmax = si_max;  // scroll_limit

        this.line = si_line;
        this.page = si_page;
        this.view = si_view;

        posarr = this._scroll_reverse_convert(si_pos);
        this.pos = posarr[0];
        this._pos = posarr[1];

        // check pos
        if (this._pos < this._min)
        {
            this.pos = this.min;
            this._pos = this._min;
        }
        if (this._pos > this._max)
        {
            this.pos = this.max;
            this._pos = this._max;
        }
    };

    _pGridHScrollManager = null;

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    nexacro._GridVScrollManager = function (grid)
    {
        // row
        this.max = 0;
        this.min = 0;
        this.pos = 0;
        this.line = 0;
        this.page = 0;
        this.view = 0;

        // pixel
        this._pos = 0;
        this._min = 0;
        this._max = 0;
        this._orgmax = 0;
        this._grid = grid;
    };

    var _pGridVScrollManager = nexacro._GridVScrollManager.prototype = nexacro._createPrototype(nexacro.Object, nexacro._GridVScrollManager);

    _pGridVScrollManager.setPos = function (v, evt_kind)
    {
        if (v < this.min) v = this.min;
        if (v > this.max) v = this.max;

        if (this.pos != v)
        {
            this.pos = v;
            if (evt_kind === "mousewheel_v")
            {
                // wheelscroll 은 scrollpixel 상관없이 변환 하여 저장
                this._pos = this._scroll_convert_pixel(v, true);
            }
            else
            {
                this._pos = this._scroll_convert_pixel(v);
            }
        }
        this._grid._scrollTo(this._grid._hscroll_pos, this._pos, undefined, true, undefined, evt_kind);
    };

    _pGridVScrollManager.setPixelPos = function (v, evt_kind, adjustrow, evtsync)
    {
        if (v < this._min) v = this._min;
        if (v > this._max) v = this._max;

        this._no_set_scrollinfo = true;
        if (this._pos != v)
        {
            if (adjustrow)
            {
                var posarr = this._scroll_reverse_convert(v);
                this.pos = posarr[0];
                this._pos = posarr[1];
            }
            else
            {
                this.pos = this._scroll_reverse_convert(v)[0];
                this._pos = v;
            }
        }

        if (!evtsync)
        {
            this._grid._scrollTo(this._grid._hscroll_pos, this._pos, undefined, true, undefined, evt_kind);
        }
        else
        {
            var vscrollbar = this._grid.vscrollbar;
            if (vscrollbar && vscrollbar._is_lineupdown && vscrollbar._pos != this._pos)
            {
                vscrollbar.pos = vscrollbar._pos = this._pos;
            }
        }
    };

    _pGridVScrollManager.setRowPos = function (v, evt_kind)
    {
        var grid = this._grid;
        v -= grid._getFixRowCnt();

        if (evt_kind === "mousewheel_v")
        {
            v = grid._pageRowToRow(v);
            this.setPos(v, evt_kind);
        }
        else
        {
            if (grid._scrollpixel == "all")
            {
                // pixel로 들어오는 케이스가 있어 보임 이건 리팩토링 필요
                v = this._scroll_convert_pixel(v, true);
            }
            v = grid._pageRowToRow(v);
            this.setPos(v, evt_kind);
        }
    };

    _pGridVScrollManager._setInfo = function (left, top, width, height, si_min, si_max, si_line, si_page, si_view, si_pos)
    { // pixel input

        var posarr = this._scroll_reverse_convert(si_min);
        this.min = posarr[0];
        this._min = posarr[1];

        posarr = this._scroll_reverse_convert(si_max, false, true);
        this.max = posarr[0];
        this._max = posarr[1];
        this._orgmax = si_max;

        this.line = si_line;
        this.page = si_page;
        this.view = si_view;

        posarr = this._scroll_reverse_convert(si_pos);
        this.pos = posarr[0];
        this._pos = posarr[1];

        // check pos
        if (this._pos < this._min)
        {
            this.pos = this.min;
            this._pos = this._min;
        }
        if (this._pos > this._max)
        {
            this.pos = this.max;
            this._pos = this._max;
            this._grid._scrollTo(this._grid._hscroll_pos, this.l_pos, undefined, true, undefined, "");
        }
    };

    _pGridVScrollManager._scroll_convert_pixel = function (v, is_notcheck)    // row -> Pixel
    {
        var grid = this._grid;
        var bodyband = grid._bodyBand;

        if (grid._scrollpixel != "all" || is_notcheck)
        {
            if (bodyband)
            {
                var srowidx = grid._getFixRowCnt() + grid._rowToPageRow(0);
                var rowidx = v + srowidx;

                if (grid._is_variable_bodyrowsize)
                {
                    var height = 0, row;

                    for (var i = srowidx; i < rowidx; i++)
                    {
                        row = grid._getDataRow(i);
                        height += grid._rowSizeList[row];
                    }
                    v = height;
                }
                else
                {
                    v = (rowidx - srowidx) * bodyband._datarowsheight;
                }
            }
        }

        return v;
    };

    _pGridVScrollManager._scroll_reverse_convert = function (v, is_notcheck, is_max)  // Pixel -> row
    {
        var grid = this._grid;
        var bodyband = grid._bodyBand;
        var renew = v;
        var height, row, i;

        if (grid._scrollpixel != "all" || is_notcheck)
        {
            if (bodyband)
            {
                if (grid._is_variable_bodyrowsize)
                {
                    var srowidx = grid._getFixRowCnt() + grid._rowToPageRow(0);
                    var erowidx = grid._rowToPageRow(grid._getGridRowCount() - 1);
                    var rowcnt = grid._getGridRowCount();
                    height = 0;
                    row = 0;

                    if (is_max)
                    {
                        for (i = srowidx; i <= erowidx; i++)
                        {
                            row = grid._getDataRow(i);

                            if (v <= height)
                            {
                                row = i;
                                renew = height;
                                break;
                            }
                            height += grid._rowSizeList[row];
                        }
                    }
                    else
                    {
                        for (i = srowidx; i <= erowidx; i++)
                        {
                            row = grid._getDataRow(i);

                            if (v < height)
                            {
                                row = i - 1;

                                if (grid._rowSizeList[row] > bodyband._getClientHeight())
                                {
                                    if (height - v < bodyband._getClientHeight())   // row가 band보다 클 때..
                                    {
                                        if (v < this._orgmax)
                                            renew = height - bodyband._getClientHeight();
                                    }
                                }
                                else
                                {
                                    if (v < this._orgmax)
                                        renew = height - grid._rowSizeList[row];
                                }
                                break;
                            }
                            height += grid._rowSizeList[row];
                        }
                    }
                    v = row;
                    v -= srowidx;
                }
                else
                {
                    row = 0;

                    if (is_max)
                    {
                        if (v > 0)
                            row = Math.ceil(v / bodyband._datarowsheight);

                        renew = row * bodyband._datarowsheight;
                    }
                    else
                    {
                        if (v == this._orgmax)
                            row = Math.ceil(v / bodyband._datarowsheight);
                        else if (v > 0)
                            row = Math.floor(v / bodyband._datarowsheight);

                        height = bodyband._datarowsheight * (row + 1);
                        if (bodyband._datarowsheight > bodyband._getClientHeight())
                        {
                            if (height - v < bodyband._getClientHeight())
                                renew = height - bodyband._getClientHeight();
                        }
                        else
                        {
                            renew = row * bodyband._datarowsheight;
                        }
                    }
                    v = row;
                }
            }
        }

        return [v, renew];
    };

    _pGridVScrollManager._checkoverscroll = function (si_pos)
    {
        var grid = this._grid;

        if (grid._scrollpixel != "all")
        {
            grid._is_over_scroll = 0;

            if (this._pos > this._orgmax)
                grid._is_over_scroll = this._pos - this._orgmax;
        }
    };

    _pGridVScrollManager.destroy = function ()
    {
        this._grid = null;
    };

    _pGridVScrollManager = null;

    //==============================================================================
    // nexacro.Grid
    //==============================================================================
    nexacro.Grid = function (id, left, top, width, height, right, bottom, minwidth, maxwidth, minheight, maxheight, parent)
    {
        nexacro.Component.call(this, id, left, top, width, height, right, bottom, minwidth, maxwidth, minheight, maxheight, parent);

        /* event list */
        this._event_list = {
            "onclick": 1, "ondblclick": 1, "onkillfocus": 1, "onsetfocus": 1,
            "onkeypress": 1, "onkeydown": 1, "onkeyup": 1,
            "onlbuttondown": 1, "onlbuttonup": 1, "onrbuttondown": 1, "onrbuttonup": 1, "onmousedown": 1, "onmouseup": 1,
            "onmouseenter": 1, "onmouseleave": 1, "onmousemove": 1, "onmousewheel": 1,
            "ondrag": 1, "ondragenter": 1, "ondragleave": 1, "ondragmove": 1, "ondrop": 1,
            "onmove": 1, "onsize": 1, "ongesture": 1,
            "onvscrolllastover": 1, "onvscroll": 1, "onhscroll": 1, "onvtracklast": 1, "oncellclick": 1, "onheadclick": 1, "onsummaryclick": 1,
            "oncelldblclick": 1, "onheaddblclick": 1, "onsummarydblclick": 1, "onnodataareaclick": 1, "onnodataareadblclick": 1, "onselectchanged": 1, "oncellposchanged": 1,
            "onenteredit": 1, "onenterdown": 1, "cantreestatuschange": 1, "ontreestatuschanged": 1, "onsubselectchanged": 1,
            "oncolresizing": 1, "onrowresizing": 1, "ondropdown": 1, "oncloseup": 1, "onitemchanged": 1, "onexpanddown": 1, "oninput": 1, "oncellimeaction": 1, /*"oncellcustomcontrolevent": 1,*/
            "onexpandup": 1, "oncolresized": 1, "onrowresized": 1,
            "oncontextmenu": 1,
            "ontouchstart": 1, "ontouchmove": 1, "ontouchend": 1, "ondevicebuttonup": 1,
            "onheadvaluechanged": 1, "onimageerror": 1, "onhtmlcontrolapplyvalue": 1
        };

        this._hscrollmng = new nexacro._GridHScrollManager(this);
        this._vscrollmng = new nexacro._GridVScrollManager(this);

        /* internal variable */
        this._use_readonly_status = true;
        this._use_translate_scroll = false;
        this._is_scrollable = true;
        this._is_locale_control = true;
        this._formats = {};
        this._curFormat = null;
        this._headBand = null;
        this._summBand = null;
        this._bodyBand = null;
        this._groupBar = null;

        // dynamic caches
        this._exprcache = {};

        this._selectstartrow = [];
        this._selectstartcol = [];
        this._selectstartsubrow = [];
        this._selectstartpvt = [];
        this._selectendrow = [];
        this._selectendcol = [];
        this._selectendsubrow = [];
        this._selectendpvt = [];
        this._resizerCols = [];
        this._resizerRows = [];
        this._imgsize_cache = {};
        this._rowSizeListSub = [];	 // subrow 별로
        this._rowSizeList = [];		 // subrow를  합한 row
        this._rowHeadListSub = [];
        this._rowHeadList = [];
        this._rowSummListSub = [];
        this._lazy_load_rowsize = [];
        this._rowSummList = [];
        this._begrowpos = 0;         // band의 물리적 rows의 시작 rowidx
        this._endrowpos = 0;         // band의 물리적 rows의 마지막 rowidx]
        this._toprowpos = [0, 0];    // index 0 : rowpos, 1 : scrollpixel시 넘어간 영역
        this._bottomrowpos = -1;      // suppress에서만 사용
        this._isflingend = undefined;   // fling 동작시 fling 중인지 판단하기 위한 내부 변수.

        this._selectinfo = {
            rows: [],
            selects: [],
            ctrlpoint: {
                "cell": -1, "col": -1, "subrow": -1, "row": -9, "colspan": -1, "rowspan": -1,
                "_init": function ()
                {
                    this.cell = -1;
                    this.col = -1;
                    this.subrow = -1;
                    this.row = -9;
                    this.colspan = -1;
                    this.rowspan = -1;
                    this.subrowslen = 0;
                    this.area = "";
                },
                "_set": function (cellinfo, row, subrowslen)
                {
                    this.cell = cellinfo._cellidx;
                    this.col = cellinfo._col;
                    this.subrow = cellinfo._row;
                    this.row = row;
                    this.colspan = cellinfo._colspan;
                    this.rowspan = cellinfo._rowspan;
                    this.subrowslen = subrowslen;
                    this.area = cellinfo._area;
                }
            },
            area: [],
            "curcell": -1, "curcol": -1, "curpvt": -9, "cursubrow": -1, "curdsrow": -1, "currow": -9,
            "getSelectCells": function (row)
            {
                return this.selects[row + 2];
            },
            arearect: { left: 0, top: 0, width: 0, height: 0, barea: "", earea: "" }
        };

        this._text_elem = null;
        this._is_use_suppress = false;
        this._is_head_wordwrap = false;
        this._is_body_wordwrap = false;
        this._is_summ_wordwrap = false;
        this._recreate_contents_proc = [];
        this._keydown_elem = null;
        this._tree_load_all = null;
        this._image_load_all = null;
        this._is_editor_keyaction = true; // use for editor key action
        this._focus_proc = null;
        this._after_recreate_contents_all = null;
        this._after_recreate = false;
        this._is_async_recreate = false; // use async recreate
        this._is_after_recreate = false;

        /* user change size flag */
        this._is_user_change_head_rowsize = false;
        this._is_user_change_body_rowsize = false;
        this._is_user_change_summ_rowsize = false;
        this._is_user_change_colsize = false;

        /* variable for accessibility */
        this.accessibilityrole = "grid";
        this._accept_arrow = false;     // move to comp for accessibility
        this._accept_focus = false;     // grid focus skip flag for accessibility
        this._is_first_focus = false;      // first focus flag for accessibility
        this._is_first_bodycell = false;// bodycell first focus flag
        this._is_band_focus = false;    // band focus flag
        this._beforegridrowpos = -1;    // befor row check
        this._beforegridcolpos = -1;    // befor col check
        this.accessibilityreadbandlabel = true;
        /* variable for accessibility */

        this._aniframe_rowscroll = null;
        this._aniframe_rowscroll_float = null;
        this._aniframe_colscroll = null;
        this._aniframe_rowscroll_end = null;
        this._aniframe_colscroll_end = null;
        this._aniframe_clientrect = null;

        this._use_bind_expr_cells = { body: null, head: null, summ: null };
        this._is_use_bind_expr_style = { body: null, head: null, summ: null };
        this._expr_allrow_update_prop = false;
        this._expr_allrow_update_style = false;


        this._is_data_enter_apply = false;
        this._select_ctrl = null;
        this._format_str = null;
        this._track_point = { x: -1, y: -1 };
        this._track_idx = -1;
        this._track_start_info = null;
        this._track_mode = "";      //"areaselect"
        this._overlay_controls = [];
        this._selections = [];
        this._func_queue = [];
        this._recalcXY_info = null;
        this._virtual_mergecell_arr = [];
        this._enable_redraw_history = {};
        this._autofitcol_rate = [];
        this._org_treeStates = [];

        this._scroll_vpos_queue = [];
        this._style_tempband = {};
        this._blinktask = null;
        this._tempmergeeditor = null;
    };

    var _pGrid = nexacro._createPrototype(nexacro.Component, nexacro.Grid);
    nexacro.Grid.prototype = _pGrid;

    // overide nexacro.Object
    _pGrid._type_name = "Grid";

    // Child Components member
    _pGrid._rowheight = 24;

    _pGrid._rowcount = 0;
    _pGrid._rowposition = -1;

    _pGrid._beforeheadcellpos = -1;
    _pGrid._beforeheadrowpos = -1;
    _pGrid._beforeheadcolpos = -1;
    _pGrid._beforeheadsubrowpos = -1;

    _pGrid._beforebodycellpos = -1;
    _pGrid._beforebodyrowpos = -1;
    _pGrid._beforebodycolpos = -1;
    _pGrid._beforebodysubrowpos = -1;
    _pGrid._beforepvt = -9;

    _pGrid._beforesummcellpos = -1;
    _pGrid._beforesummrowpos = -1;
    _pGrid._beforesummcolpos = -1;
    _pGrid._beforesummsubrowpos = -1;

    _pGrid._multiselect = "none";

    _pGrid._bodyrowheight = 0;
    _pGrid._mouseRowPos = -9;
    _pGrid._mouseovercell = null;
    _pGrid._mouseCellPos = -1;
    _pGrid._dsEventOccured = false;
    _pGrid._bPivotGrid = false;

    _pGrid._tryShowEditorCell = false;
    _pGrid._showEditRowIdx = -1;
    _pGrid._showEditCellIdx = -1;

    _pGrid._dbclickPreCell = -1;
    _pGrid._dbclickPreCol = -1;
    _pGrid._dbclickPreRow = -9;
    _pGrid._dbclickPreSubrow = -1;
    _pGrid._dbclickPrePvt = -9;
    _pGrid._lbuttondown_proc = false;

    _pGrid._bDragArea = false;
    _pGrid._nDragRow = -1;
    _pGrid._nDragCell = -1;
    _pGrid._nDragPivot = -9;
    _pGrid._nDragEndRow = -1;
    _pGrid._nDragEndCell = -1;
    _pGrid._nDragEndCol = -9;
    _pGrid._nDragBand = -1;
    _pGrid._bShiftClick = false;

    _pGrid._selectClear = false;
    _pGrid._acceptstab = true;

    _pGrid._copyseparator = "\t";

    //read only property
    _pGrid._p_body = null;
    _pGrid._p_head = null;
    _pGrid._p_summ = null;
    _pGrid._p_summary = null;

    _pGrid._p_currentcell = -1;
    _pGrid._p_currentcol = -1;
    _pGrid._p_currentpivot = -9;
    _pGrid._p_currentsubrow = -1;
    _pGrid._p_currentrow = -9;

    _pGrid._currentDSrow = -1;
    _pGrid._currentBand = "body";

    _pGrid._p_selectstartrow = -9;
    _pGrid._p_selectstartcol = -1;
    _pGrid._p_selectstartsubrow = -1;
    _pGrid._p_selectstartpivot = -9;
    _pGrid._p_selectendrow = -9;
    _pGrid._p_selectendcol = -1;
    _pGrid._p_selectendsubrow = -1;
    _pGrid._p_selectendpivot = -9;

    _pGrid._p_pagerowcount = 0;
    _pGrid._pagerowcnt = 0;   // 잘리는 셀도 포함.

    _pGrid._p_rowcount = 0;
    _pGrid._p_pivotcount = 0;

    _pGrid._disprowcnt = 0;

    //normal property
    _pGrid._p_fillareatype = "none";
    _pGrid._resetfillarea = false;
    _pGrid._p_scrollpixel = "default";
    _pGrid._scrollpixel = (nexacro._isTouchInteraction) ? "all" : "none";
    _pGrid._selectscrollmode = (nexacro._isTouchInteraction) ? "scroll" : "select";
    _pGrid._p_dragscrolltype = "both";
    _pGrid._p_hideendline = "none";
    _pGrid._p_userdata = "";
    _pGrid._p_nodataimage = "";
    _pGrid._p_nodatatext = "";
    _pGrid._p_summarytype = "default";
    _pGrid._p_suppresslevel = "sameskip";
    _pGrid._p_useselcolor = true;
    _pGrid._p_showselection = false;

    _pGrid._p_autoupdatetype = "none";
    _pGrid._p_cellclickbound = "control";
    _pGrid._p_cellmovingtype = "none";
    _pGrid._p_cellsizebandtype = "body";
    _pGrid._p_cellsizingtype = "none";
    _pGrid._p_extendsizetype = "none";
    _pGrid._p_readonly = false;
    _pGrid._p_selectbandtype = "default";
    _pGrid._p_selectchangetype = "down";
    _pGrid._p_selecttype = "row";
    _pGrid._p_wheelscrollrow = 2;
    _pGrid._p_usecontrolkey = true;
    _pGrid._p_treeusebutton = "use";
    _pGrid._p_treeuseline = true;
    _pGrid._p_treeusecheckbox = true;
    _pGrid._p_treeuseimage = true;
    _pGrid._p_treeuseexpandkey = false;
    _pGrid._p_treeasynctoggle = false;
    _pGrid._p_treeinitstatus = "collapse,null";
    _pGrid._p_groupinitstatus = "expand";
    _pGrid._p_treepathdelimiter = ".";
    _pGrid._p_useinputpanel = false;

    _pGrid._initsoftkeyboard = undefined;
    _pGrid._p_usesoftkeyboard = true;

    _pGrid._p_suppresshorzcell = "none";

    _pGrid._enable = true;
    _pGrid._changeDisplayer = false;
    _pGrid._autoSizeRowProc = false;
    _pGrid._iskey_movetocell = false;

    /* Data Bind control */
    _pGrid._p_binddataset = "";
    _pGrid._binddataset = null;

    _pGrid._userRowposChange = false;
    _pGrid._create_selection = null;

    _pGrid._p_formatid = "";
    _pGrid._p_formats = "";
    _pGrid._p_locale = "";
    _pGrid._p_areaselecttype = "limitband";
    _pGrid._p_autoenter = "none";
    _pGrid._p_autofitbandtype = "body";
    _pGrid._p_autofitminheight = 100;
    _pGrid._p_autofitminwidth = 100;
    _pGrid._p_autofittype = "none";
    _pGrid._p_autosizingtype = "none";
    _pGrid._p_autosizebandtype = "body";
    _pGrid._p_selectscrollmode = "default";
    _pGrid._p_createrowstype = "auto";
    _pGrid._p_showgroupbar = false;
    _pGrid._p_groupbarminheight = 24;

    _pGrid._colautofit = false;
    _pGrid._rowautofit = false;
    _pGrid._autofiting = false;
    _pGrid._bodyAutoSize = true;
    _pGrid._headAutoSize = false;
    _pGrid._summAutoSize = false;
    _pGrid._AutoSizeLcol = false;
    _pGrid._AutoSizeRcol = false;
    _pGrid._rowSizeEx = false;
    _pGrid._noInternalvscroll = false;
    _pGrid._is_variable_bodyrowsize = false;
    _pGrid._bGridCtrlLdown = false;
    _pGrid._locale = "";
    _pGrid._firstEditableCell = null;

    /* fixed row */
    _pGrid._fixed_startrow = -9;
    _pGrid._fixed_endrow = -9;
    _pGrid._fixed_height = 0;
    _pGrid._fixedrow_height = 0;
    _pGrid._fixed_rowcnt = 0;
    _pGrid._fixed_row_scrolling = false;

    _pGrid._p_createcellasync = false;

    _pGrid._p_cellcombobuttonsize = undefined;
    _pGrid._p_cellmulticombobuttonsize = undefined;
    _pGrid._p_cellcalendarbuttonsize = undefined;
    _pGrid._p_cellcomboscrollbarsize = undefined;
    _pGrid._p_cellmulticomboscrollbarsize = undefined;
    _pGrid._p_celltextareascrollbarsize = undefined;
    _pGrid._p_cellcalendarpopuptype = undefined;
    _pGrid._p_cellcombopopuptype = undefined;
    _pGrid._p_cellmulticombopopuptype = undefined;
    _pGrid._p_cellcheckboxsize = undefined;
    _pGrid._p_cellradioitemsize = undefined;
    _pGrid._p_cellcalendarpopupsize = undefined;
    _pGrid._p_cellcombopopupsize = undefined;
    _pGrid._p_cellmulticombopopupsize = undefined;

    _pGrid._p_mouseovertype = "default";
    _pGrid._p_fastvscrolltype = "alldisplay";
    _pGrid._p_cellexprupdatecondition = "all";
    _pGrid._p_scrolldisplaymode = "normal";
    _pGrid._p_pagesize = 0;
    _pGrid._p_pagecount = 1;
    _pGrid._p_page = 1;

    _pGrid._p_groupbardisplayrowcount = undefined;
    _pGrid._p_groupbarbuttonsize = undefined;
    _pGrid._p_groupbaritemheight = undefined;
    _pGrid._p_groupbarpopuptype = "normal";
    _pGrid._p_groupbarpopupsize = undefined;
    _pGrid._p_groupbartagboxitemhorizontalgap = undefined;
    _pGrid._p_groupbartagboxitemverticalgap = undefined;
    _pGrid._p_groupbartagboxscrollbartype = "default";
    _pGrid._p_groupbartagboxscrollbarsize = null;
    _pGrid._p_groupbartagboxscrollindicatorsize = null;
    _pGrid._p_groupbartagbuttonsize = undefined;
    _pGrid._p_groupbarscrollbarsize = undefined;
    _pGrid._p_groupbarscrollindicatorsize = undefined;
    _pGrid._p_groupbarscrollbarbarminsize = undefined;
    _pGrid._p_groupbarscrollbarbaroutsize = undefined;
    _pGrid._p_groupbarscrollbardecbuttonsize = undefined;
    _pGrid._p_groupbarscrollbarincbuttonsize = undefined;
    _pGrid._p_groupbarscrollbartrackbarsize = undefined;

    _pGrid._p_allowcopy = false;
    _pGrid._p_copyseparator = "tab";

    _pGrid._properties = [
        { name: "body", readonly: true },
        { name: "head", readonly: true },
        { name: "summ", readonly: true },
        { name: "summary", readonly: true },
        { name: "currentcell", readonly: true },
        { name: "currentcol", readonly: true },
        { name: "currentpivot", readonly: true },
        { name: "currentsubrow", readonly: true },
        { name: "currentrow", readonly: true },
        { name: "selectstartrow", readonly: true },
        { name: "selectstartcol", readonly: true },
        { name: "selectstartsubrow", readonly: true },
        { name: "selectstartpivot", readonly: true },
        { name: "selectendrow", readonly: true },
        { name: "selectendcol", readonly: true },
        { name: "selectendsubrow", readonly: true },
        { name: "selectendpivot", readonly: true },
        { name: "pagerowcount", readonly: true },
        { name: "rowcount", readonly: true },
        { name: "pivotcount", readonly: true },
        { name: "fillareatype" },
        { name: "scrollpixel" },
        { name: "hideendline" },
        { name: "userdata" },
        { name: "nodataimage" },
        { name: "nodatatext" },
        { name: "summarytype" },
        { name: "suppresslevel" },
        { name: "useselcolor" },
        { name: "showselection" },
        { name: "autoupdatetype" },
        { name: "cellclickbound" },
        { name: "cellmovingtype" },
        { name: "cellsizebandtype" },
        { name: "cellsizingtype" },
        { name: "extendsizetype" },
        { name: "readonly" },
        { name: "selectbandtype" },
        { name: "selectchangetype" },
        { name: "selecttype" },
        { name: "wheelscrollrow" },
        { name: "usecontrolkey" },
        { name: "treeusebutton" },
        { name: "treeuseline" },
        { name: "treeusecheckbox" },
        { name: "treeuseimage" },
        { name: "treeuseexpandkey" },
        { name: "treeasynctoggle" },
        { name: "treeinitstatus" },
        { name: "groupinitstatus" },
        { name: "treepathdelimiter" },
        { name: "useinputpanel" },
        { name: "usesoftkeyboard" },
        { name: "suppresshorzcell" },
        { name: "binddataset" },
        { name: "formatid" },
        { name: "formats" },
        { name: "locale" },
        { name: "areaselecttype" },
        { name: "autoenter" },
        { name: "autofitbandtype" },
        { name: "autofitminheight" },
        { name: "autofitminwidth" },
        { name: "autofittype" },
        { name: "autosizingtype" },
        { name: "autosizebandtype" },
        { name: "selectscrollmode" },
        { name: "createrowstype" },
        { name: "createcellasync" },
        { name: "cellcombobuttonsize" },
        { name: "cellmulticombobuttonsize" },
        { name: "cellcalendarbuttonsize" },
        { name: "cellcomboscrollbarsize" },
        { name: "cellmulticomboscrollbarsize" },
        { name: "celltextareascrollbarsize" },
        { name: "cellcalendarpopuptype" },
        { name: "cellcombopopuptype" },
        { name: "cellmulticombopopuptype" },
        { name: "cellcheckboxsize" },
        { name: "cellradioitemsize" },
        { name: "cellcalendarpopupsize" },
        { name: "cellcombopopupsize" },
        { name: "cellmulticombopopupsize" },
        { name: "mouseovertype" },
        { name: "fastvscrolltype" },
        { name: "cellexprupdatecondition" },
        { name: "scrolldisplaymode" },
        { name: "pagesize" },
        { name: "pagecount", readonly: true },
        { name: "page" },
        { name: "showgroupbar" },
        { name: "groupbarminheight" },
        { name: "groupbardisplayrowcount" },
        { name: "groupbarbuttonsize" },
        { name: "groupbaritemheight" },
        { name: "groupbarpopuptype" },
        { name: "groupbarpopupsize" },
        { name: "groupbartagboxitemhorizontalgap" },
        { name: "groupbartagboxitemverticalgap" },
        { name: "groupbartagboxscrollbartype" },
        { name: "groupbartagboxscrollbarsize" },
        { name: "groupbartagboxscrollindicatorsize" },
        { name: "groupbartagbuttonsize" },
        { name: "groupbarscrollbarsize" },
        { name: "groupbarscrollindicatorsize" },
        { name: "groupbarscrollbarbarminsize" },
        { name: "groupbarscrollbarbaroutsize" },
        { name: "groupbarscrollbardecbuttonsize" },
        { name: "groupbarscrollbarincbuttonsize" },
        { name: "groupbarscrollbartrackbarsize" },
        { name: "allowcopy" },
        { name: "copyseparator" },
    ];

    _pGrid._control_passprop = {    // control에 값을 전달만하는 properties
        "_groupBar": [  // member control instance
            ["groupbardisplayrowcount", "displayrowcount"], // grid prop, control prop
            ["groupbarbuttonsize", "buttonsize"],
            ["groupbaritemheight", "itemheight"],
            ["groupbarpopuptype", "popuptype"],
            ["groupbarpopupsize", "popupsize"],
            ["groupbartagboxitemhorizontalgap", "tagboxitemhorizontalgap"],
            ["groupbartagboxitemverticalgap", "tagboxitemverticalgap"],
            ["groupbartagboxscrollbartype", "tagboxscrollbartype"],
            ["groupbartagboxscrollbarsize", "tagboxscrollbarsize"],
            ["groupbartagboxscrollindicatorsize", "tagboxscrollindicatorsize"],
            ["groupbartagbuttonsize", "tagbuttonsize"],
            ["groupbarscrollbarsize", "scrollbarsize"],
            ["groupbarscrollindicatorsize", "scrollindicatorsize"],
            ["groupbarscrollbarbarminsize", "scrollbarbarminsize"],
            ["groupbarscrollbarbaroutsize", "scrollbarbaroutsize"],
            ["groupbarscrollbardecbuttonsize", "scrollbardecbuttonsize"],
            ["groupbarscrollbarincbuttonsize", "scrollbarincbuttonsize"],
            ["groupbarscrollbartrackbarsize", "scrollbartrackbarsize"]
        ]
    };

    nexacro._makeGridPropertySetter = function (ptype_val, control, control_passprop)
    {
        var _property_map = control_passprop[control];
        var prop, conp, eval_str = "", str;

        for (var i = 0; i < _property_map.length; i++)
        {
            prop = _property_map[i][0];
            conp = _property_map[i][1];

            str = "$PTYPE$.set_$ATTR$ = function (v)\n";
            str += "{\n";
            str += "    if (v != this._p_$ATTR$)\n";
            str += "    {\n";
            str += "        this._p_$ATTR$ = v;\n";
            str += "        this.on_apply_$ATTR$();\n";
            str += "    }\n";
            str += "};\n";
            str += "$PTYPE$.on_apply_$ATTR$ = function ()\n";
            str += "{\n";
            str += "    if (this.$CTRL$)\n";
            str += "        this.$CTRL$.$CTRLPROP$ = this._p_$ATTR$;\n"
            str += "};\n\n";

            str = str.replace(/\$PTYPE\$/g, ptype_val).replace(/\$ATTR\$/g, prop).replace(/\$CTRL\$/g, control).replace(/\$CTRLPROP\$/g, conp);

            eval_str += str;
        }

        eval_str = eval_str.replace(/\$PTYPE\$/g, ptype_val);

        if (!nexacro.ismodule)
            new Function(eval_str)(arguments[0]);
        else
            new Function(String(arguments[0]), eval_str)(arguments[0]);
    };

    nexacro._makeGridPropertySetter("_pGrid", "_groupBar", _pGrid._control_passprop);

    _pGrid._callControlApplyProp = function (control)
    {
        var control_passprop = this._control_passprop;
        var _property_map = control_passprop[control];

        for (var i = 0; i < _property_map.length; i++)
        {
            var prop = _property_map[i][0];
            this["on_apply_" + prop]();
        }
    };

    _pGrid._is_listtype = true; // 접근성 contents focus

    _pGrid._use_innerhtml = false; // 동적 cell, row innerHTML 사용여부 (현재는 gridrow의 id로 node를 찾아 attach하는 부분이 싱크가 맞지않아 사용안함. node 조작시 영향도 존재 : 대용량처리나 tree 등에서 오류발생 - 재검토필요)
    _pGrid._use_recycle_colscroll = (nexacro._Browser != "Runtime");

    /* android accessibility */
    _pGrid._accessibility_row = -1;
    _pGrid._accessibility_cellidx = -1;
    _pGrid._skip_mobile_tabfocus = true;
    _pGrid._groupcount = 0;
    _pGrid._groupbarheight = 24;
    _pGrid._groupinitstatus = "expand,all";
    _pGrid._b_indentsubsum = true;

    //==============================================================================
    //nexacro.Grid : Create & Destroy & Update
    //==============================================================================
    _pGrid.on_create_contents = function ()
    {
        var control_elem = this.getElement();
        if (control_elem)
        {
            var text_elem = this._text_elem = new nexacro.TextBoxElement(control_elem);
            text_elem.setElementSize(this._getClientWidth(), this._getClientHeight());
            text_elem.setElementVisible(false);
            text_elem.setElementTextAlign("center");
            text_elem.setElementVerticalAlign("middle");

            if (this._p_binddataset && !this._binddataset)
            {
                var ds = this._findDataset(this._p_binddataset);
                if (ds)
                    this.setBindDataset(ds);
            }

            this._createBandsAndAreas(true);
        }
    };

    _pGrid.on_created_contents = function (win)
    {
        var text_elem = this._text_elem;
        if (text_elem)
        {
            text_elem.create(win);
        }

        var head_band = this._headBand;
        if (head_band)
        {
            head_band.on_created();
        }

        var body_band = this._bodyBand;
        if (body_band)
        {
            body_band.on_created();
        }

        var summ_band = this._summBand;
        if (summ_band)
        {
            summ_band.on_created();
        }

        var groupbar = this._groupBar;
        if (groupbar)
        {
            groupbar.on_created(); // NC는 created 로..
        }

        var select_ctrl = this._select_ctrl;
        if (select_ctrl)
        {
            select_ctrl.on_created();
        }

        if (this._covercontrol)
            this._covercontrol.on_created();
        if (this._highlight_row_main)
            this._highlight_row_main.on_created();
        if (this._highlight_row_sublast)
            this._highlight_row_sublast.on_created();
        if (this._highlight_row_subcenter)
            this._highlight_row_subcenter.on_created();

        this._onResetScrollBar();

        if (body_band || head_band || summ_band)
        {
            this._applyAutofittype(true);
        }

        if (this._create_selection != null)
        {
            var sel = this._create_selection;
            this._resetSelect(sel.row, sel.cell, sel.col, sel.subrow, sel.pivot);
        }

        this._create_selection = null;
        this._is_created = true;    // nodataimage 때문에 여기서 완료 처리

        var recreatecontents = false;

        if (this._useexprtree)
            recreatecontents = true;

        if (this._p_autosizingtype != "none")
        {
            if (this._img_preload_cnt == 0)
                recreatecontents = true;
        }

        if (recreatecontents)
            this._recreate_contents_all(true, true);
        else
            this._refreshBody();

        this._on_created_accessibility_contents(win);

        this.on_apply_nodatatext();
        this.on_apply_nodataimage();
        this.on_apply_readonly();
        this._applyResizer();
        this.on_apply_prop_rtl();

        if (this._after_resizeband)
            this._resizeBand();

        this._adjustOverlayControls(true); //suppressinfo 최신으로 새로만들어야함

        if (!this._isMultiSelect() && !this._isAreaSelect())
            this._initSelect(this._rowposition);
    };

    _pGrid._on_apply_status = function (oldstatus, status, olduserstatus, userstatus, apply, status_param, value_param, applycssstatus, applycssuserstatus)
    {
        if (status == "mouseover")
        {
            if (this._p_mouseovertype == "cell" || this._p_mouseovertype == "row")
                status = oldstatus;
        }

        nexacro.Component.prototype._on_apply_status.call(this, oldstatus, status, olduserstatus, userstatus, apply, status_param, value_param, applycssstatus, applycssuserstatus);

        var rowcount = this._rowcount;
        if (this.getElement() && rowcount == 0 && this._bodyBand == null && this._is_created)
        {
            if (this._p_nodataimage)
            {
                var val = "transparent " + this._p_nodataimage + " center center no-repeat";
                var background = nexacro.BackgroundObject(val, this);
                this._control_element.setElementBackground(background);
            }
            else
            {
                this.on_apply_background(this._background);
            }
        }
        else
        {
            this.on_apply_background(this._background);
        }
    };

    _pGrid.on_create_contents_command = function ()
    {
        var command = "";
        var text_elem = this._text_elem;
        if (text_elem)
        {
            command += text_elem.createCommand();
        }

        var head_band = this._headBand;
        if (head_band)
        {
            command += head_band.createCommand();
        }

        var body_band = this._bodyBand;
        if (body_band)
        {
            command += body_band.createCommand();
        }

        var summ_band = this._summBand;
        if (summ_band)
        {
            command += summ_band.createCommand();
        }
        return command;
    };

    _pGrid.on_attach_contents_handle = function (win)
    {
        var text_elem = this._text_elem;
        if (text_elem)
        {
            text_elem.attachHandle(win);
        }

        var head_band = this._headBand;
        if (head_band)
        {
            head_band._control_element._cur_border = head_band._border || head_band._getCSSStyleValue("border", head_band._status);
            head_band.attachHandle(win);
        }

        var body_band = this._bodyBand;
        if (body_band)
        {
            body_band._control_element._cur_border = body_band._border || body_band._getCSSStyleValue("border", body_band._status);
            body_band.attachHandle(win);
        }

        var summ_band = this._summBand;
        if (summ_band)
        {
            summ_band._control_element._cur_border = summ_band._border || summ_band._getCSSStyleValue("border", summ_band._status);
            summ_band.attachHandle(win);
        }

        var groupbar = this._groupBar;
        if (groupbar)
        {
            groupbar.on_created(); // NC는 created 로..
        }

        var select_ctrl = this._select_ctrl;
        if (select_ctrl)
        {
            select_ctrl.attachHandle(win);
        }

        this._onResetScrollBar();

        if (body_band || head_band || summ_band)
        {
            this._applyAutofittype(true);
        }

        if (this._create_selection != null)
        {
            var sel = this._create_selection;
            this._resetSelect(sel.row, sel.cell, sel.col, sel.subrow, sel.pivot);
        }

        this._create_selection = null;
        this._is_created = true;    // nodataimage 때문에 여기서 완료 처리

        var recreatecontents = false;

        if (this._useexprtree)
        {
            recreatecontents = true;
        }
        if (this._p_autosizingtype != "none")
        {
            if (this._img_preload_cnt == 0)
                recreatecontents = true;
        }
        if (recreatecontents)
            this._recreate_contents_all(true, true);
        else
            this._refreshBody();

        this._on_attach_accessibility_contents_handle(win);
        this.on_apply_nodatatext();
        this.on_apply_nodataimage();
        this.on_apply_readonly();
        this._applyResizer();
        this.on_apply_prop_rtl();

        if (this._control_element)
        {
            if (this._control_element._arrangeBandOrder)
                this._control_element._arrangeBandOrder();
        }

        if (this._after_resizeband)
            this._resizeBand();

        if (this._select_ctrl)
            this._select_ctrl.on_created(win);

        if (this._covercontrol)
            this._covercontrol.on_created();
        if (this._highlight_row_main)
            this._highlight_row_main.on_created();
        if (this._highlight_row_sublast)
            this._highlight_row_sublast.on_created();
        if (this._highlight_row_subcenter)
            this._highlight_row_subcenter.on_created();

        this._adjustOverlayControls(true); //suppressinfo 최신으로 새로만들어야함 
        this._initChecked();

        if (!this._isMultiSelect() && !this._isAreaSelect())
            this._initSelect(this._rowposition);
    };

    _pGrid._destroyFormats = function ()
    {
        var formats = this._formats;
        if (formats)
        {
            for (var id in formats)
            {
                var format = formats[id];

                if (format && format.destroy)
                {
                    format.destroy();
                    formats[id] = null;
                }
            }
            this._formats = {};
        }
    }

    _pGrid.on_destroy_contents = function ()
    {
        if (this._binddataset)
            this._removeDSEventHandlers(this._binddataset);

        if (this._aniframe_rowscroll)
            this._aniframe_rowscroll.destroy();
        if (this._aniframe_rowscroll_float)
            this._aniframe_rowscroll_float.destroy();
        if (this._aniframe_colscroll)
            this._aniframe_colscroll.destroy();
        if (this._aniframe_rowscroll_end)
            this._aniframe_rowscroll_end.destroy();
        if (this._aniframe_colscroll_end)
            this._aniframe_colscroll_end.destroy();
        if (this._aniframe_clientrect)
            this._aniframe_clientrect.destroy();

        this._aniframe_rowscroll = null;
        this._aniframe_rowscroll_float = null;
        this._aniframe_colscroll = null;
        this._aniframe_rowscroll_end = null;
        this._aniframe_colscroll_end = null;
        this._aniframe_clientrect = null;

        this._scroll_vpos_queue = null;

        this._destroyHighlightRow();

        var text_elem = this._text_elem;
        if (text_elem)
        {
            text_elem.destroy();
            this._text_elem = null;
        }
        this._destroyBands(true);

        this._destroyFormats();

        this._select_ctrl = null;
        this._currentCellEditor = null;

        this._binddataset = null;
        if (this._resizer_colctrl)
        {
            this._resizer_colctrl.destroy();
        }
        if (this._resizer_rowctrl)
        {
            this._resizer_rowctrl.destroy();
        }

        if (this._extratrack_timer)
        {
            this._extratrack_timer._handle.stop();
            this._extratrack_timer._handle = null;
            this._extratrack_timer = null;
        }

        this._clearTreeStates();
        this._clearTempBand(true);
        this._blinktask = null;

        if (this._tempmergeeditor)
        {
            this._tempmergeeditor.destroy();
            this._tempmergeeditor = null;
        }

        this._destroyOverlayControls();
        this._destroySelectionControls();
        this._destroyCellSelectionControl();

        this._hscrollmng.destroy();
        this._hscrollmng = null;
        this._vscrollmng.destroy();
        this._vscrollmng = null;
        this._curFormat = null;
        this._formats = null;
        this._mouseovercell = null;
        this._lastmouseentercell = null;
        this._prevAreaCellObj = null;
        this._selectstartrow = null;
        this._selectstartcol = null;
        this._selectstartsubrow = null;
        this._selectstartpvt = null;
        this._selectendrow = null;
        this._selectendcol = null;
        this._selectendsubrow = null;
        this._selectendpvt = null;
        this._resizerCols = null;
        this._resizerRows = null;
        this._imgsize_cache = null;
        this._rowSizeListSub = null;
        this._rowSizeList = null;
        this._rowHeadListSub = null;
        this._rowHeadList = null;
        this._rowSummListSub = null;
        this._rowSummList = null;
        this._lazy_load_rowsize = null;
        this._toprowpos = null;
        this._selectinfo = null;
        this._recreate_contents_proc = null;
        this._keydown_elem = null;
        this._tree_load_all = null;
        this._image_load_all = null;
        this._focus_proc = null;
        this._after_recreate_contents_all = null;
        this._band_scroll_tops = null;
        this._format_str = null;
        this._exprcache = null;
        this._use_bind_expr_cells = null;
        this._is_use_bind_expr_style = null;
        this._setdataobj = null;
        this._resizer_colctrl = null;
        this._resizer_rowctrl = null;
        this._p_selectstartrow = null;
        this._p_selectstartcol = null;
        this._p_selectstartsubrow = null;
        this._p_selectstartpivot = null;
        this._p_selectendrow = null;
        this._p_selectendcol = null;
        this._p_selectendsubrow = null;
        this._p_selectendpivot = null;
        this._p_formats = null;
        this._overlay_controls = null;
        this._selections = null;
        this._recalcXY_info = null;
        this._virtual_mergecell_arr = null;
        this._enable_redraw_history = null;
        this._autofitcol_rate = null;
        this._org_treeStates = null;
        this._treeCellinfo = null;
        this._band_resizing_no_autofit = null;
        this._global_cursor_obj = null;
        this._global_cursor = null;
        this._start_perftime = null;
        this._end_perftime = null;
        this._drag_start_obj = null;
        this._firstEditableCell = null;

        if (this._afterrecreatetask)
        {
            this._afterrecreatetask.destroy();
            this._afterrecreatetask = null;
        }
        if (this._applytask)
        {
            this._applytask.destroy();
            this._applytask = null;
        }
        this._arrtextsizeCache = null;
        this._sortinfo = null;
        this._group_checked = null;
        this._check_subrow_map = null;
    };

    _pGrid._clearTempBand = function (b_destroy)
    {
        if (this._style_tempband["head"])
        {
            this._style_tempband["head"].destroy();
            this._style_tempband["head"] = null;
        }

        if (this._style_tempband["body"])
        {
            this._style_tempband["body"].destroy();
            this._style_tempband["body"] = null;
        }

        if (this._style_tempband["summary"])
        {
            this._style_tempband["summary"].destroy();
            this._style_tempband["summary"] = null;
        }

        if (b_destroy)
            this._style_tempband = null;
    };

    _pGrid._is_changingRect = false;
    _pGrid.on_change_containerRect = function (width, height)
    {
        if (!this._is_changingRect)
            nexacro.Component.prototype.on_change_containerRect.call(this, width, height);
        if (this._is_created_contents)
        {
            var text_elem = this._text_elem;
            text_elem.setElementSize(width, height);
        }
        this._is_changingRect = true;
        this._resizeBand();
        this._adjustOverlayControls(false);
        this._is_changingRect = false;
    };

    //==============================================================================
    //nexacro.Grid : Override
    //==============================================================================
    _pGrid.on_create_control_element = function (parent_elem)
    {
        var control_elem = new nexacro.GridScrollableControlElement(parent_elem);
        control_elem.setLinkedControl(this);
        this._control_element = control_elem;
        return control_elem;
    };

    _pGrid._on_deactivate = function ()
    {
        if (!this._isSelected())
        {
            this._changeStatus("enabled", true);
        }
    };

    _pGrid.on_update_position = function (resize_flag, move_flag, update)
    {
        nexacro.Component.prototype.on_update_position.call(this, resize_flag, move_flag, update);

        if (this._currentCellEditor && this._currentCellEditor._isPopupVisible())
        {
            this._currentCellEditor.on_update_position(resize_flag, move_flag, update);
        }
    };

    _pGrid.applyto_bindSource = function (propid, Val)
    {
        if (this._currentCellEditor)
        {
            this._currentCellEditor._setDataset();
        }
    };

    /* property 확정시 property 이름 변경 및 주석 제거
    _pGrid.set_accessibilityreadbandlabel = function (flag)
    {
        
        flag = nexacro._toBoolean(flag);
        if (this.accessibilityreadbandlabel != flag)
        {
            this.accessibilityreadbandlabel = flag;
            return true;
        }
        return false;        
    };
    */

    /* android accessibility */
    _pGrid.on_fire_sys_onaccessibilitygesture = function (direction, fire_comp, refer_comp)
    {
        var bIsAndroidRuntimeAccessibility = (nexacro._Browser == "Runtime" && this._env._a11ytype == 5);
        var bIsNotInitialized = (this._currentBand == "body" && this._accessibility_row == -1 && this._accessibility_cellidx == -1);

        if (bIsAndroidRuntimeAccessibility)
        {
            if (direction === undefined)
            {
                return false;
            }
            if (bIsNotInitialized)
            {
                this._accessibility_row = 0;
                this._accessibility_cellidx = 0;
            }
        }

        var ret = false;
        var curFormat = this._curFormat;
        if (curFormat)
        {
            var headcells_len = (curFormat._headcells) ? curFormat._headcells.length : 0;
            var bodycells_len = (curFormat._bodycells) ? curFormat._bodycells.length : 0;
            var summcells_len = (curFormat._summcells) ? curFormat._summcells.length : 0;

            if (this._currentBand == "grid" && this._accessibility_cellidx < 0 && this._accessibility_row < 0)
            {
                if (headcells_len == 0 && bodycells_len == 0 && summcells_len == 0)
                {
                    var _form = this._getForm();
                    var comp = _form._getTabOrderNext(this, (direction > 0) ? direction : -1, true);
                    if (comp && (!this._p_nodatatext || this._p_nodatatext.length <= 0))
                    {
                        comp._setAccessibilityNotifyEvent(direction);
                    }
                }

                if (direction)
                {
                    this._currentBand = "head";
                    this._accessibility_row = 0;
                    this._accessibility_cellidx = -1;
                }
                else
                {
                    this._currentBand = "summary";
                    this._accessibility_row = 0;
                    this._accessibility_cellidx = summcells_len;
                }
            }

            var cellobj = null;
            while (true)
            {
                if (direction)
                    this._accessibility_cellidx++;
                else
                    this._accessibility_cellidx--;

                if (this._currentBand == "head")
                {
                    if (direction)
                    {
                        if (!this._headBand || this._accessibility_cellidx >= headcells_len)
                        {
                            this._currentBand = "body";
                            this._accessibility_row = 0;
                            this._accessibility_cellidx = 0;

                            /* bodyBand empty & has nodatatext property */
                            if (this._p_rowcount <= 0 && this._p_nodatatext)
                            {
                                this._bodyBand._setAccessibilityNotifyEvent();
                                ret = true;
                                break;
                            }
                        }
                    }
                    else
                    {
                        if (!this._headBand || this._accessibility_cellidx < 0)
                        {
                            this._accessibility_row = -1;
                            this._accessibility_cellidx = -1;
                            break;
                        }
                    }
                }
                else if (this._currentBand == "summary")
                {
                    if (direction)
                    {
                        if (!this._summBand || this._accessibility_cellidx >= summcells_len)
                        {
                            this._accessibility_row = -1;
                            this._accessibility_cellidx = -1;
                            break;
                        }
                    }
                    else
                    {
                        if (!this._summBand || this._accessibility_cellidx < 0)
                        {
                            this._currentBand = "body";
                            this._accessibility_row = this._rowcount - 1;
                            this._accessibility_cellidx = bodycells_len - 1;

                            /* bodyBand empty & has nodatatext property */
                            if (this._p_rowcount <= 0 && this._p_nodatatext)
                            {
                                this._bodyBand._setAccessibilityNotifyEvent();
                                ret = true;
                                break;
                            }
                        }
                    }
                }
                else // currentBand == "body"
                {
                    if (direction)
                    {
                        if (this._accessibility_cellidx >= bodycells_len)
                        {
                            this._accessibility_row++;
                            this._accessibility_cellidx = 0;
                        }

                        if (this._rowcount <= 0 || this._accessibility_row >= this._rowcount)
                        {
                            this._currentBand = "summary";
                            this._accessibility_row = 0;
                            this._accessibility_cellidx = 0;
                        }
                    }
                    else
                    {
                        if (this._accessibility_cellidx < 0)
                        {
                            this._accessibility_row--;
                            this._accessibility_cellidx = bodycells_len - 1;
                        }

                        if (this._rowcount <= 0 || this._accessibility_row < 0)
                        {
                            this._currentBand = "head";
                            this._accessibility_row = 0;
                            this._accessibility_cellidx = headcells_len - 1;
                        }
                    }
                }

                cellobj = this._getAccessibilityCurrentCell(this._accessibility_row, this._accessibility_cellidx);
                if (cellobj)
                {
                    cellobj._setAccessibilityNotifyEvent();
                    ret = true;
                    break;
                }
            } // while (true)
        } // curFormat == true                
        return ret;
    };

    _pGrid._setAccessibilityNotifyEvent = function (direction)
    {
        this._resetScrollPos(
            this,
            this._adjust_left,
            this._adjust_top,
            this._adjust_left + this._adjust_width,
            this._adjust_top + this._adjust_height,
            (direction && direction > 0) ? 0 : 1);
        /*
        var bIsAndroidRuntimeAccessibility = (nexacro._Browser == "Runtime" && this._env._a11ytype == 5);       
        if (bIsAndroidRuntimeAccessibility && direction !== undefined)
        {
            this._accessibility_row = -1;
            this._accessibility_cellidx = -1;
            this._currentBand = "grid";    
        }
        else
        {
            this._accessibility_row = -1;
            this._accessibility_cellidx = -1;
            this._currentBand = "grid";
        }
        */
        this._accessibility_row = -1;
        this._accessibility_cellidx = -1;
        this._currentBand = "grid";

        this.on_fire_sys_onaccessibilitygesture(direction);
    };

    _pGrid._setAccessibilityInfoByHover = function (control)
    {
        var ret = false;
        if (control)
        {
            if (control._cellobj)
            {
                control = control._cellobj;
            }

            if (control instanceof nexacro._GridCellControl)
            {
                this._currentBand = control._band.id;
                this._accessibility_cellidx = control._cellidx;
                this._accessibility_row = this._getDataRow(control._rowidx);
                this._first_focus = true;
            }
            else
            {
                this._first_focus = false;
            }

            ret = control._setAccessibilityInfoByHover();
        }
        return ret;
    };

    //==============================================================================
    //nexacro.Grid : Properties
    //==============================================================================
    _pGrid.set_fillareatype = function (v)
    {
        switch (v)
        {
            case "none":
            case "linerow":
            case "datarow":
            case "controlrow":
            case "allrow":
                if (v != this._p_fillareatype)
                {
                    this._p_fillareatype = v;
                    this.on_apply_fillareatype();
                }
                break;
        }
    };

    _pGrid.on_apply_fillareatype = function ()
    {
        this._resetfillarea = true;

        if (this._bodyBand)
        {
            this._bodyBand._matrix._adjustRowsDisplay();
            this._bodyBand._matrix._adjustColsDisplay();
            this._bodyBand._on_refresh_rows(false, false);
        }

        this._resetfillarea = false;
    };

    _pGrid._isFillAreatype = function ()
    {
        return (this._p_fillareatype != "none" && !this._isPagination())
    };

    _pGrid.set_selectscrollmode = function (v)
    {
        switch (v)
        {
            case "select":
            case "scroll":
                this._selectscrollmode = this._p_selectscrollmode = v;
                break;
            case "default":
                this._p_selectscrollmode = v;
                this._selectscrollmode = (nexacro._isTouchInteraction) ? "scroll" : "select";
                break;
        }
    };

    _pGrid.set_scrollpixel = function (v)
    {
        if (v != this._p_scrollpixel)
        {
            switch (v)
            {
                case "none":
                case "all":
                    this._p_scrollpixel = this._scrollpixel = v;
                    this.on_apply_scrollpixel();
                    break;
                case "default":
                    this._p_scrollpixel = v;
                    this._scrollpixel = (nexacro._isTouchInteraction) ? "all" : "none";
                    this.on_apply_scrollpixel();
                    break;
            }
        }
    };

    _pGrid.on_apply_scrollpixel = function ()
    {
        this._updateScrollInfo();
    };

    _pGrid.set_mouseovertype = function (v)
    {
        if (v != this._p_mouseovertype)
        {
            switch (v)
            {
                case "cell":
                case "row":
                    this._p_mouseovertype = v;
                    break;
                default:
                    this._p_mouseovertype = "default";
                    break;
            }
        }
    };

    _pGrid._updateScrollInfo = function ()
    {
        if (this._control_element)
        {
            this._control_element._updateClientRect();
        }
    };

    _pGrid.set_hideendline = function (v)
    {
        switch (v)
        {
            case "none":
            case "row":
            case "col":
            case "both":
                if (v != this._p_hideendline)
                {
                    this._p_hideendline = v;
                    this.on_apply_hideendline();
                }
                break;
        }
    };

    _pGrid.on_apply_hideendline = function ()
    {
        this._refreshAll();
    };

    _pGrid.set_userdata = function (v)
    {
        if (this._p_userdata != v)
        {
            this._p_userdata = v;
        }
    };

    _pGrid.set_nodataimage = function (v)
    {
        if (v && v.substring(0, 4).toLowerCase() != "url(")
        {
            v = "URL(" + v + ")";
        }

        this._p_nodataimage = v;
        this.on_apply_nodataimage();
    };

    _pGrid.on_apply_nodataimage = function ()
    {
        if (this.getElement())
        {
            var body = this._bodyBand;
            if (body)
            {
                body._updateAll(true);
            }
            else
            {
                this._apply_status(this._oldstatus, this._status, this._olduserstatus, this._userstatus);
            }
        }
    };

    _pGrid.set_nodatatext = function (v)
    {
        this._p_nodatatext = v;
        this.on_apply_nodatatext();
    };

    _pGrid.on_apply_nodatatext = function ()
    {
        var rowcount = this._getGridRowCount();
        if (this.getElement() && rowcount == 0)
        {
            var body = this._bodyBand;
            if (body)
            {
                if (this._text_elem)
                {
                    this._text_elem.setElementVisible(false);
                }

                body.on_apply_text();
            }
            else
            {
                if (this._text_elem)
                {
                    var text = this._getStringResourceProperty(this._p_nodatatext);
                    this._text_elem.setElementVisible(true);
                    this._text_elem.setElementText(text);
                }
            }
        }
        else
        {
            if (this._text_elem)
            {
                this._text_elem.setElementVisible(false);
            }
        }
    };

    _pGrid.set_summarytype = function (v)
    {
        switch (v)
        {
            case "default":
            case "top":
            case "left":
            case "lefttop":
                if (v != this._p_summarytype)
                {
                    this._p_summarytype = v;
                    this.on_apply_summarytype();
                }
                break;
        }
    };

    _pGrid.on_apply_summarytype = function ()
    {
        if (this.getElement() && this._curFormat != null && this._curFormat.summHeight > 0)
            this._recreate();
    };

    _pGrid.set_suppresslevel = function (v)
    {
        switch (v)
        {
            case "sameskip":
            case "allskip":
            case "allcompare":
                if (v != this._p_suppresslevel)
                {
                    this._p_suppresslevel = v;
                    this.on_apply_suppresslevel();
                }
                break;
        }
    };

    _pGrid.on_apply_suppresslevel = function ()
    {
        if (this.getElement() && this._curFormat != null)
            this._refreshBody();
    };

    _pGrid.set_showselection = function (v)
    {
        if (v != undefined)
        {
            v = nexacro._toBoolean(v);
            this._p_showselection = v;
            this.on_apply_showselection();
        }
    };

    _pGrid.on_apply_showselection = function ()
    {
        this._applySelection();
    };

    _pGrid.set_showcellselection = function (v)
    {
        if (v != undefined)
        {
            v = nexacro._toBoolean(v);
            this.showcellselection = v;
            this.on_apply_showcellselection();
        }
    };

    _pGrid.on_apply_showcellselection = function ()
    {
        this._applyCellSelection();
    };

    _pGrid.set_useselcolor = function (v)
    {
        if (v != undefined)
        {
            v = nexacro._toBoolean(v);
            this._p_useselcolor = v;
            this.on_apply_useselcolor();
        }

    };

    _pGrid.on_apply_useselcolor = function ()
    {
        this._refreshBody();
    };

    _pGrid.setBindDataset = function (obj)
    {
        if (obj instanceof nexacro.Dataset)
        {
            if (this._binddataset)
                this._removeDSEventHandlers(this._binddataset);

            if (!obj)
            {
                this._binddataset = null;
                this._p_binddataset = "";
            }
            else
            {
                this._binddataset = obj;
                this._p_binddataset = obj.id;
            }
            this.on_apply_prop_binddataset();
        }
    };

    _pGrid.getBindDataset = function ()
    {
        return this._binddataset;
    };

    _pGrid.set_binddataset = function (str)
    {
        if (str && typeof str != "string")
        {
            this.setBindDataset(str);
            return;
        }
        if (str != this._p_binddataset || this._p_binddataset && !this._binddataset)
        {
            if (this._binddataset)
                this._removeDSEventHandlers(this._binddataset);

            if (!str)
            {
                this._binddataset = null;
                this._p_binddataset = "";
            }
            else
            {
                str = str.replace("@", "");
                this._binddataset = this._findDataset(str);
                this._p_binddataset = str;
            }
            this.on_apply_prop_binddataset();
        }
        return this._p_binddataset;
    };

    _pGrid.on_apply_prop_binddataset = function ()
    {
        var dsobj = this._binddataset;

        this._is_user_change_head_rowsize = false;
        this._is_user_change_body_rowsize = false;
        this._is_user_change_summ_rowsize = false;

        if (this._is_down_act && !this._isDownActionKeyMouse())
            this._is_down_act = false;

        if (dsobj)
        {
            this._p_binddataset = dsobj.id;
            this._rowcount = dsobj._p_rowcount;	// rowcount property set
            this._applyPageRowCount();
            this._rowposition = dsobj.rowposition;

            // clear exprcache
            this._exprcache = {};
            this._initTreeStates();
            this._initChecked();
            this._recreate_contents_all(true, true);
            this._initSelect(this._rowposition);
            this._setDSEventHandlers(dsobj);
        }
        else
        {
            this._p_rowcount = this._rowcount = 0;	// rowcount property set
            this._rowposition = -1;
            this._exprcache = {};
            this._initTreeStates();
            this._initChecked();
            this._recreate_contents_all(true, true);
            this._initSelect(this._rowposition);
        }

        if (this._is_created)
            this._clearGroup(true);
    };

    _pGrid.set_formatid = function (v)
    {
        if (this._p_formatid != v)
        {
            this._p_formatid = v;
            this.on_apply_formatid();
        }
    };

    _pGrid.on_apply_formatid = function ()
    {
        var formatid = this._p_formatid;
        if (formatid == "" || !formatid)
        {
            formatid = this._default_formatid;
        }

        if (this._is_down_act && !this._isDownActionKeyMouse())
            this._is_down_act = false;

        this._curFormat = this._formats[formatid];
        this._autofitcol_rate = [];
        this._clearBindTypeFlag();
        this._clearTempBand();
        this._initVirtualMerge();
        this._initChecked();
        this._recreate();
        this._resetSelect(this._rowposition);
    };

    _pGrid.set_formats = function (v)
    {
        if (this._p_formats != v)
        {
            this._p_formats = v;
            this.on_apply_formats();
        }
    };

    _pGrid.on_apply_formats = function ()
    {
        if (this._is_down_act && !this._isDownActionKeyMouse())
            this._is_down_act = false;

        this._destroyFormats();
        this._setContents(this._p_formats);
        this._initVirtualMerge();
        this._initChecked();
        this._recreate();
        this._resetSelect(this._rowposition);
    };

    _pGrid.set_locale = function (v)
    {
        if (v != this._p_locale)
        {
            this._p_locale = v;
            this._locale = v;
            this.on_apply_locale(v);
        }
    };

    _pGrid.on_apply_locale = function (v)
    {
        this._recreate();
    };

    _pGrid.on_apply_font = function (font)
    {
        nexacro.Component.prototype.on_apply_font.call(this, font);

        if (this._apply_enableredraw)
            return;

        this._clearCellStyleCache(this._curFormat, true);
        // lazy 처리가 안된 경우만 recreate
        let is_recreate = (!this._enable_redraw_history.recreate && !this._enable_redraw_history.refresh_head && !this._enable_redraw_history.refresh_body && !this._enable_redraw_history.refresh_summ)
        if (is_recreate)
        {
            this._recreate();
        }
    };

    _pGrid.on_apply_wordSpacing = function (wordspacing)
    {
        nexacro.Component.prototype.on_apply_wordSpacing.call(this, wordspacing);

        if (this._apply_enableredraw)
            return;

        this._clearCellStyleCache(this._curFormat, true);

        if (this._p_autosizingtype != "none")
            this._recreate();
    };

    _pGrid.on_apply_letterSpacing = function (letterspacing)
    {
        nexacro.Component.prototype.on_apply_letterSpacing.call(this, letterspacing);

        if (this._apply_enableredraw)
            return;

        this._clearCellStyleCache(this._curFormat, true);

        if (this._p_autosizingtype != "none")
            this._recreate();
    };

    _pGrid.on_apply_cssclass = function (cssclass)
    {
        nexacro.Component.prototype.on_apply_cssclass.call(this, cssclass);

        if (this._apply_enableredraw)
            return;

        this._clearCellStyleCache(this._curFormat, true);

        if (this._p_autosizingtype != "none")
            this._recreate();
    };

    _pGrid.set_areaselecttype = function (v)
    {
        if (this._p_areaselecttype != v)
        {
            switch (v)
            {
                case "overband":
                case "limitband":
                    this._p_areaselecttype = v;
                    //TODO

                    break;
            }
        }
    };

    _pGrid.set_autoenter = function (v)
    {
        if (this._p_autoenter != v)
        {
            switch (v)
            {
                case "select":
                case "key":
                case "none":
                    this._p_autoenter = v;
                    break;
            }
        }
    };

    _pGrid.set_autofitbandtype = function (v)
    {
        if (this._p_autofitbandtype != v)
        {
            switch (v)
            {
                case "body":
                case "allband":
                case "nohead":
                case "noleft":
                case "nohead,noleft":
                    this._p_autofitbandtype = v;
                    //TODO

                    break;
            }
        }
    };

    _pGrid.set_autofitminheight = function (v)
    {
        if (this._p_autofitminheight != v)
        {
            this._p_autofitminheight = (isNaN(v) ? 100 : parseInt(v, 10));
        }
    };

    _pGrid.set_autofitminwidth = function (v)
    {
        if (this._p_autofitminwidth != v)
        {
            this._p_autofitminwidth = (isNaN(v) ? 100 : parseInt(v, 10));
        }
    };

    _pGrid.set_autofittype = function (v)
    {
        if (this._p_autofittype != v)
        {
            switch (v)
            {
                case "none":
                case "col":
                case "row":
                case "both":
                case "allpivot":
                case "allrow":
                case "allboth":
                case "col,allrow":
                case "row,allpivot":
                    this._p_autofittype = v;
                    this.on_apply_prop_autofittype();
                    break;
            }
        }
    };

    _pGrid.on_apply_prop_autofittype = function ()
    {
        if (this._curFormat)
        {
            var width;
            var bodysize = this._getBodyClientSize();
            var control_elem = this.getElement();

            width = bodysize[0];

            // 분산된 if 문 합성
            if (!this._is_user_change_colsize || this._p_autofittype == "none")
            {
                this._autofitcol_rate = [];
            }

            if (control_elem)
            {
                if (!this._is_created && width <= 0)
                    width = control_elem.client_width;

                this._curFormat._resetOrgColSize(true, this._autofitcol_rate, width);
            }
        }
        this._applyAutofittype(true, true);
    };

    _pGrid.set_pagesize = function (v)
    {
        if (this._p_pagesize != v)
        {
            this._p_pagesize = v;
            this._p_page = 1;
            this.on_apply_pagesize();
        }
    };

    _pGrid.on_apply_pagesize = function ()
    {
        this._setFixedRow(-1, true);
        this._applyPageRowCount();
        this._recreate_contents_all(true, true, true);
    };

    _pGrid.set_page = function (v)
    {
        if (this._p_pagesize > 0)
        {
            if (this._p_page != v)
            {
                this._p_page = v;
                this.on_apply_page();
            }
        }
    };

    _pGrid.on_apply_page = function ()
    {
        this._setFixedRow(-1, true);
        this._applyPageRowCount();
        this._recreate_contents_all(false, true, true);
    };

    _pGrid.set_allowcopy = function (v)
    {
        v = nexacro._toBoolean(v);
        if (this._p_allowcopy != v)
        {
            this._p_allowcopy = v;
        }
    };

    _pGrid.set_copyseparator = function (v)
    {
        if (this._p_copyseparator != v)
        {
            switch (v)
            {
                case "tab":
                    this._copyseparator = "\t";
                    break;
                case "comma":
                    this._copyseparator = ",";
                    break;
                case "pipe":
                    this._copyseparator = "|";
                    break;
                case "semicolon":
                    this._copyseparator = ";";
                    break;
                case "colon":
                    this._copyseparator = ":";
                    break;
                case "dash":
                    this._copyseparator = "-";
                    break;
                case "space":
                    this._copyseparator = " ";
                    break;
                case "hash":
                    this._copyseparator = "#";
                    break;
                default:
                    return;
            }
            this._p_copyseparator = v;
        }
    };

    _pGrid.set_showgroupbar = function (v)
    {
        v = nexacro._toBoolean(v);
        if (this._p_showgroupbar != v)
        {
            this._p_showgroupbar = v;
            this.on_apply_showgroupbar();
        }
    };

    _pGrid.on_apply_showgroupbar = function ()
    {
        this._recreate();
    };

    _pGrid._calcGroupBarHeight = function ()
    {
        if (this._groupBar)
        {
            this._groupBar.set_minheight(parseInt(this._p_groupbarminheight));
            this._groupbarheight = this._groupBar._adjust_height;
        }
    };

    _pGrid.set_groupbarminheight = function (v)
    {
        if (this._p_groupbarminheight != v)
        {
            this._p_groupbarminheight = v;
            this.on_apply_groupbarminheight();
        }
    };

    _pGrid.on_apply_groupbarminheight = function ()
    {
        this._calcGroupBarHeight();
        this._recreate();
    };

    _pGrid._applyPageRowCount = function ()
    {
        this._p_rowcount = this._getGridRowCount();
    };

    _pGrid.set_visible = function (v)
    {
        if (v === undefined || v === null) return;
        v = nexacro._toBoolean(v);

        if (this._p_visible != v)
        {
            nexacro.Component.prototype.set_visible.call(this, v);
            if (v && this._is_created)
            {
                this._refreshAll();
                if (nexacro._Browser == "Chrome" || (nexacro._Browser == "Edge" && nexacro._BrowserType == "WebKit"))    // 크롬에서 화면이 draw가 안되는 문제
                {
                    if (this._vscrollmng)
                    {
                        this._absolutelyResetScrollPos(true);
                        var limit = Math.ceil(this._control_element.vscroll_limit);
                        var top = this._vscrollmng._pos;
                        if (top >= limit)
                        {
                            top = limit;
                            this._control_element.setElementVScrollPos(top - 1);
                        }
                        else
                        {
                            this._control_element.setElementVScrollPos(top + 1);
                        }
                        this._control_element.setElementVScrollPos(top);
                        this._absolutelyResetScrollPos(false);
                    }
                }
            }
        }
    };

    _pGrid.set_autosizebandtype = function (v)
    {
        if (this._p_autosizebandtype != v)
        {
            var error = false;
            switch (v)
            {
                case "body":
                    this._bodyAutoSize = true;
                    this._headAutoSize = false;
                    this._summAutoSize = false;
                    this._AutoSizeLcol = false;
                    this._AutoSizeRcol = false;
                    break;
                case "head":
                    this._bodyAutoSize = false;
                    this._headAutoSize = true;
                    this._summAutoSize = false;
                    this._AutoSizeLcol = false;
                    this._AutoSizeRcol = false;
                    break;
                case "summary":
                    this._bodyAutoSize = false;
                    this._headAutoSize = false;
                    this._summAutoSize = true;
                    this._AutoSizeLcol = false;
                    this._AutoSizeRcol = false;
                    break;
                case "allband":
                    this._bodyAutoSize = true;
                    this._headAutoSize = true;
                    this._summAutoSize = true;
                    this._AutoSizeLcol = true;
                    this._AutoSizeRcol = true;
                    break;
                case "nohead":
                    this._bodyAutoSize = true;
                    this._headAutoSize = false;
                    this._summAutoSize = true;
                    this._AutoSizeLcol = false;
                    this._AutoSizeRcol = false;
                    break;
                case "noleft":
                    this._bodyAutoSize = true;
                    this._headAutoSize = true;
                    this._summAutoSize = true;
                    this._AutoSizeLcol = false;
                    this._AutoSizeRcol = true;
                    break;
                case "nohead,noleft":
                    this._bodyAutoSize = true;
                    this._headAutoSize = false;
                    this._summAutoSize = true;
                    this._AutoSizeLcol = false;
                    this._AutoSizeRcol = true;
                    break;
                default:
                    error = true;
                    break;
            }
            if (!error)
            {
                this._p_autosizebandtype = v;
                this.on_apply_autosizebandtype();
            }
        }
    };

    _pGrid.on_apply_autosizebandtype = function ()
    {
        if (this.getElement())
        {
            this._recreate_contents_all(true, true);
        }
    };

    _pGrid.set_autosizingtype = function (v)
    {
        if (this._p_autosizingtype != v)
        {
            var size = false;
            if (this._p_extendsizetype == "row" || this._p_extendsizetype == "both")
            {
                size = true;
            }

            switch (v)
            {
                case "none":
                case "col":
                    this._rowSizeEx = size;
                    break;
                case "row":
                case "both":
                    this._rowSizeEx = true;
                    break;
            }
            if (v == "row" || v == "none" || !v)
            {
                if (this._curFormat)
                {
                    var width;
                    var bodysize = this._getBodyClientSize();
                    var control_elem = this.getElement();

                    width = bodysize[0];

                    if (control_elem)
                    {
                        if (!this._is_created && width <= 0)
                            width = control_elem.client_width;

                        this._curFormat._resetOrgColSize(true, this._autofitcol_rate, width);
                    }
                }
            }
            this._p_autosizingtype = v;
        }
        this.on_apply_autosizingtype();
    };

    _pGrid.on_apply_autosizingtype = function ()
    {
        if (this.getElement())
        {
            this._is_user_change_head_rowsize = false;
            this._is_user_change_body_rowsize = false;
            this._is_user_change_summ_rowsize = false;

            this._recreate_contents_all(true, true);
            this._resetFixSize();
        }
    };

    _pGrid.set_readonly = function (v)
    {
        if (v != null)
        {
            v = nexacro._toBoolean(v);
            if (v != this._p_readonly)
            {
                this._p_readonly = v;
                this.on_apply_readonly();
            }
        }
    };

    _pGrid.on_apply_readonly = function ()
    {
        var v = this._p_readonly;

        this._changeStatus("readonly", v);
        if (this._headBand)
            this._headBand._changeStatus("readonly", v);
        if (this._bodyBand)
            this._bodyBand._changeStatus("readonly", v);
        if (this._summBand)
            this._summBand._changeStatus("readonly", v);

        this._refreshAll();
    };

    _pGrid.set_selectbandtype = function (v)
    {
        if (this._p_selectbandtype != v)
        {
            switch (v)
            {
                case "default":
                case "allband":
                case "body":
                case "nohead":
                case "noleft":
                    this._p_selectbandtype = v;
                    this.on_apply_selectbandtype();
                    break;
            }
        }
    };

    _pGrid.on_apply_selectbandtype = function ()
    {
        //TODO
    };

    _pGrid.set_selectchangetype = function (v)
    {
        if (this._p_selectchangetype != v)
        {
            switch (v)
            {
                case "up":
                case "down":
                    this._p_selectchangetype = v;
                    break;
            }
        }
    };

    _pGrid.set_selecttype = function (v)
    {
        if (this._p_selecttype != v)
        {
            var oldtype = this._isSelectRowType();
            var newtype;

            switch (v)
            {
                case "row":
                case "cell":
                case "area":
                case "multirow":
                case "multicell":
                case "multiarea":
                case "treecell":
                case "multitreecell":
                    this._p_selecttype = v;
                    newtype = this._isSelectRowType();
                    this.on_apply_selecttype(oldtype && !newtype);
                    break;
                default:
                    if (this._p_selecttype != "row")
                    {
                        this._p_selecttype = "row";
                        newtype = true;
                        this.on_apply_selecttype(oldtype && !newtype);
                    }
                    break;
            }
        }
    };

    _pGrid.on_apply_selecttype = function (refreshrow)
    {
        this._resetSelect();
        this._refreshBody();

        if (refreshrow && this._mouseovercell)
        {
            var cell = this._getCurrentBodyCell(this._mouseovercell.row, this._mouseovercell.cell);

            if (cell)
            {
                this._on_apply_cell_status(cell, "mouseover", false, true);
                this._on_apply_cell_status(cell, "mouseover", true);
            }
        }
        this._updateSelector();
    };

    _pGrid._applySelectorScroll = function (type, area)  // selector movetrack callback
    {
        var oldpos, new_pos, newpos;
        var retn = false;
        var topPos = this._toprowpos[0];
        var ctrl_flag = this._selectinfo.area.length > 1 && this._p_selecttype == "multirow";

        if (type[0] == "leftover0")
        {
            this._multiselect = ctrl_flag ? "ctrl" : "shift";
            this._moveToCell("prev", false, true, area, null);
            retn = true;
        }
        else if (type[0] == "rightover0")
        {
            this._multiselect = ctrl_flag ? "ctrl" : "shift";
            this._moveToCell("next", false, true, area, this._selectinfo.ctrlpoint.col);
            retn = true;
        }
        else if (type[0] == "leftover1")
        {
            this._multiselect = ctrl_flag ? "ctrl" : "shift";
            this._moveToCell("prev", false, true, area, this._selectinfo.ctrlpoint.col);
            retn = true;
        }
        else if (type[0] == "rightover1")
        {
            this._multiselect = ctrl_flag ? "ctrl" : "shift";
            this._moveToCell("next", false, true, area, null);
            retn = true;
        }

        if (type[1] == "topover0" || type[1] == "topover1")
        {

            new_pos = this._selectinfo.currow - 1;
            oldpos = this._begrowpos;
            if (topPos != new_pos)
                newpos = this._jumpCurrentRow(new_pos);
            retn = (oldpos != newpos);
        }
        else if (type[1] == "bottomover0" || type[1] == "bottomover1")
        {
            new_pos = this._selectinfo.currow + 1;
            oldpos = this._begrowpos;

            newpos = this._jumpCurrentRow(new_pos);
            retn = (oldpos != newpos);
        }
        return retn;
    };

    _pGrid._startAreaSizing = function (posobj, idx)
    {
        var format = this._curFormat;
        var subrowlen = format._bodyrows.length;

        var info = this._getAreaInfoWithPos(posobj, idx);
        var cellinfo;

        if (idx == 0)
        {
            cellinfo = format._bodycells[info.ecell];
            if (cellinfo)
                this._selectinfo.ctrlpoint._set(cellinfo, info.erow, subrowlen);
        }
        else if (idx == 1)
        {
            cellinfo = format._bodycells[info.scell];
            if (cellinfo)
                this._selectinfo.ctrlpoint._set(cellinfo, info.srow, subrowlen);
        }
        else if (idx == 2)
        {
            cellinfo = format._bodycells[info.ecell];
            if (cellinfo)
                this._selectinfo.ctrlpoint._set(cellinfo, info.srow, subrowlen);
        }
        else if (idx == 3)
        {
            cellinfo = format._bodycells[info.scell];
            if (cellinfo)
                this._selectinfo.ctrlpoint._set(cellinfo, info.erow, subrowlen);
        }
    };

    _pGrid._applyAreaSizing = function (posobj, idx, is_tracking)  // selector endtrack callback
    {

        //var format = this._curFormat;
        //var subrowlen = format._bodyrows.length;
        var beforeCell = this._selectinfo.curcell;
        var beforeCol = this._selectinfo.curcol;
        var beforeRow = this._selectinfo.curdsrow;
        var beforeSubrow = this._selectinfo.cursubrow;
        var beforePvt = this._selectinfo.curpvt;
        var afterCell, afterCol, afterRow, afterSubrow, afterPvt = this._selectinfo.curpvt;

        var info = this._getAreaInfoWithPos(posobj, idx);

        if (idx == 0)
        {
            this._setSelectedInfo(info.scell, info.scol, info.srow, info.ssubrow, null, info);
            afterCell = info.scell;
            afterCol = info.scol;
            afterRow = info.srow;
            afterSubrow = info.ssubrow;
        }
        else if (idx == 1)
        {
            this._setSelectedInfo(info.ecell, info.ecol, info.erow, info.esubrow, null, info);
            afterCell = info.ecell;
            afterCol = info.ecol;
            afterRow = info.erow;
            afterSubrow = info.esubrow;
        }
        else if (idx == 2)
        {
            this._setSelectedInfo(info.scell, info.scol, info.erow, info.esubrow, null, info);
            afterCell = info.scell;
            afterCol = info.scol;
            afterRow = info.erow;
            afterSubrow = info.esubrow;
        }
        else if (idx == 3)
        {
            this._setSelectedInfo(info.ecell, info.ecol, info.erow, info.esubrow, null, info);
            afterCell = info.ecell;
            afterCol = info.ecol;
            afterRow = info.srow;
            afterSubrow = info.ssubrow;
        }

        var kind;
        if (is_tracking)
            kind = "selectorsizing";
        else if (is_tracking === false)
            kind = "selector";
        //var kind = (is_tracking) ? "selectorsizing" :"selector";
        if (this._selectinfo.area.length > 1 && this._p_selecttype == "multirow")
            this._multiselect = "ctrl";
        else
            this._multiselect = "shift";
        this._ChangeSelect(afterCell, afterCol, afterRow, afterSubrow, afterPvt, false, beforeCell, beforeCol, beforeRow, beforeSubrow, beforePvt, "body", kind);
    };

    _pGrid._getAreaInfoWithPos = function (posobj, idx)  // selector 크기로 areainfo 구함.
    {
        var scroll_left = this._getScrollLeft();
        var scroll_top = this._getScrollTop();
        var scroll_max = this._getScollMaxLeft();
        var select_ctrl = this._select_ctrl;

        var scale = this._getCumulativeZoomFactor() / 100.0;
        var wheelZoom = nexacro._getDevicePixelRatio(this.getElement());
        var border = this._getCurrentStyleBorder();
        var border_l = border ? border.left._width : 0;
        var border_t = border ? border.top._width : 0;

        scale = scale * wheelZoom;

        var l = (posobj.l - border_l) / scale;
        var r = l + posobj.w / scale;
        var t = (posobj.t - border_t) / scale;
        var b = t + posobj.h / scale;

        var format = this._curFormat;
        var rowcnt = this._getGridRowCount();
        var row, srow, erow, scell, ecell, scol, ecol, ssubrow, esubrow, spvt, epvt;
        var cell_left, cell_top, cell_right, cell_bottom;
        //var arealeft;
        var toppos;
        //var ctrlpoint = this._selectinfo.ctrlpoint;
        var begarea, endarea;

        if (select_ctrl)
        {
            begarea = select_ctrl._start_begarea;
            endarea = select_ctrl._start_endarea;
        }
        else
        {
            begarea = this._selectinfo.arearect.barea;
            endarea = this._selectinfo.arearect.earea;
        }


        var fixed_rowcnt = parseInt(this._fixed_rowcnt);
        var fixed_startrow = fixed_rowcnt > 0 ? parseInt(this._fixed_startrow) : 0;
        var fixed_endrow = parseInt(this._fixed_endrow);
        //      var fixed_height = parseInt(this._fixed_height);

        if (fixed_rowcnt > 0)
            toppos = this._getHeadHeight();
        else
            toppos = this._getHeadHeight() - scroll_top;

        if (this._p_summarytype == "top" || this._p_summarytype == "lefttop")
            toppos += this._getSummHeight();

        if (this._p_showgroupbar)
            toppos += this._groupbarheight;

        var row_top, row_bottom;
        var cells = format._bodycells;
        var cells_len = cells.length;
        //      var colspan, rowspan;
        var col, area;
        var condition;
        var cell_rect;
        srow = -1;

        row_top = toppos;

        //scol = scell = 0;
        for (var i = fixed_startrow; i < rowcnt; i++)
        {
            if (fixed_rowcnt > 0 && i == (fixed_endrow + 1))
            {
                row_top -= scroll_top;
            }
            row_bottom = row_top + this._getRowSize(i);

            if (this._track_mode == "areaselect")
            {
                condition = (t <= row_bottom);
                if (i == 0 && t < row_top)
                    condition = true;
            }
            else
                condition = (row_top < t && t <= row_bottom);

            var j;
            if (srow < 0 && condition)
            {
                srow = this._getDataRow(i);

                for (j = 0; j < cells_len; j++)
                {
                    area = cells[j]._area;
                    col = cells[j]._col;
                    row = cells[j]._row;
                    //colspan = cells[j]._colspan;
                    //rowspan = cells[j]._rowspan;
                    /*
                    if (cells[j]._area == "left")
                        arealeft = this._getClientLeft();
                    else if (cells[j]._area == "right")
                        arealeft = this._getClientWidth() - format.rightWidth;
                    else
                        arealeft = format.leftWidth - scroll_left;*/
                    /*
                    cell_left = arealeft + cols[col].left;
                    cell_right = arealeft + cols[col + colspan - 1].right;
                    cell_top = row_top + rows[row].top;
                    cell_bottom = row_top + rows[row + rowspan - 1].bottom;
                    */
                    cell_rect = this._getSubCellRect(i, j, -1, -1, false);
                    cell_left = cell_rect.left;
                    //cell_top = cell_rect.top;
                    cell_right = cell_rect.right;
                    cell_bottom = cell_rect.bottom;

                    if (fixed_rowcnt > 0 && i <= fixed_endrow)
                    {
                        //  cell_top += scroll_top;
                        cell_bottom += scroll_top;
                    }

                    if (this._track_mode == "areaselect")
                    {
                        condition = (cell_left <= l && l < cell_right && t < cell_bottom);
                        if (j == 0 && l < cell_left)
                            condition = true;
                    }
                    else
                        condition = (cell_left <= l && l < cell_right && t < cell_bottom);

                    if (condition)
                    {
                        if (endarea != begarea || (begarea == "body" && endarea == "body"))
                        {
                            if (begarea != "left" && scroll_left > 0 && area == "left")   // body랑 left랑 겹치는 부분
                            {
                                continue;
                            }

                            if (begarea != "right" && scroll_left < scroll_max && area == "right")  // body랑 right랑 겹치는 부분
                            {
                                continue;
                            }

                            if (endarea != "right" && area == "right")
                            {
                                continue;
                            }
                        }

                        scell = j;
                        scol = col;
                        ssubrow = row;

                        if (posobj.area != "right")
                            break;
                        else if (cells[j]._area == "right")
                            break;
                    }
                }
            }

            // end point

            if (this._track_mode == "areaselect")
            {
                condition = (b <= row_bottom);

                if ((i + 1) == rowcnt && b > row_bottom)
                    condition = true;
            }
            else
            {
                condition = row_top < b && b <= row_bottom;
            }

            if (srow >= 0 && condition)
            {
                erow = this._getDataRow(i);

                for (j = 0; j < cells_len; j++)
                {
                    col = cells[j]._col;
                    row = cells[j]._row;
                    //                    colspan = cells[j]._colspan;
                    //                    rowspan = cells[j]._rowspan;

                    /*
                    if (cells[j]._area == "left")
                        arealeft = this._getClientLeft();
                    else if (cells[j]._area == "right")
                        arealeft = this._getClientWidth() - format.rightWidth;
                    else
                        arealeft = format.leftWidth - scroll_left;

                    cell_left = arealeft + cols[col].left;
                    cell_top = row_top + rows[row].top;
                    cell_right = arealeft + cols[col + colspan - 1].right;
                    cell_bottom = row_top + rows[row + rowspan - 1].bottom;
                    */
                    /*
                    if (cells[j]._area == "left")
                        arealeft = 0;
                    else if (cells[j]._area == "right")
                        arealeft = this._getClientWidth() - format.rightWidth;
                    else
                        arealeft = 0;
                        */
                    cell_rect = this._getSubCellRect(i, j, -1, -1, false);

                    cell_top = cell_rect.top;
                    //cell_bottom = cell_rect.bottom;

                    if (fixed_rowcnt > 0 && i <= fixed_endrow)
                    {
                        cell_top += scroll_top;
                        //  cell_bottom += scroll_top;
                    }

                    if (cells[j]._area == "right")
                    {
                        cell_left = cell_rect.left - scroll_left;
                        cell_right = cell_rect.right - scroll_left;
                    }
                    else
                    {
                        cell_left = cell_rect.left;
                        cell_right = cell_rect.right;
                    }
                    if (this._track_mode == "areaselect")
                    {
                        condition = cell_left < r && r <= cell_right;
                        if ((j + 1) == cells_len && r >= cell_right)
                        {
                            condition = true;
                        }
                    }
                    else
                        condition = cell_left < r && r <= cell_right && cell_top < b;

                    //if (cell_left < r && r <= cell_right && cell_top < b && (b <= cell_bottom || bottomover))
                    if (condition)
                    {
                        if (endarea != begarea || (begarea == "body" && endarea == "body"))
                        {
                            if (endarea != "right" && scroll_left < scroll_max && cells[j]._area == "right")   // body랑 right랑 겹치는 부분
                            {
                                continue;
                            }

                            if (endarea != "left" && scroll_left > 0 && cells[j]._area == "left")  // body랑 left랑 겹치는 부분
                            {
                                continue;
                            }

                            if (begarea != "left" && cells[j]._area == "left")
                            {
                                continue;
                            }
                        }

                        ecell = j;
                        ecol = col;
                        esubrow = row;

                        if (posobj.area != "right")
                            break;
                        else if (cells[j]._area == "right")
                            break;
                    }
                }
                break;
            }
            row_top = row_bottom;
        }
        spvt = epvt = this._selectinfo.curpvt;

        return { srow: srow, erow: erow, scell: scell, ecell: ecell, scol: scol, ecol: ecol, ssubrow: ssubrow, esubrow: esubrow, spvt: spvt, epvt: epvt };
    };

    _pGrid._getSelectRect = function (onlyarea, bApplyFixedRow) // select된 영역 크기를 구하여 selector 크기 결정
    {
        if (!this._selectinfo)
            return null;

        var rect = this._selectinfo.arearect;
        var area = this._selectinfo.area;

        rect.left = 0;
        rect.top = 0;
        rect.width = 0;
        rect.height = 0;
        rect.barea = "";
        rect.earea = "";

        var scroll_left = this._getScrollLeft();
        var scroll_top = this._getScrollTop();

        while (area.length)
        {
            var areainfo = area[area.length - 1];
            var format = this._curFormat;
            var cols = format._cols;
            var rows = format._bodyrows;
            var subrow_size_list = this._rowSizeListSub;
            var begcol = areainfo.begcol;
            var endcol = areainfo.endcol;
            var bodystart = format.leftWidth;
            var rightstart = this._getClientWidth() - format.rightWidth;

            var fixed_startrow = this._fixed_startrow;
            //var fixed_endrow = this._fixed_endrow;

            if (areainfo.begrow < 0)    // head, summ
                break;

            if (!this._isAreaSelect())
            {
                begcol = 0;
                endcol = cols.length - 1;
            }



            if (begcol >= 0 && endcol >= 0)
            {
                if (onlyarea && cols[begcol]._area != cols[endcol]._area) // only same area
                    break;

                rect.barea = cols[begcol]._area;
                rect.earea = cols[endcol]._area;



                if (rect.barea == "right")
                {
                    rect.left = rightstart + cols[begcol].left;
                    rect.width = cols[endcol].right - cols[begcol].left;
                }
                else
                {
                    if (rect.barea == "left")
                        rect.left = cols[begcol].left;
                    else
                        rect.left = bodystart + cols[begcol].left - scroll_left;

                    if (rect.earea == "left")
                        rect.width = cols[endcol].right - rect.left;
                    else if (rect.earea == "body")
                        rect.width = (bodystart + cols[endcol].right - scroll_left) - rect.left;
                    else
                        rect.width = (rightstart + cols[endcol].right) - rect.left;
                }
            }
            else
            {

                rect.left = this._getClientLeft();
                rect.width = this._getClientWidth();
            }

            var area_begrow = areainfo.begrow;
            var area_endrow = areainfo.endrow;
            var i;

            for (var row = 0; row <= area_endrow; row++)
            {
                var s = 0, e = rows.length - 1;

                if (this._hasTree)
                {
                    if (this._getGridRow(row) < -2)
                        continue;
                }

                if (row < area_begrow)
                {
                    if (bApplyFixedRow && row < fixed_startrow)
                        continue;

                    for (i = s; i <= e; i++)
                    {
                        rect.top += subrow_size_list[row * rows.length + i];
                    }

                }
                else
                {
                    if (row == area_begrow)
                        s = areainfo.begsubrow[0];
                    if (row == area_endrow)
                        e = areainfo.endsubrow[row - area_begrow];

                    for (i = 0; i <= e; i++)
                    {
                        if (i < s)
                            rect.top += subrow_size_list[row * rows.length + i];
                        else
                            rect.height += subrow_size_list[row * rows.length + i];
                    }
                }
            }

            rect.top += this._bodyBand._adjust_top - scroll_top;

            break;  // 소나큐브무시
        }
        this._selectinfo.arearect = rect;

        return rect;
    };

    _pGrid._updateSelector = function (mode, pos)
    {
        var v = this._isAreaSelect() && nexacro._isTouchInteraction;

        if (this._control_element)
        {
            var rect, l, t, w, h;

            var select_ctrl = this._select_ctrl;
            if (v)
            {
                if (!select_ctrl)
                {
                    select_ctrl = new nexacro._GridSelector("gridselector", 0, 0, 0, 0, null, null, this);
                    select_ctrl._setCallbackFn(this._startAreaSizing, this._applyAreaSizing, this._applySelectorScroll);
                    select_ctrl.createComponent();
                    select_ctrl._createButton();
                    this._select_ctrl = select_ctrl;
                }

                if ((mode == "vscroll" || mode == "hscroll") && !select_ctrl._is_tracking)
                {
                    rect = this._selectinfo.arearect;

                    if (mode == "hscroll")
                    {
                        if (rect.barea == "left")
                        {
                            if (rect.earea == "body")
                                rect.width -= pos;
                        }
                        else if (rect.barea == "body")
                        {
                            rect.left -= pos;

                            if (rect.earea == "right")
                                rect.width += pos;
                        }
                    }
                    if (mode == "vscroll")
                        rect.top -= pos;

                    l = rect.left;
                    t = rect.top;
                    w = rect.width;
                    h = rect.height;

                    if (t + h <= this._bodyBand._adjust_top)
                        v = false;
                }
                else
                {
                    rect = this._getSelectRect(select_ctrl._onlyarea, true);

                    l = rect.left;
                    t = rect.top;
                    w = rect.width;
                    h = rect.height;
                }

                if (!l && !t && !w && !h)
                    v = false;

                select_ctrl.move(l, t, w, h, mode);

                if (v)
                {
                    if (!select_ctrl._is_tracking)
                        select_ctrl.set_visible(false);
                }
                else
                {
                    select_ctrl.set_visible(false);
                }
            }


        }
        else
        {
            if (this._select_ctrl)
            {
                this._select_ctrl.destroy();
                this._select_ctrl = null;
            }
        }
    };

    _pGrid.set_autoupdatetype = function (v)
    {
        if (this._p_autoupdatetype != v)
        {
            switch (v)
            {
                case "none":
                case "comboselect":
                case "dateselect":
                case "itemselect":
                    this._p_autoupdatetype = v;
                    break;
            }
        }
    };

    _pGrid.set_cellclickbound = function (v)
    {
        if (this._p_cellclickbound != v)
        {
            switch (v)
            {
                case "control":
                case "cell":
                    this._p_cellclickbound = v;
                    break;
            }
        }
    };

    _pGrid.set_cellmovingtype = function (v)
    {
        if (this._p_cellmovingtype != v)
        {
            switch (v)
            {
                case "none":
                case "col":
                case "col,band":
                case "col,merge":
                case "col,line":
                    this._p_cellmovingtype = v;
                    break;
            }
        }
    };

    _pGrid.set_cellsizebandtype = function (v)
    {
        if (this._p_cellsizebandtype != v)
        {
            switch (v)
            {
                case "body":
                case "allband":
                case "nohead":
                case "noleft":
                case "nohead,noleft":
                    this._p_cellsizebandtype = v;
                    this.on_apply_cellsizebandtype();
                    break;
            }
        }
    };

    _pGrid.on_apply_cellsizebandtype = function ()
    {
        //TODO
    };

    _pGrid.set_cellsizingtype = function (v)
    {
        if (this._p_cellsizingtype != v)
        {
            switch (v)
            {
                case "none":
                case "col":
                case "row":
                case "both":
                    this._p_cellsizingtype = v;
                    this.on_apply_cellsizingtype();
                    break;
            }
        }
    };

    _pGrid.on_apply_cellsizingtype = function ()
    {
        this._applyResizer();
    };

    _pGrid.set_extendsizetype = function (v)
    {
        if (this._p_extendsizetype != v)
        {
            var size = false;
            if (this._p_autosizingtype == "row" || this._p_autosizingtype == "both")
                size = true;

            var error = false;
            switch (v)
            {
                case "none":
                case "col":
                    this._rowSizeEx = size;
                    break;
                case "row":
                case "both":
                    this._rowSizeEx = true;
                    break;
                default:
                    error = true;
                    break;
            }

            if (!error)
            {
                this._p_extendsizetype = v;
                this.on_apply_extendsizetype();
            }
        }
    };

    _pGrid.on_apply_extendsizetype = function ()
    {
        if (this.getElement())
            this._recreate_contents_all(true, true);
    };

    _pGrid.set_wheelscrollrow = function (v)
    {
        if (this._p_wheelscrollrow != v)
        {
            this._p_wheelscrollrow = (isNaN(v) ? 2 : parseInt(v, 10));
        }
    };

    _pGrid.set_usecontrolkey = function (v)
    {
        if (this._p_usecontrolkey != v)
        {
            this._p_usecontrolkey = v;
        }
    };

    _pGrid.set_treeusebutton = function (v)
    {
        if (this._p_treeusebutton != v)
        {
            switch (v)
            {
                case "use":
                case "no":
                case "noclick":
                    this._p_treeusebutton = v;
                    this.on_apply_treeusebutton();
                    break;
            }
        }
    };

    _pGrid.set_dragscrolltype = function (v)
    {
        nexacro.Form.prototype.set_dragscrolltype.call(this, v);
    };

    _pGrid.on_apply_treeusebutton = function ()
    {
        this._refreshBody();
    };

    _pGrid.set_treeuseline = function (v)
    {
        if (v != null && this._p_treeuseline != v)
        {
            v = nexacro._toBoolean(v);
            this._p_treeuseline = v;
            this.on_apply_treeuseline();
        }
    };

    _pGrid.on_apply_treeuseline = function ()
    {
        this._refreshBody();
    };

    _pGrid.set_treeusecheckbox = function (v)
    {
        if (v != null && this._p_treeusecheckbox != v)
        {
            v = nexacro._toBoolean(v);
            this._p_treeusecheckbox = v;
            this.on_apply_treeusecheckbox();
        }
    };

    _pGrid.on_apply_treeusecheckbox = function ()
    {
        this._refreshBody();
    };

    _pGrid.set_treeuseimage = function (v)
    {
        if (v != null && this._p_treeuseimage != v)
        {
            v = nexacro._toBoolean(v);
            this._p_treeuseimage = v;
            this.on_apply_treeuseimage();
        }
    };

    _pGrid.on_apply_treeuseimage = function ()
    {
        this._refreshBody();
    };

    _pGrid.set_treeuseexpandkey = function (v)
    {
        if (v != null && this._p_treeuseexpandkey != v)
        {
            v = nexacro._toBoolean(v);
            this._p_treeuseexpandkey = v;
        }
    };

    _pGrid.set_treeinitstatus = function (v)
    {
        if (this._p_treeinitstatus != v)
        {
            var prev = this._p_treeinitstatus;
            this._p_treeinitstatus = v;

            if (!this.on_apply_treeinitstatus() === false)
                this._p_treeinitstatus = prev;
        }
    };

    _pGrid.set_groupinitstatus = function (v)
    {
        if (this._p_groupinitstatus != v)
        {
            switch (v)
            {
                case "collapse":
                    this._p_groupinitstatus = v;
                    this._groupinitstatus = "collapse,all";
                    break;
                case "expand":
                    this._p_groupinitstatus = v;
                    this._groupinitstatus = "expand,all";
                    break;
                default:
                    return;
            }
            this.on_apply_groupinitstatus();
        }
    };

    _pGrid.on_apply_groupinitstatus = function ()
    {
        this.on_apply_treeinitstatus(true);
    };

    _pGrid.on_apply_treeinitstatus = function (group)
    {
        var initstatus;

        if (group)
        {
            if (this._groupcount == 0)
                return;

            initstatus = this._groupinitstatus;
        }
        else
        {
            if (this._groupcount > 0)
                return;

            initstatus = this._p_treeinitstatus;
        }

        var expand, value, error = false;

        switch (initstatus)
        {
            case "collapse,null":
                expand = false;
                value = false;
                break;
            case "expand,null":
                expand = true;
                value = false;
                break;
            case "collapse,all":
                expand = false;
                value = true;
                break;
            case "expand,all":
                expand = true;
                value = true;
                break;
            default:
                error = true;
                break;
        }

        if (error)
            return false;

        if (!this._hasTree)
            return;

        var format = this._curFormat;

        if (!format)
            return;

        var cells = format._bodycells;
        var cellsLen = cells.length;
        var _treeIndexes = this._treeIndexes;
        var _treeStates = this._treeStates;

        if (!_treeIndexes || !_treeStates)
            return;

        this._org_treeStates = [];

        var update, precnt, state;
        var i, j;

        if (!value)
        {
            update = false;
            var dsrowidx;

            for (i = _treeIndexes.length - 1; i >= 0; i--)
            {
                var cellinfo, editType;
                dsrowidx = this.getDatasetRow(i);

                for (j = 0; j < cellsLen; j++)
                {
                    cellinfo = cells[j];
                    editType = cellinfo._getEdittype(dsrowidx);

                    if (editType == "tree" || editType == "rowgroup")
                    {
                        break;
                    }
                }
                if (cellinfo)
                {
                    if (cellinfo.treestate._bindtype != 0)
                    {
                        state = cellinfo._getAttrValue(cellinfo._p_treestate, dsrowidx);
                    }
                    if (!state && state !== 0)
                    {
                        precnt = _treeIndexes.length;
                        if (expand)
                        {
                            if (this._setTreeState(i, 1, false, "null") > 0)
                            {
                                i += (_treeIndexes.length - precnt + 1);
                                update = true;
                            }
                        }
                        else
                        {
                            if (this._setTreeState(i, 0, false, "null") > 0)
                            {
                                update = true;
                            }
                        }
                    }
                    else
                    {
                        precnt = _treeIndexes.length;

                        var s = this._setTreeState(i, state, false, "null_value");
                        if (s == 2)
                        {
                            if ((_treeIndexes.length - precnt) > 0)
                                i += (_treeIndexes.length - precnt + 1);

                            update = true;
                        }
                        else if (s == 1)
                        {
                            update = true;
                        }
                    }
                }
            }
            if (update == true)
            {
                this._recreate_contents_all(false, false, true);
            }
        }
        else
        {
            update = false;

            if (!expand)
            {
                for (i = _treeIndexes.length - 1; i >= 0; i--)
                {
                    if (this._setTreeState(i, 0, false, "all") > 0)
                    {
                        update = true;
                    }
                }

                for (i = _treeStates.length - 1; i >= 0; i--)   // 위 loop와 length가 다름.
                {
                    state = this._getOrgTreeStates(i);  // all일 경우 원래 leaf인 경우엔 leaf로 다시 설정.

                    if (state == 2)
                        _treeStates[i] = 2;
                }
            }
            else
            {
                for (i = 0; i < _treeIndexes.length; i++)
                {
                    if (this._setTreeState(i, 1, false, "all") > 0)
                    {
                        update = true;
                    }
                }
            }

            if (update == true)
            {
                if (this._p_autosizingtype == "col" || this._p_autosizingtype == "both")
                    this._recreate_contents_all(true, false);
                else
                    this._recreate_contents_all(false, false, true);
            }
        }
    };

    _pGrid.set_treepathdelimiter = function (v)
    {
        if (this._p_treepathdelimiter != v)
        {
            this._p_treepathdelimiter = v;
        }
    };

    _pGrid.set_useinputpanel = function (v)
    {
        if (this._p_useinputpanel != v)
        {
            this._p_useinputpanel = v;
        }
    };

    _pGrid.set_usesoftkeyboard = function (v)
    {
        v = nexacro._toBoolean(v);
        if (v != this._p_usesoftkeyboard)
        {
            this._p_usesoftkeyboard = v;

            if (!this._initsoftkeyboard)
                this._initsoftkeyboard = true;
        }
    };

    _pGrid.on_apply_prop_enable = function (v)
    {
        this._enable = v;
        nexacro.Component.prototype.on_apply_prop_enable.call(this, v);

        if (this._is_created)
        {
            var band = this._headBand;
            if (band)
                band._setEnable(v);
            band = this._bodyBand;
            if (band)
                band._setEnable(v);
            band = this._summBand;
            if (band)
                band._setEnable(v);

            var groupbar = this._groupBar;
            if (groupbar)
                groupbar._setEnable(v);
        }
    };

    _pGrid.on_apply_prop_rtl = function ()
    {
        nexacro.Component.prototype.on_apply_prop_rtl.call(this);
        this._refreshAll();
    };

    _pGrid.on_apply_prop_stringresource = function ()
    {
        if (!nexacro._StringResource)
            return;

        nexacro.Component.prototype.on_apply_prop_stringresource.call(this);

        this.on_apply_nodatatext(this._getStringResourceProperty(this._p_nodatatext));

        this._recreate_contents_all();
    };

    _pGrid.set_createrowstype = function (type)
    {
        type = type ? type.toString() : "";
        if (type != this._p_createrowstype)
        {
            switch (type)
            {
                case "auto":
                case "all":
                    this._p_createrowstype = type;
                    break;
                default:
                    break;
            }
        }
    };

    //==============================================================================
    // nexacro.Grid : Methods
    //==============================================================================
    _pGrid.createFormat = function ()
    {
        var pDataset = this._binddataset;
        var i;
        var nColCount = 0;

        if (pDataset)
        {
            nColCount = pDataset.getColCount();
            this._rowcount = pDataset._p_rowcount;	// rowcount property set
            this._applyPageRowCount();
            this._rowposition = pDataset.rowposition;
            //this._initSelect(this._rowposition);
        }

        var strContents;

        if (nColCount > 0)
        {
            strContents = "<Formats>\n";
            strContents += "<Format id=\"default\">\n";
            strContents += "<Columns>\n";
            {
                for (i = 0; i < nColCount; i++)
                {
                    strContents += "<Column size=\"";
                    strContents += "80";
                    strContents += "\"/>\n";
                }
            }
            strContents += "</Columns>\n";
            strContents += "<Rows>\n";
            {
                strContents += "<Row band=\"head\" size=\"";
                strContents += "24";
                strContents += "\"/>\n";
                strContents += "<Row band=\"body\" size=\"";
                strContents += "24";
                strContents += "\"/>\n";
            }
            strContents += "</Rows>\n";
            strContents += "<Band id=\"head\">\n";
            {
                for (i = 0; i < nColCount; i++)
                {
                    strContents += "<Cell col=\"";
                    strContents += i.toString();
                    strContents += "\" displaytype=\"normal\" text=\"";
                    strContents += pDataset.getColID(i);
                    strContents += "\"/>\n";
                }
            }
            strContents += "</Band>\n";
            strContents += "<Band id=\"body\">\n";
            {
                for (i = 0; i < nColCount; i++)
                {
                    strContents += "<Cell col=\"";
                    strContents += i.toString();
                    strContents += "\" displaytype=\"normal\" text=\"bind:";
                    strContents += pDataset.getColID(i);
                    strContents += "\"/>\n";
                }
            }
            strContents += "</Band>\n";
            strContents += "</Format>\n";
            strContents += "</Formats>\n";
        }
        else
        {
            strContents = "<Formats>\n";
            strContents += "<Format id=\"default\">\n";
            strContents += "</Format>\n";
            strContents += "</Formats>\n";
        }

        this.set_formats(strContents);
        return 0;
    };

    _pGrid.setFormat = function (id)
    {
        var format = this._formats[id];

        if (format)
        {
            if (format != this._curFormat)
            {
                this.set_formatid(id);
                return true;
            }
        }
        else
        {
            this._p_formatid = "";
            this._curFormat = null;
            this._clearTempBand();
            this._clearBindTypeFlag();
            this._destroyBands();
        }
        return false;
    };

    _pGrid.getFormatString = function ()
    {
        return this._p_formats;
    };

    _pGrid.getCurFormatString = function (bOrginal)
    {
        if (this._curFormat)
        {
            if (bOrginal)
                return this._curFormat._getOrgFormatStr();
            else
                return this._curFormat._getFormatStr();
        }
        else
        {
            return this._p_formats;
        }
    };

    _pGrid.getFormatIdList = function ()
    {
        if (!this._format_str)
            return [];

        var list = [];

        list = list.concat(this._format_str);
        return list;
    };

    _pGrid.getCellPos = function ()
    {
        return this._selectinfo.curcell;
    };

    _pGrid.setCellPos = function (nCellIdx, nRowIdx)
    {
        if (nRowIdx >= 0)
            return this._moveToPosCell(nRowIdx, nCellIdx);
        else
            return this._moveToPosCell(this._selectinfo.curdsrow, nCellIdx);
    };

    _pGrid.getCellCount = function (strBand)
    {
        if (!this._curFormat)
            return 0;

        strBand = strBand.toLowerCase();
        var cells;
        if (strBand == "head")
            cells = this._curFormat._headcells;
        else if (strBand == "summ" || strBand == "summary")
            cells = this._curFormat._summcells;
        else
            cells = this._curFormat._bodycells;

        if (cells)
        {
            return cells.length;
        }
        return 0;
    };

    _pGrid.getCellRect = function (nRow, nCellIdx, nPivotIdx)
    {
        return this.getSubCellRect(nRow, nCellIdx, -1, nPivotIdx);
    };

    _pGrid.getSubCellRect = function (nRow, nCellIdx, nSubCellIdx, nPivotIdx)
    {
        return this._getSubCellRect(nRow, nCellIdx, nSubCellIdx, nPivotIdx, true);
    };

    _pGrid._getSubCellRect = function (nRow, nCellIdx, nSubCellIdx, nPivotIdx, bApplyScroll)
    {
        var rect = { "left": 0, "top": 0, "right": 0, "bottom": 0, "width": 0, "height": 0 };
        rect.left = 0;
        rect.top = 0;
        rect.right = 0;
        rect.bottom = 0;
        rect.width = 0;
        rect.height = 0;

        var cellinfo;
        var k, i, j;
        var size;
        var top;
        var left;
        var right;
        var bottom;
        var _cols;
        var cellinfo_row;
        var cellinfo_col;
        var cellinfo_rowspan;
        var cellinfo_colspan;

        if (nRow >= 0 && nRow < this._rowcount)
        {
            if (this._curFormat && this._curFormat._bodycells)
            {
                var parentinfo = null;
                cellinfo = this._curFormat._bodycells[nCellIdx];

                if (cellinfo && nSubCellIdx >= 0)
                {
                    parentinfo = cellinfo;
                    cellinfo = cellinfo._subcells[nSubCellIdx];
                }
                if (cellinfo)
                {
                    bottom = this._getHeadHeight();
                    _cols = this._curFormat._cols;

                    if (this._p_summarytype == "top" || this._p_summarytype == "lefttop")
                        bottom += this._getSummHeight();

                    if (this._p_showgroupbar)
                        bottom += this._groupbarheight;

                    var bodyrows = this._curFormat._bodyrows;
                    var rowcnt = bodyrows.length;
                    var rowcount = this._getGridRowCount();
                    cellinfo_row = (parentinfo) ? parentinfo._row + cellinfo._row : cellinfo._row;
                    cellinfo_col = (parentinfo) ? parentinfo._col + cellinfo._col : cellinfo._col;
                    cellinfo_rowspan = cellinfo._rowspan;
                    cellinfo_colspan = cellinfo._colspan;
                    var _rowSizeListSub = this._rowSizeListSub;
                    var row;

                    for (i = 0; i < rowcount; i++)
                    {
                        row = i;
                        if (this._hasTree)
                            row = this._treeIndexes[row];

                        var r = row * rowcnt;

                        if (row == nRow)
                        {
                            for (k = 0; k < cellinfo_row; k++)
                            {
                                bottom += _rowSizeListSub[r++];
                            }
                            top = bottom;

                            for (j = 0; j < cellinfo_rowspan; j++)
                            {
                                bottom += _rowSizeListSub[r++];
                            }
                            break;
                        }
                        else
                        {
                            for (var jj = 0; jj < rowcnt; jj++)
                            {
                                bottom += _rowSizeListSub[r + jj];
                            }
                        }
                    }

                    size = 0;
                    for (i = 0; i < cellinfo_col; i++)
                        size += _cols[i].getSize();

                    left = size;
                    size = 0;

                    for (i = 0; i < cellinfo_col + cellinfo_colspan; i++)
                        size += _cols[i].getSize();

                    right = size;

                    if (cellinfo._area == "body" || cellinfo._area == "")   // "" subcell
                    {
                        left -= this._getScrollLeft();
                        right -= this._getScrollLeft();
                    }

                    top -= this._getScrollTop();
                    bottom -= this._getScrollTop();

                    if (bApplyScroll)
                    {
                        if (left < 0) left = 0;
                        if (right < 0) right = 0;
                        if (top < 0) top = 0;
                        if (bottom < 0) bottom = 0;
                    }

                    rect.left = left;
                    rect.right = right;
                    rect.top = top;
                    rect.bottom = bottom;
                    rect.width = right - left;
                    rect.height = bottom - top;
                }
            }
        }
        else if (nRow == -1)
        {
            if (this._curFormat && this._curFormat._headcells)
            {
                cellinfo = this._curFormat._headcells[nCellIdx];

                if (cellinfo && nSubCellIdx >= 0)
                    cellinfo = cellinfo._subcells[nSubCellIdx];

                if (cellinfo)
                {
                    bottom = 0;
                    _cols = this._curFormat._cols;

                    var headrows = this._curFormat._headrows;
                    //                    rowcnt = headrows.length;
                    cellinfo_row = cellinfo._row;
                    cellinfo_col = cellinfo._col;
                    cellinfo_rowspan = cellinfo._rowspan;
                    cellinfo_colspan = cellinfo._colspan;

                    for (k = 0; k < cellinfo_row; k++)
                    {
                        bottom += headrows[k].size;
                    }

                    top = bottom;

                    for (k = 0; k < cellinfo_rowspan; k++)
                    {
                        bottom += headrows[k + cellinfo_row].size;
                    }

                    size = 0;
                    for (i = 0; i < cellinfo_col; i++)
                        size += _cols[i].getSize();

                    left = size;
                    size = 0;

                    for (i = 0; i < cellinfo_col + cellinfo_colspan; i++)
                        size += _cols[i].getSize();

                    right = size;

                    if (cellinfo._area == "body" || cellinfo._area == "")   // "" subcell
                    {
                        left -= this._getScrollLeft();
                        right -= this._getScrollLeft();
                    }
                    if (bApplyScroll)
                    {
                        if (left < 0) left = 0;
                        if (right < 0) right = 0;
                    }

                    rect.left = left;
                    rect.right = right;
                    rect.top = top;
                    rect.bottom = bottom;
                    rect.width = right - left;
                    rect.height = bottom - top;
                }
            }
        }
        else if (nRow == -2)
        {
            if (this._curFormat && this._curFormat._summcells)
            {
                cellinfo = this._curFormat._summcells[nCellIdx];

                if (cellinfo && nSubCellIdx >= 0)
                    cellinfo = cellinfo._subcells[nSubCellIdx];

                if (cellinfo)
                {
                    bottom = 0;
                    _cols = this._curFormat._cols;

                    if (this._p_summarytype == "top" || this._p_summarytype == "lefttop")
                    {
                        if (this._p_showgroupbar)
                            bottom += this._groupbarheight;

                        bottom += this._getHeadHeight();
                    }
                    else
                    {
                        bottom = this._getClientTop() + this._getClientHeight() - this._getSummHeight();
                    }

                    var summrows = this._curFormat._summrows;
                    cellinfo_row = cellinfo._row;
                    cellinfo_col = cellinfo._col;
                    cellinfo_rowspan = cellinfo._rowspan;
                    cellinfo_colspan = cellinfo._colspan;

                    for (k = 0; k < cellinfo_row; k++)
                    {
                        bottom += summrows[k].size;
                    }

                    top = bottom;

                    for (k = 0; k < cellinfo_rowspan; k++)
                    {
                        bottom += summrows[k + cellinfo_row].size;
                    }

                    size = 0;
                    for (i = 0; i < cellinfo_col; i++)
                        size += _cols[i].getSize();

                    left = size;
                    size = 0;

                    for (i = 0; i < cellinfo_col + cellinfo_colspan; i++)
                        size += _cols[i].getSize();

                    right = size;

                    if (cellinfo._area == "body" || cellinfo._area == "")   // "" subcell
                    {
                        left -= this._getScrollLeft();
                        right -= this._getScrollLeft();
                    }
                    if (bApplyScroll)
                    {
                        if (left < 0) left = 0;
                        if (right < 0) right = 0;
                    }
                    rect.left = left;
                    rect.right = right;
                    rect.top = top;
                    rect.bottom = bottom;
                    rect.width = right - left;
                    rect.height = bottom - top;
                }
            }
        }
        return rect;
    };

    _pGrid.getCellText = function (nRow, nCellIdx, nPivotIdx)
    {
        var cellinfo;
        if (nRow >= 0)
        {
            if (this._curFormat && this._curFormat._bodycells)
            {
                cellinfo = this._curFormat._bodycells[nCellIdx];
                if (cellinfo)
                {
                    if (this._hasTree)
                    {
                        if (nRow < this._treeIndexes.length)
                        {
                            nRow = this._treeIndexes[nRow];
                            return cellinfo._getDisplayText(nRow);
                        }
                    }
                    else
                    {
                        if (nRow < this._rowcount)
                            return cellinfo._getDisplayText(nRow);
                    }
                }
            }
        }
        else if (nRow == -1)
        {
            if (this._curFormat && this._curFormat._headcells)
            {
                cellinfo = this._curFormat._headcells[nCellIdx];
                if (cellinfo)
                {
                    return cellinfo._getDisplayText(this._currentDSrow);
                }
            }
        }
        else if (nRow == -2)
        {
            if (this._curFormat && this._curFormat._summcells)
            {
                cellinfo = this._curFormat._summcells[nCellIdx];
                if (cellinfo)
                {
                    return cellinfo._getDisplayText(this._currentDSrow);
                }
            }
        }
    };

    _pGrid.getCellValue = function (nRow, nCellIdx, nPivotIdx)
    {
        if (nPivotIdx == undefined)
            nPivotIdx = 0;

        var cellinfo;
        if (nRow >= 0)
        {
            if (this._curFormat && this._curFormat._bodycells)
            {
                cellinfo = this._curFormat._bodycells[nCellIdx];
                if (cellinfo)
                {
                    if (this._hasTree)
                    {
                        if (nRow < this._treeIndexes.length)
                        {
                            nRow = this._treeIndexes[nRow];
                            return cellinfo._getValue(nRow, true);
                        }
                    }
                    else
                    {
                        if (nRow < this._rowcount)
                            return cellinfo._getValue(nRow, true);
                    }
                }
            }
        }
        else if (nRow == -1)
        {
            if (this._curFormat && this._curFormat._headcells)
            {
                cellinfo = this._curFormat._headcells[nCellIdx];
                if (cellinfo)
                {
                    return cellinfo._getValue(this._currentDSrow, true);
                }
            }
        }
        else if (nRow == -2)
        {
            if (this._curFormat && this._curFormat._summcells)
            {
                cellinfo = this._curFormat._summcells[nCellIdx];
                if (cellinfo)
                {
                    return cellinfo._getValue(this._currentDSrow, true);
                }
            }
        }
    };

    _pGrid.getSubCellCount = function (strBand, nCellIdx)
    {
        var format = this._curFormat;
        strBand = strBand.toLowerCase();

        if (format)
        {
            var cells;
            if (strBand == "head")
            {
                cells = format._headcells;
            }
            else if (strBand == "summ" || strBand == "summary")
            {
                cells = format._summcells;
            }
            else
            {
                cells = format._bodycells;
            }
            if (cells && cells.length > nCellIdx && nCellIdx >= 0)
            {
                var cell = cells[nCellIdx];
                return cell._subcells.length;
            }
        }
        return 0;
    };

    _pGrid.getSubCellProperty = function (strBand, nCellIdx, nSubCellIdx, strPropID)
    {
        var format = this._curFormat;

        if (!format)
            return undefined;

        return format.getSubCellProperty(strBand, nCellIdx, nSubCellIdx, strPropID);
    };

    _pGrid.getSubCellText = function (nRow, nCellIdx, nSubCellIdx, nPivotIdx)
    {
        var cellinfo;
        if (nRow >= 0)
        {
            if (this._curFormat && this._curFormat._bodycells)
            {
                if (nCellIdx >= 0 && nCellIdx < this._curFormat._bodycells.length)
                {
                    cellinfo = this._curFormat._bodycells[nCellIdx];
                    if (cellinfo && nSubCellIdx >= 0 && nSubCellIdx < cellinfo._subcells.length)
                    {
                        if (this._hasTree)
                        {
                            if (nRow < this._treeIndexes.length)
                            {
                                nRow = this._treeIndexes[nRow];
                                return cellinfo._subcells[nSubCellIdx]._getDisplayText(nRow);
                            }
                        }
                        else
                        {
                            if (nRow < this._rowcount)
                                return cellinfo._subcells[nSubCellIdx]._getDisplayText(nRow);
                        }
                    }
                }
            }
        }
        else if (nRow == -1)
        {
            if (this._curFormat && this._curFormat._headcells)
            {
                cellinfo = this._curFormat._headcells[nCellIdx];
                if (cellinfo && nSubCellIdx >= 0 && nSubCellIdx < cellinfo._subcells.length)
                {
                    return cellinfo._subcells[nSubCellIdx]._getDisplayText(this._currentDSrow);
                }
            }
        }
        else if (nRow == -2)
        {
            if (this._curFormat && this._curFormat._summcells)
            {
                cellinfo = this._curFormat._summcells[nCellIdx];
                if (cellinfo && nSubCellIdx >= 0 && nSubCellIdx < cellinfo._subcells.length)
                {
                    return cellinfo._subcells[nSubCellIdx]._getDisplayText(this._currentDSrow);
                }
            }
        }
    };

    _pGrid.getSubCellValue = function (nRow, nCellIdx, nSubCellIdx, nPivotIdx)
    {
        var cellinfo;
        if (nRow >= 0)
        {
            if (this._curFormat && this._curFormat._bodycells)
            {
                if (nCellIdx >= 0 && nCellIdx < this._curFormat._bodycells.length)
                {
                    cellinfo = this._curFormat._bodycells[nCellIdx];
                    if (cellinfo && nSubCellIdx >= 0 && nSubCellIdx < cellinfo._subcells.length)
                    {
                        if (this._hasTree)
                        {
                            if (nRow < this._treeIndexes.length)
                            {
                                nRow = this._treeIndexes[nRow];
                                return cellinfo._subcells[nSubCellIdx]._getValue(nRow);
                            }
                        }
                        else
                        {
                            if (nRow < this._rowcount)
                                return cellinfo._subcells[nSubCellIdx]._getValue(nRow);
                        }
                    }
                }
            }
        }
        else if (nRow == -1)
        {
            if (this._curFormat && this._curFormat._headcells)
            {
                cellinfo = this._curFormat._headcells[nCellIdx];
                if (cellinfo && nSubCellIdx >= 0 && nSubCellIdx < cellinfo._subcells.length)
                {
                    return cellinfo._subcells[nSubCellIdx]._getValue(this._currentDSrow);
                }
            }
        }
        else if (nRow == -2)
        {
            if (this._curFormat && this._curFormat._summcells)
            {
                cellinfo = this._curFormat._summcells[nCellIdx];
                if (cellinfo && nSubCellIdx >= 0 && nSubCellIdx < cellinfo._subcells.length)
                {
                    return cellinfo._subcells[nSubCellIdx]._getValue(this._currentDSrow);
                }
            }
        }
    };

    _pGrid.setSubCellProperty = function (strBand, nCellIdx, nSubCellIdx, strPropID, varValue)
    {
        var format = this._curFormat;

        if (!format)
            return false;

        var cellinfo = format.setSubCellProperty(strBand, nCellIdx, nSubCellIdx, strPropID, varValue);
        if (cellinfo)
        {
            this._refreshCell(strBand, nCellIdx, -1, strPropID, nSubCellIdx);
        }

        return (cellinfo != null);
    };

    _pGrid.setFormatColProperty = function (nColIdx, strPropID, nValue)
    {
        if (strPropID && this._curFormat)
        {
            strPropID = strPropID.toLowerCase();
            if (this._curFormat.setFormatColProperty(nColIdx, strPropID, nValue))
            {
                this._clearBindTypeFlag();

                // TODO 넓이만 조정토록
                if (strPropID == "band")
                {
                    this._autofitcol_rate = [];
                    this._recreate();
                }
                else if (strPropID == "size")
                {
                    this._is_user_change_colsize = true;

                    if (this._p_enableredraw)
                    {
                        this._updateColSize(nColIdx);
                    }
                    else
                    {
                        this._autofitcol_rate = [];
                        if (!this._enable_redraw_history.updatecolsize)
                            this._enable_redraw_history.updatecolsize = [];

                        this._enable_redraw_history.updatecolsize.push(nColIdx);
                    }
                    this._is_user_change_colsize = false;
                }
                else if (strPropID == "visible")
                {
                    if (nValue && this._p_autofittype != "none")
                    {
                        this._autofitcol_rate = [];
                        this._applyAutofittype(true);
                    }
                    else
                    {
                        this._recreate_contents_all(false, false);
                    }
                }
                else
                {
                    this._recreate_contents_all(false, false);
                }
                return true;
            }
        }
        return false;
    };

    _pGrid.setFormatRowProperty = function (nRowIdx, strPropID, nValue)
    {
        if (strPropID && this._curFormat)
        {
            strPropID = strPropID.toLowerCase();
            if (this._curFormat.setFormatRowProperty(nRowIdx, strPropID, nValue))
            {
                this._clearBindTypeFlag();

                if (strPropID == "band" || strPropID == "size")
                {
                    this._is_user_change_head_rowsize = false;
                    this._is_user_change_body_rowsize = false;
                    this._is_user_change_summ_rowsize = false;
                    this._recreate();
                }
                else
                {
                    this._recreate_contents_all(false, false);
                }
                return true;
            }
        }
        return false;
    };

    _pGrid.getFormatColProperty = function (nCollIdx, strPropId)
    {
        if (this._curFormat)
            return this._curFormat.getFormatColProperty(nCollIdx, strPropId);

        return null;
    };

    _pGrid.getFormatRowProperty = function (nRowIdx, strPropId)
    {
        if (this._curFormat)
            return this._curFormat.getFormatRowProperty(nRowIdx, strPropId);

        return null;
    };

    _pGrid.getFormatColCount = function ()
    {
        if (this._curFormat)
        {
            return this._curFormat._cols.length;
        }
        return 0;
    };

    _pGrid.getFormatRowCount = function ()
    {
        if (this._curFormat)
        {
            var format = this._curFormat;
            var rowcnt = 0;

            if (format._headrows)
                rowcnt += format._headrows.length;
            if (format._bodyrows)
                rowcnt += format._bodyrows.length;
            if (format._summrows)
                rowcnt += format._summrows.length;

            return rowcnt;
        }
        return 0;
    };

    _pGrid.getFormatColSize = function (nColIdx)
    {
        if (this._curFormat)
        {
            if (this._curFormat._cols.length > 0 && this._curFormat._cols.length > nColIdx)
            {
                var col = this._curFormat._cols[nColIdx];
                if (col)
                    return col.orgsize;
            }
        }
        return -1;
    };

    _pGrid.getFormatRowSize = function (nRowIdx)
    {
        if (this._curFormat)
        {
            if (nRowIdx < 0) return -1;

            var top = 0;
            var rows = this._curFormat._headrows;
            var row;

            if (rows)
            {
                if (rows.length > nRowIdx)
                {
                    row = rows[nRowIdx];
                    return row.orgsize;
                }
                top += rows.length;
            }

            if (this._p_summarytype == "top" || this._p_summarytype == "lefttop")
            {
                rows = this._curFormat._summrows;
                if (rows)
                {
                    if (rows.length + top > nRowIdx)
                    {
                        row = rows[nRowIdx - top];
                        return row.orgsize;
                    }
                    top += rows.length;
                }
                rows = this._curFormat._bodyrows;
                if (rows)
                {
                    if (rows.length + top > nRowIdx)
                    {
                        row = rows[nRowIdx - top];
                        return row.orgsize;
                    }
                }
            }
            else
            {
                rows = this._curFormat._bodyrows;
                if (rows)
                {
                    if (rows.length + top > nRowIdx)
                    {
                        row = rows[nRowIdx - top];
                        return row.orgsize;
                    }
                    top += rows.length;
                }
                rows = this._curFormat._summrows;
                if (rows)
                {
                    if (rows.length + top > nRowIdx)
                    {
                        row = rows[nRowIdx - top];
                        return row.orgsize;
                    }
                }
            }
        }
        return -1;
    };

    _pGrid._isUserChangeHeadRowSize = false;
    _pGrid._isUserChangeBodyRowSize = false;
    _pGrid._isUserChangeSummRowSize = false;
    _pGrid._isUserChangeColSize = false;

    _pGrid.setRealColSize = function (enumband, nColIndex, nSize, bBandIndex)
    {
        this._is_user_change_colsize = true;

        var ret = false;
        if (enumband && bBandIndex)
            ret = this._setColSize(enumband, nColIndex, nSize, true, true);
        else
            ret = this._setColSize(-9, nColIndex, nSize, false, true);

        this._is_user_change_colsize = false;
        return ret;

    };

    _pGrid.setRealRowSize = function (nRowIndex, nSize, nSubRowIndex, bBandIndex)
    {
        var format = this._curFormat;

        if (bBandIndex == undefined)
            bBandIndex = true;

        var band = "none";
        if (bBandIndex)
        {
            if (nRowIndex >= 0)
            {
                band = "body";
            }
            else if (nRowIndex == -1)
            {
                band = "head";
            }
            else if (nRowIndex == -2)
            {
                band = "summ";
            }
        }
        else
        {
            if (format._headrows)
            {
                if (nRowIndex < format._headrows.length)
                {
                    band = "head";
                }
                else
                {
                    nRowIndex -= format._headrows.length;
                }
            }

            if (band == "none")
            {
                if (this._p_summarytype == "top" || this._p_summarytype == "lefttop")
                {
                    if (format._summrows)
                    {
                        if (nRowIndex < format._summrows.length)
                        {
                            band = "summ";
                        }
                        else
                        {
                            nRowIndex -= format._headrows.length;
                        }
                    }
                    if (band == "none")
                    {
                        band = "body";
                    }
                }
                else
                {
                    if (format._bodyrows)
                    {
                        var length = (this._hasTree) ? this._treeIndexes.length : this._rowcount;
                        if (nRowIndex < length)
                        {
                            band = "body";
                        }
                        else
                        {
                            nRowIndex -= length;
                        }
                    }
                    if (band == "none")
                    {
                        if (format._summrows)
                        {
                            if (nRowIndex < format._summrows.length)
                                band = "summ";
                        }
                    }
                }
            }
        }

        var change = false;
        var index, oldsize, newsize;
        var rows;
        var rowsLen;
        var _rowSizeList;
        var _rowSizeListSub;
        var i;

        if (band == "body")
        {
            if (format && format._bodyrows)
            {
                var nRow = nRowIndex;
                if (this._hasTree)
                {
                    if (nRow >= this._treeIndexes.length)
                        return false;

                    nRow = this._treeIndexes[nRow];
                }
                else
                {
                    if (nRow >= this._rowcount)
                        return false;
                }

                rows = format._bodyrows;
                rowsLen = rows.length;
                _rowSizeList = this._rowSizeList;
                _rowSizeListSub = this._rowSizeListSub;

                if (nSubRowIndex >= 0)
                {
                    if (nSubRowIndex < rowsLen)
                    {
                        this._is_variable_bodyrowsize = true;

                        index = (nRow * rowsLen) + nSubRowIndex;
                        oldsize = _rowSizeListSub[index];
                        newsize = nSize;

                        if (oldsize != newsize)
                        {
                            _rowSizeListSub[index] = newsize;
                            _rowSizeList[nRow] += (newsize - oldsize);
                            change = true;

                            this._updateRowSizeExtendEx(format._bodyrows, _rowSizeList, _rowSizeListSub, nRow, true);

                            if (this._p_enableredraw)
                            {
                                if (this._p_extendsizetype != "row" && this._p_extendsizetype != "both")
                                {
                                    if (this._isDownActionKeyMouse())
                                    {
                                        nexacro._OnceCallbackTimer.callonce(this, function ()
                                        {
                                            if (this._bodyBand)
                                                this._bodyBand._recreate_contents();
                                        });
                                    }
                                    else
                                    {
                                        if (this._bodyBand)
                                            this._bodyBand._recreate_contents();
                                    }
                                }
                                else
                                {
                                    this._updateRowSize(nRowIndex, nSubRowIndex);
                                }
                            }
                            else
                            {
                                if (this._p_extendsizetype != "row" && this._p_extendsizetype != "both")
                                {
                                    this._enable_redraw_history.recreate_body = true;
                                }
                                else
                                {
                                    if (!this._enable_redraw_history.updaterowsize)
                                        this._enable_redraw_history.updaterowsize = [];

                                    this._enable_redraw_history.updaterowsize.push([nRowIndex, nSubRowIndex]);
                                }
                            }
                            this._is_user_change_body_rowsize = true;
                        }
                    }
                    else
                    {
                        return false;
                    }
                }
                else
                {
                    if (nRow < _rowSizeList.length)
                    {
                        this._is_variable_bodyrowsize = true;

                        for (i = 0; i < rowsLen; i++)
                        {
                            index = (nRow * rowsLen) + i;
                            oldsize = _rowSizeListSub[index];
                            newsize = nSize;

                            if (oldsize != newsize)
                            {
                                _rowSizeListSub[index] = newsize;
                                _rowSizeList[nRow] += (newsize - oldsize);
                                change = true;
                            }
                        }

                        if (change)
                        {
                            this._updateRowSizeExtendEx(format._bodyrows, _rowSizeList, _rowSizeListSub, nRow, true);
                            this._is_user_change_body_rowsize = true;
                            if (this._p_enableredraw)
                            {
                                if (this._isDownActionKeyMouse())
                                {
                                    nexacro._OnceCallbackTimer.callonce(this, function ()
                                    {
                                        if (this._bodyBand)
                                            this._bodyBand._recreate_contents();
                                    });
                                }
                                else
                                {
                                    if (this._bodyBand)
                                        this._bodyBand._recreate_contents();
                                }
                            }
                            else
                            {
                                this._enable_redraw_history.recreate_body = true;
                            }

                        }
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }
        else if (band == "head")
        {
            if (format && format._headrows)
            {
                rows = format._headrows;
                rowsLen = rows.length;
                _rowSizeList = this._rowHeadList;
                _rowSizeListSub = this._rowHeadListSub;

                if (nSubRowIndex >= 0)
                {
                    if (nSubRowIndex < rowsLen)
                    {
                        index = nSubRowIndex;
                        oldsize = _rowSizeListSub[index];
                        newsize = nSize;

                        if (oldsize != newsize)
                        {
                            _rowSizeListSub[index] = newsize;
                            _rowSizeList[0] += (newsize - oldsize);
                            change = true;
                            this._updateRowSizeExtendEx(format._headrows, _rowSizeList, _rowSizeListSub, 0);
                        }
                    }
                    else
                    {
                        return false;
                    }
                }
                else
                {
                    for (i = 0; i < rowsLen; i++)
                    {
                        index = i;
                        oldsize = _rowSizeListSub[index];
                        newsize = nSize;

                        if (oldsize != newsize)
                        {
                            _rowSizeListSub[index] = newsize;
                            _rowSizeList[0] += (newsize - oldsize);
                            change = true;
                        }
                    }

                    if (change == true)
                        this._updateRowSizeExtendEx(format._headrows, _rowSizeList, _rowSizeListSub, 0);
                }

                if (change)
                {
                    if (this._p_enableredraw)
                    {
                        if (this._isDownActionKeyMouse())
                        {
                            nexacro._OnceCallbackTimer.callonce(this, function ()
                            {
                                if (this._headBand)
                                    this._headBand._recreate_contents();

                                this._resizeBand();
                            });
                        }
                        else
                        {
                            if (this._headBand)
                                this._headBand._recreate_contents();

                            this._resizeBand();
                        }
                    }
                    else
                    {
                        this._enable_redraw_history.recreate_head = true;
                        this._enable_redraw_history.resize_band = true;
                    }
                    this._is_user_change_head_rowsize = true;
                }
            }
        }
        else if (band == "summ")
        {
            if (format && format._summrows)
            {
                rows = format._summrows;
                rowsLen = rows.length;
                _rowSizeList = this._rowSummList;
                _rowSizeListSub = this._rowSummListSub;

                if (nSubRowIndex >= 0)
                {
                    if (nSubRowIndex < rowsLen)
                    {
                        index = nSubRowIndex;
                        oldsize = _rowSizeListSub[index];
                        newsize = nSize;

                        if (oldsize != newsize)
                        {
                            _rowSizeListSub[index] = newsize;
                            _rowSizeList[0] += (newsize - oldsize);
                            change = true;
                            this._updateRowSizeExtendEx(format._summrows, _rowSizeList, _rowSizeListSub, 0);
                        }
                    }
                    else
                    {
                        return false;
                    }
                }
                else
                {
                    for (i = 0; i < rowsLen; i++)
                    {
                        index = i;
                        oldsize = _rowSizeListSub[index];
                        newsize = nSize;

                        if (oldsize != newsize)
                        {
                            _rowSizeListSub[index] = newsize;
                            _rowSizeList[0] += (newsize - oldsize);
                            change = true;
                        }
                    }

                    if (change == true)
                        this._updateRowSizeExtendEx(format._summrows, _rowSizeList, _rowSizeListSub, 0);
                }

                if (change == true)
                {
                    if (this._p_enableredraw)
                    {
                        if (this._isDownActionKeyMouse())
                        {
                            nexacro._OnceCallbackTimer.callonce(this, function ()
                            {
                                if (this._summBand)
                                    this._summBand._recreate_contents();

                                this._resizeBand();
                            });
                        }
                        else
                        {
                            if (this._summBand)
                                this._summBand._recreate_contents();

                            this._resizeBand();
                        }
                    }
                    else
                    {
                        this._enable_redraw_history.recreate_summ = true;
                        this._enable_redraw_history.resize_band = true;
                    }
                    this._is_user_change_summ_rowsize = true;
                }
            }
        }

        if (change)
            this._resetScrollMax();

        return change;
    };

    _pGrid.getRealColSize = function (/*nPivotIndex,*/ nColIndex, bBandIndex)
    {
        var format = this._curFormat;
        /*
        if (nColIndex == undefined)
        {
            nColIndex = nPivotIndex;
            nPivotIndex = -9;
        }
        else if (typeof (nColIndex) == "boolean")
        {
            bBandIndex = nColIndex;
            nColIndex = nPivotIndex;
            nPivotIndex = -9;
        }

        if (bBandIndex == undefined)
        {
            bBandIndex = true;
        }
        */
        var leftcnt = this._getColFixCnt("left");
        var bodycnt = this._getColFixCnt("body");
        //      var rightcnt = this._getColFixCnt("right");
        var _cols = format._cols;
        var _colsLen = _cols.length;

        //        var areatype = "body";

        if (bBandIndex == true)
        {
            //if (nPivotIndex >= 0)
            if (nColIndex >= 0)
            {
                nColIndex += leftcnt;
            }
            //else if (nPivotIndex == -2)
            else if (nColIndex == -2)
            {
                nColIndex += leftcnt;
                nColIndex += bodycnt;
            }

            if (_colsLen <= nColIndex)
            {
                return -1;
            }
        }
        return _cols[nColIndex].getSize();
    };

    _pGrid.getRealRowSize = function (nRowIndex, nSubRowIndex, bBandIndex)
    {
        var format = this._curFormat;

        if (bBandIndex == undefined)
        {
            bBandIndex = true;
        }
        var rows;
        var band = "none";

        if (bBandIndex)
        {
            if (nRowIndex >= 0)
            {
                band = "body";
            }
            else if (nRowIndex == -1)
            {
                band = "head";
            }
            else if (nRowIndex == -2)
            {
                band = "summ";
            }
        }
        else
        {
            if (format._headrows)
            {
                if (nRowIndex < format._headrows.length)
                {
                    band = "head";
                }
                else
                {
                    nRowIndex -= format._headrows.length;
                }
            }

            if (band == "none")
            {
                if (this._p_summarytype == "top" || this._p_summarytype == "lefttop")
                {
                    if (format._summrows)
                    {
                        if (nRowIndex < format._summrows.length)
                        {
                            band = "summ";
                        }
                        else
                        {
                            nRowIndex -= format._headrows.length;
                        }
                    }
                    if (band == "none")
                    {
                        band = "body";
                    }
                }
                else
                {
                    if (format._bodyrows)
                    {
                        var length = (this._hasTree) ? this._treeIndexes.length : this._rowcount;
                        if (nRowIndex < length)
                        {
                            band = "body";
                        }
                        else
                        {
                            nRowIndex -= length;
                        }
                    }
                    if (band == "none")
                    {
                        if (format._summrows)
                        {
                            if (nRowIndex < format._summrows.length)
                            {
                                band = "summ";
                            }
                        }
                    }
                }
            }
        }

        if (band == "body")
        {
            if (format && format._bodyrows)
            {
                var nRow = nRowIndex;
                if (this._hasTree)
                {
                    if (nRow >= this._treeIndexes.length)
                    {
                        return 0;
                    }
                    nRow = this._treeIndexes[nRow];
                }
                else
                {
                    if (nRow >= this._rowcount)
                    {
                        return 0;
                    }
                }

                rows = format._bodyrows;

                var _rowSizeListSub = this._rowSizeListSub;
                var _rowSizeList = this._rowSizeList;

                if (this._isLazyAutoVscroll())
                {
                    _rowSizeListSub = [];
                    _rowSizeList = [];

                    this._resetRowSizeListBodyRange(nRowIndex, nRowIndex, _rowSizeList, _rowSizeListSub);
                }

                if (nSubRowIndex >= 0)
                {
                    if (nSubRowIndex < rows.length)
                        return _rowSizeListSub[nRow * rows.length + nSubRowIndex];
                    else
                        return 0;
                }
                else
                {
                    if (nRow < _rowSizeList.length)
                        return _rowSizeList[nRow];
                    else
                        return 0;
                }
            }
        }
        else if (band == "head")
        {
            if (format && format._headrows)
            {
                rows = format._headrows;

                if (nSubRowIndex >= 0)
                {
                    if (nSubRowIndex < rows.length)
                        return this._rowHeadListSub[nSubRowIndex];
                    else
                        return 0;
                }
                else
                {
                    return this._rowHeadList[0];
                }
            }
        }
        else if (band == "summ")
        {
            if (format && format._summrows)
            {
                rows = format._summrows;

                if (nSubRowIndex >= 0)
                {
                    if (nSubRowIndex < rows.length)
                        return this._rowSummListSub[nSubRowIndex];
                    else
                        return 0;
                }
                else
                {
                    return this._rowSummList[0];
                }
            }
        }
        return 0;
    };

    _pGrid.getRealColFullSize = function (strBand)
    {
        var i, leftcnt, size = 0;
        var bodycnt;
        var rightcnt;

        if (!strBand)
        {
            leftcnt = this._getColFixCnt("left");
            for (i = 0; i < leftcnt; i++)
            {
                size += this.getRealColSize(i);
            }

            bodycnt = this._getColFixCnt("body");

            for (i = 0; i < bodycnt; i++)
            {
                size += this.getRealColSize(leftcnt + i);
            }

            rightcnt = this._getColFixCnt("right");
            for (i = 0; i < rightcnt; i++)
            {
                size += this.getRealColSize(leftcnt + bodycnt + i);
            }
        }
        else
        {
            strBand = strBand.toLowerCase();
            if (strBand == "left")
            {
                leftcnt = this._getColFixCnt("left");
                for (i = 0; i < leftcnt; i++)
                {
                    size += this.getRealColSize(i);
                }
            }
            else if (strBand == "body")
            {
                leftcnt = this._getColFixCnt("left");
                bodycnt = this._getColFixCnt("body");
                for (i = 0; i < bodycnt; i++)
                {
                    size += this.getRealColSize(leftcnt + i);
                }
            }
            else if (strBand == "right")
            {
                leftcnt = this._getColFixCnt("left");
                bodycnt = this._getColFixCnt("body");
                rightcnt = this._getColFixCnt("right");
                for (i = 0; i < rightcnt; i++)
                {
                    size += this.getRealColSize(leftcnt + bodycnt + i);
                }
            }
        }
        return size;
    };

    _pGrid.getRealRowFullSize = function (strBand)
    {
        var length;
        var i;
        var size;

        if (!strBand)
        {
            length = (this._hasTree) ? this._treeIndexes.length : this._rowcount;
            size = 0;

            for (i = 0; i < length; i++)
                size += this.getRealRowSize(i);

            size += this.getRealRowSize(-1);
            size += this.getRealRowSize(-2);
            return size;
        }
        else
        {
            strBand = strBand.toLowerCase();
            if (strBand == "body")
            {
                length = (this._hasTree) ? this._treeIndexes.length : this._rowcount;
                size = 0;
                for (i = 0; i < length; i++)
                    size += this.getRealRowSize(i);

                return size;
            }
            else if (strBand == "head")
            {
                return this.getRealRowSize(-1);
            }
            else if (strBand == "summ" || strBand == "summary")
            {
                return this.getRealRowSize(-2);
            }
        }
        return 0;
    };

    _pGrid.__createDefualtColFormat = function (band)
    {
        var strContents;

        strContents = "<Formats>\n";
        strContents += "<Format id=\"default\">\n";
        strContents += "<Columns>\n";
        strContents += "<Column size=\"40\"/>\n";
        strContents += "</Columns>\n";

        if (band == "head")
        {
            strContents += "<Rows>\n";
            strContents += "<Row size=\"24\" band=\"head\"/>";
            strContents += "</Rows>\n";
            strContents += "<Band id=\"head\">\n";
            strContents += "<Cell/>\n";
            strContents += "</Band>\n";
        }
        else if (band == "summ" || band == "summary")
        {
            strContents += "<Rows>\n";
            strContents += "<Row size=\"24\" band=\"summ\"/>";
            strContents += "</Rows>\n";
            strContents += "<Band id=\"summary\">\n";
            strContents += "<Cell/>\n";
            strContents += "</Band>\n";
        }
        else if (band == "body")
        {
            strContents += "<Rows>\n";
            strContents += "<Row size=\"24\" band=\"body\"/>";
            strContents += "</Rows>\n";
            strContents += "<Band id=\"body\">\n";
            strContents += "<Cell/>\n";
            strContents += "</Band>\n";
        }

        strContents += "</Format>\n";
        strContents += "</Formats>\n";

        this.set_formats(strContents);

        return 0;
    };

    _pGrid.appendContentsRow = function (strBand, bBandAppend)
    {
        if (!strBand)
        {
            strBand = "body";
        }

        if (typeof (strBand) == "number")
        {
            if (strBand == -1)
                strBand = "head";
            else if (strBand == -2)
                strBand = "summ";
            else if (strBand >= 0)
                strBand = "body";
        }

        strBand = strBand.toLowerCase();

        if (!this._curFormat)
        {
            return this.__createDefualtColFormat(strBand);
        }

        if (bBandAppend == undefined)
            bBandAppend = true;

        if (bBandAppend == false)
            strBand = this._getLastRowBand();

        this._clearGroup(true);

        var row = this._curFormat.appendContentsRow(strBand, bBandAppend);
        var rows;

        if (row >= 0)
        {
            this._clearTempBand();
            this._clearBindTypeFlag();
            this._initChecked();
            this._recreate();
            this._initSelect();

            if (strBand == "body" || strBand >= 0)
            {
                if (rows = this._curFormat._headrows)
                {
                    row += rows.length;
                }
                if (this._p_summarytype == "top" || this._p_summarytype == "lefttop")
                {
                    if (rows = this._curFormat._summrows)
                    {
                        row += rows.length;
                    }
                }
            }
            else if (strBand == "summ" || strBand == "summary" || strBand == -2)
            {
                if (rows = this._curFormat._headrows)
                {
                    row += rows.length;
                }
                if (this._p_summarytype != "top" && this._p_summarytype != "lefttop")
                {
                    if (rows = this._curFormat._bodyrows)
                    {
                        row += rows.length;
                    }
                }
            }
        }
        return row;
    };

    _pGrid.appendContentsCol = function (strBand, bBandAppend)
    {
        if (!this._curFormat || (!isNaN(parseInt(strBand)) && strBand < -2) || this.getFormatRowCount() == 0)
        {
            return -1;
        }

        this._autofitcol_rate = [];
        this._clearGroup(true);

        var col = this._curFormat.appendContentsCol(strBand, bBandAppend);

        if (col >= 0)
        {
            this._initChecked();
            this._clearTempBand();
            this._clearBindTypeFlag();
            this._recreate();
        }

        return col;
    };

    _pGrid.insertContentsRow = function (strBand, nSubRowIndex, bBandIndex)
    {
        if (!this._curFormat)
        {
            return -1;
        }

        if (arguments.length == 1)
        {
            nSubRowIndex = strBand;
            strBand = "body";
        }

        this._clearGroup(true);

        var row = this._curFormat.insertContentsRow(strBand, nSubRowIndex, bBandIndex);
        var rows;

        if (row >= 0)
        {
            this._initChecked();
            this._clearTempBand();
            this._clearBindTypeFlag();
            this._recreate();

            if (strBand == "body" || strBand >= 0)
            {
                if (rows = this._curFormat._headrows)
                {
                    row += rows.length;
                }
                if (this._p_summarytype == "top" || this._p_summarytype == "lefttop")
                {
                    if (rows = this._curFormat._summrows)
                    {
                        row += rows.length;
                    }
                }
            }
            else if (strBand == "summ" || strBand == "summary" || strBand == -2)
            {
                if (rows = this._curFormat._headrows)
                {
                    row += rows.length;
                }
                if (this._p_summarytype != "top" && this._p_summarytype != "lefttop")
                {
                    if (rows = this._curFormat._bodyrows)
                    {
                        row += rows.length;
                    }
                }
            }
        }
        return row;
    };

    _pGrid.insertContentsCol = function (strBand, nColIndex, bBandIndex)
    {
        if (!this._curFormat)
            return -1;

        this._autofitcol_rate = [];

        this._clearGroup(true);

        var col = this._curFormat.insertContentsCol(strBand, nColIndex, bBandIndex);

        if (col >= 0)
        {
            this._initChecked();
            this._clearTempBand();
            this._clearBindTypeFlag();
            this._recreate();
        }

        return col;
    };

    _pGrid.deleteContentsRow = function (strBand, nSubRowIndex, bBandIndex)
    {
        if (!this._curFormat)
        {
            return -1;
        }

        if (arguments.length == 1)
        {
            nSubRowIndex = strBand;
            strBand = "body";
        }

        this._clearGroup(true);

        var row = this._curFormat.deleteContentsRow(strBand, nSubRowIndex, bBandIndex);

        if (row >= 0)
        {
            this._initChecked();
            this._clearTempBand();
            this._clearBindTypeFlag();
            this._recreate();
        }

        return row;
    };

    _pGrid.deleteContentsCol = function (strBand, nColIndex, bBandIndex)
    {
        if (!this._curFormat)
        {
            return -1;
        }

        this._autofitcol_rate = [];
        this._clearGroup(true);

        var col = this._curFormat.deleteContentsCol(strBand, nColIndex, bBandIndex);

        if (col >= 0)
        {
            this._initChecked();
            this._clearTempBand();
            this._clearBindTypeFlag();
            this._recreate();
        }

        return col;
    };

    _pGrid.mergeContentsCell = function (strBand, nStartRow, nStartCol, nEndRow, nEndCol, nFirstCell, bKeepSubCell)
    {
        if (!this._curFormat)
        {
            return -1;
        }

        bKeepSubCell = nexacro._toBoolean(bKeepSubCell);
        this._clearGroup(true);

        var cell = this._curFormat.mergeContentsCell(strBand, nStartRow, nStartCol, nEndRow, nEndCol, nFirstCell, bKeepSubCell);

        if (cell >= 0)
        {
            this._clearTempBand();
            this._clearBindTypeFlag();
            this._recreate();
        }

        return cell;
    };

    _pGrid.splitContentsCell = function (strBand, nStartRow, nStartCol, nEndRow, nEndCol, bMakeSubCell)
    {
        if (!this._curFormat)   
        {
            return -1;
        }
        else
        {
            bMakeSubCell = nexacro._toBoolean(bMakeSubCell);
            this._clearGroup(true);

            var cell = this._curFormat.splitContentsCell(strBand, nStartRow, nStartCol, nEndRow, nEndCol, bMakeSubCell);

            if (cell > 0)
            {
                this._clearTempBand();
                this._clearBindTypeFlag();
                this._recreate();
            }
            return cell;
        }
    };

    _pGrid.setBandProperty = function (strBand, strPropID, varValue)
    {
        var format = this._curFormat;

        if (!format)
            return false;

        strBand = strBand.toLowerCase();

        var bandinfo = format.setBandProperty(strBand, strPropID, varValue);
        if (bandinfo)
        {
            strBand = strBand.toLowerCase();

            var pre = strPropID.substr(0, 13).toLowerCase();
            var band;

            if (pre == "accessibility")
            {
                // 실제 band control에 bandinfo 값 적용
                if (strBand == "body")
                {
                    band = this._bodyBand;
                    band["set_" + strPropID](varValue);
                }
                else if (strBand == "head")
                {
                    band = this._headBand;
                    band["set_" + strPropID](varValue);
                }
                else
                {
                    band = this._summBand;
                    band["set_" + strPropID](varValue);
                }
            }
            else
            {
                if (strBand == "body")
                {
                    this._refreshBody(true);
                }
                else if (strBand == "head")
                {
                    this._refreshHead(true);
                }
                else 
                {
                    this._refreshSumm(true);
                }
            }
        }
        return (bandinfo != null);
    };

    _pGrid.getBandProperty = function (strBand, strPropID)
    {
        var format = this._curFormat;

        if (!format)
        {
            return null;
        }

        strBand = strBand.toLowerCase();

        return format.getBandProperty(strBand, strPropID);
    };

    _pGrid.setCellProperty = function (strBand, nCellIdx, strPropID, varValue)
    {
        var format = this._curFormat;

        if (!format)
        {
            return false;
        }
        if (this._firstEditableCell)
            this._firstEditableCell = null;
        strBand = strBand.toLowerCase();

        var cells, cellcnt, cellinfo2;
        var cellinfo = format.setCellProperty(strBand, nCellIdx, strPropID, varValue);
        if (cellinfo)
        {
            if (strPropID == "displaytype")
            {
                if ((varValue == "treeitemcontrol"))
                {
                    if (!this._hasTree)
                        this._setTreeCellinfo(cellinfo);
                }
                else if (varValue == "rowgroupcontrol")
                {
                    if (cellinfo._groupcol >= 0 || !this._hasTree)
                        this._setTreeCellinfo(cellinfo);
                }
            }
            else if (strPropID == "autosizecol" || strPropID == "autosizerow" || strPropID == "rtl")
            {
                this._recreate_contents_all(true, false);
            }
            else if (strPropID == "text" || strPropID == "expr")
            {
                if (strBand == "head")
                {
                    if (this._headAutoSize)
                    {
                        this._recreate_contents_all(true, false);
                    }
                    else
                    {
                        if (this._groupBar)
                            this._groupBar._updateInnerDataset();
                    }
                }
                else if (strBand == "body" && this._bodyAutoSize)
                {
                    this._recreate_contents_all(true, false);
                }
                else if ((strBand == "summ" || strBand == "summary") && this._summAutoSize)
                {
                    this._recreate_contents_all(true, false);
                }
                else
                {
                    this._refreshCell(strBand, nCellIdx, -1);
                }
            }
            else if (strPropID == "suppress")
            {
                if (varValue != 0)
                {
                    this._is_use_suppress = true;
                }
                else
                {
                    cellinfo._clearSuppressInfo();

                    cells = this._curFormat._bodycells;
                    cellcnt = cells ? cells.length : 0;

                    this._is_use_suppress = false;
                    for (var j = 0; j < cellcnt; j++)
                    {
                        cellinfo2 = cells[j];
                        if (cellinfo2._p_suppress != 0)
                        {
                            this._is_use_suppress = true;
                            break;
                        }
                    }
                }
                this._refreshBody();
            }
            else if (strPropID == "suppressalign" && this._is_use_suppress)
            {
                this._destroyOverlayControls();
                this._destroySelectionControls();
                this._destroyCellSelectionControl();
                this._refreshBody();
            }
            else
            {
                if (strPropID == "displaytype")
                {
                    this._changeDisplayer = true;
                }
                else if (strPropID == "wordwrap")
                {
                    if (varValue != "none")
                    {
                        if (strBand == "head")
                            this._is_head_wordwrap = true;
                        if (strBand == "body")
                            this._is_body_wordwrap = true;
                        if ((strBand == "summ" || strBand == "summary"))
                            this._is_head_wordwrap = true;
                    }
                    else
                    {
                        if (strBand == "body")
                        {
                            cells = this._curFormat._bodycells;
                            cellcnt = cells ? cells.length : 0;

                            this._is_body_wordwrap = false;
                            for (var jj = 0; jj < cellcnt; jj++)
                            {
                                cellinfo2 = cells[jj];
                                if (cellinfo2.wordwrap != "none")
                                {
                                    this._is_body_wordwrap = true;
                                    break;
                                }
                            }
                        }

                        if (strBand == "head")
                        {
                            cells = this._curFormat._headcells;
                            cellcnt = cells ? cells.length : 0;

                            this._is_head_wordwrap = false;
                            for (var jjj = 0; jjj < cellcnt; jjj++)
                            {
                                cellinfo2 = cells[jjj];
                                if (cellinfo2.wordwrap != "none")
                                {
                                    this._is_head_wordwrap = true;
                                    break;
                                }
                            }
                        }

                        if ((strBand == "summ" || strBand == "summary"))
                        {
                            cells = this._curFormat._summcells;
                            cellcnt = cells ? cells.length : 0;

                            this._is_summ_wordwrap = false;
                            for (var jjjj = 0; jjjj < cellcnt; jjjj++)
                            {
                                cellinfo2 = cells[jjjj];
                                if (cellinfo2.wordwrap != "none")
                                {
                                    this._is_summ_wordwrap = true;
                                    break;
                                }
                            }
                        }
                    }
                }

                this._refreshCell(strBand, nCellIdx, -1, strPropID);

                if (this._currentCellEditor)
                    this._currentCellEditor._setProperty(true);

                this._changeDisplayer = false;
            }
        }

        return (cellinfo != null);
    };

    _pGrid.getCellProperty = function (strBand, nCellIdx, strPropID)
    {
        var format = this._curFormat;

        if (!format)
        {
            return null;
        }

        strBand = strBand.toLowerCase();

        return format.getCellProperty(strBand, nCellIdx, strPropID);
    };

    _pGrid.getCellPropertyValue = function (nRowIndex, nCellIdx, strPropID)
    {
        var format = this._curFormat;

        if (!format)
            return undefined;

        return format.getCellPropertyValue(nRowIndex, nCellIdx, strPropID);
    };

    _pGrid.getSubCellPropertyValue = function (nRowIndex, nCellIdx, nSubCellIdx, strPropID)
    {
        var format = this._curFormat;

        if (!format)
            return undefined;

        return format.getSubCellPropertyValue(nRowIndex, nCellIdx, nSubCellIdx, strPropID);
    };

    _pGrid.autoFitRow = function (strType)
    {
        //TODO
    };

    _pGrid.autoFitCol = function ()
    {
        var af = this._p_autofittype;
        this._p_autofittype = "col";

        if (this._curFormat)
        {
            var width;
            var bodysize = this._getBodyClientSize();
            var control_elem = this.getElement();

            width = bodysize[0];

            if (control_elem)
            {
                if (!this._is_created && width <= 0)
                    width = control_elem.client_width;

                this._curFormat._resetOrgColSize(true, this._autofitcol_rate, width);
            }
        }

        var retn = this._applyAutofittype(true);
        this._p_autofittype = af;
        return retn;
    };

    _pGrid.autoSizeRow = function (nRowIndex, nSubRowIndex, bIsDatasetRow)
    {
        if (!this._binddataset || !this._curFormat || nRowIndex == undefined)
            return false;

        if (bIsDatasetRow == undefined || bIsDatasetRow == true)
            nRowIndex = this._getDataRow(nRowIndex);

        var retn = false;
        var change = false;
        var index;
        var oldsize;
        var newsize;
        var rows;
        var rowsLen;
        var j;

        this._autoSizeRowProc = true;

        if (nRowIndex >= 0)
        {
            this._is_variable_bodyrowsize = true;

            rows = this._curFormat._bodyrows;
            rowsLen = rows.length;

            if (nSubRowIndex >= 0)
            {
                index = (nRowIndex * rows.length) + nSubRowIndex;
                oldsize = this._rowSizeListSub[index];
                newsize = this._getMaxSubRowSize(nRowIndex, nSubRowIndex);

                if (oldsize != newsize)
                {
                    this._rowSizeListSub[index] = newsize;
                    this._rowSizeList[nRowIndex] += (newsize - oldsize);
                    change = true;
                    this._is_user_change_body_rowsize = true;
                }
            }
            else
            {
                for (j = 0; j < rowsLen; j++)
                {
                    index = (nRowIndex * rows.length) + j;
                    oldsize = this._rowSizeListSub[index];
                    newsize = this._getMaxSubRowSize(nRowIndex, j);

                    if (oldsize != newsize)
                    {
                        this._rowSizeListSub[index] = newsize;
                        this._rowSizeList[nRowIndex] += (newsize - oldsize);
                        change = true;
                        this._is_user_change_body_rowsize = true;
                    }
                }
            }
            if (change == true)
            {
                this._updateRowSizeExtend();
            }

            this._recreate_contents_all(false, false);
            retn = true;
        }
        else if (nRowIndex == -1)
        {
            rows = this._curFormat._headrows;
            rowsLen = rows.length;

            if (nSubRowIndex >= 0)
            {
                index = nSubRowIndex;
                oldsize = this._rowHeadListSub[index];
                newsize = this._getMaxSubRowSize(nRowIndex, nSubRowIndex);

                if (oldsize != newsize)
                {
                    this._rowHeadListSub[index] = newsize;
                    this._rowHeadList[0] += (newsize - oldsize);
                    change = true;
                }
            }
            else
            {
                for (j = 0; j < rowsLen; j++)
                {
                    index = j;
                    oldsize = this._rowHeadListSub[index];
                    newsize = this._getMaxSubRowSize(nRowIndex, j);

                    if (oldsize != newsize)
                    {
                        this._rowHeadListSub[index] = newsize;
                        this._rowHeadList[0] += (newsize - oldsize);
                        change = true;
                    }
                }
            }
            if (change == true)
            {
                this._updateRowSizeExtend();
            }

            this._resizeBand();
            this._recreate_contents_all(false, false);
            retn = true;
        }
        else if (nRowIndex == -2)
        {
            rows = this._curFormat._summrows;
            rowsLen = rows.length;

            if (nSubRowIndex >= 0)
            {
                index = nSubRowIndex;
                oldsize = this._rowSummListSub[index];
                newsize = this._getMaxSubRowSize(nRowIndex, nSubRowIndex);

                if (oldsize != newsize)
                {
                    this._rowSummListSub[index] = newsize;
                    this._rowSummList[0] += (newsize - oldsize);
                    change = true;
                }
            }
            else
            {
                for (j = 0; j < rowsLen; j++)
                {
                    index = j;
                    oldsize = this._rowSummListSub[index];
                    newsize = this._getMaxSubRowSize(nRowIndex, j);

                    if (oldsize != newsize)
                    {
                        this._rowSummListSub[index] = newsize;
                        this._rowSummList[0] += (newsize - oldsize);
                        change = true;
                    }
                }
            }
            if (change == true)
            {
                this._updateRowSizeExtend();
            }

            this._resizeBand();
            this._recreate_contents_all(false, false);
            retn = true;
        }
        this._autoSizeRowProc = false;
        return retn;
    };

    _pGrid.autoSizeCol = function (strBand, nColIndex, bBandindex)
    {
        var size;

        if (bBandindex == undefined)
            bBandindex = false;

        if (nColIndex == -1)
        {
            var cols = this._curFormat._cols;
            var colsLen = cols.length;

            for (var i = 0; i < colsLen; i++)
            {
                size = this._getMaxColDataSizeBand(i);

                if (size >= 0)
                    this._setColSize(strBand, i, size, false, true, true, (i != colsLen - 1));
            }
        }
        else if (nColIndex >= 0)
        {
            if (bBandindex)
            {
                var leftcnt = this._getColFixCnt("left");
                var bodycnt = this._getColFixCnt("body");
                var rightcnt = this._getColFixCnt("right");

                if (strBand == "left")
                {
                    if (nColIndex >= leftcnt)
                        return;
                }
                if (strBand == "body" && nColIndex >= 0)
                {
                    if (nColIndex >= bodycnt)
                        return;

                    nColIndex += leftcnt;
                }
                else if (strBand == "right")
                {
                    if (nColIndex >= rightcnt)
                        return;

                    nColIndex += leftcnt;
                    nColIndex += bodycnt;
                }
            }

            size = this._getMaxColDataSizeBand(nColIndex);

            if (size >= 0)
            {
                this._setColSize(strBand, nColIndex, size, false, true, true);
            }
        }
    };

    _pGrid.isDropdownCalendar = function ()
    {
        if (this._currentCellEditor && this._currentCellEditor._p_visible == true && this._currentCellEditor._type_name == "CalendarControl")
        {
            return this.isDropdown();
        }
        return false;
    };

    _pGrid.isDropdownCombo = function ()
    {
        if (this._currentCellEditor && this._currentCellEditor._p_visible == true && this._currentCellEditor._type_name == "ComboControl")
        {
            return this.isDropdown();
        }
        return false;
    };

    _pGrid.isDropdown = function ()
    {
        if (this._currentCellEditor && this._currentCellEditor._p_visible == true && this._currentCellEditor.isDropdown)
        {
            return this._currentCellEditor.isDropdown();
        }
        return false;
    };

    _pGrid.moveToNextCell = function ()
    {
        return this._moveToCell("next", true, false, undefined, undefined, true);
    };

    _pGrid.moveToPrevCell = function ()
    {
        return this._moveToCell("prev", true, false, undefined, undefined, true);
    };

    _pGrid.showHeadEditor = function (cellidx, show)
    {
        var ret = false;
        if (show === undefined)
        {
            show = true;
        }
        else
        {
            show = nexacro._toBoolean(show);
        }

        if (this._showEditing !== show || cellidx !== this._showEditCellIdx)
        {
            if (show)
            {
                this.setFocus(false);
                var cellobj = this._getCurrentHeadCell(cellidx, true);
                if (cellobj)
                {
                    // selection과 상관없이 반영하기 위해서 초기화
                    this._beforeEditRowIdx = -1;
                    this._beforeEditCellIdx = -1;

                    ret = this._showEditor(cellobj);
                }
            }
            else
            {
                ret = this._hideEditor();
            }
        }

        return ret;
    };

    _pGrid.showEditor = function (bShow)
    {
        if (this._hide_applydata)
        {
            nexacro._OnceCallbackTimer.callonce(this, function ()
            {
                this.showEditor(bShow);
            }, 50);

            return true;
        }

        var val;

        if (bShow === undefined)
        {
            bShow = true;
        }
        bShow = nexacro._toBoolean(bShow);

        if (this._showEditing == bShow)
        {
            return false;
        }

        if (bShow)
        {
            this.setFocus(false);
            val = this._showEditor();
        }
        else
        {
            val = this._hideEditor();
        }
        return val;
    };

    _pGrid.dropdownCombo = function ()
    {
        if (this._currentCellEditor && this._currentCellEditor._p_visible == true && this._currentCellEditor._type_name == "ComboControl")
        {
            this._currentCellEditor.dropdown();
            return true;
        }
        return false;
    };

    _pGrid.dropdownCalendar = function ()
    {
        if (this._currentCellEditor && this._currentCellEditor._p_visible == true && this._currentCellEditor._type_name == "CalendarControl")
        {
            this._currentCellEditor.dropdown();
            return true;
        }
        return false;
    };

    _pGrid.dropdown = function ()
    {
        if (this._currentCellEditor && this._currentCellEditor._p_visible == true && this._currentCellEditor.dropdown)
        {
            this._currentCellEditor.dropdown();
            return true;
        }
        return false;
    };

    _pGrid.getCurEditType = function ()
    {
        var cellinfo = this._getBodyCellInfo(this._selectinfo.curcell);
        if (cellinfo)
        {
            return cellinfo._getAttrValue(cellinfo._p_edittype, this._selectinfo.curdsrow);
        }
        return "";
    };

    _pGrid.getEditCaret = function ()
    {
        if (this._showEditing)
        {
            var editComp = this._currentCellEditor;
            if (editComp && editComp.getCaretPos)
            {
                return editComp.getCaretPos();
            }
        }
        return -1;
    };

    _pGrid.getEditSelect = function ()
    {
        var editComp = this._currentCellEditor;
        if (editComp && editComp.getSelect)
        {
            return editComp.getSelect();
        }
    };

    _pGrid.getEditSelectedText = function ()
    {
        var editComp = this._currentCellEditor;
        if (editComp && editComp.getSelectedText)
        {
            return editComp.getSelectedText();
        }
        return "";
    };

    _pGrid.getEditText = function ()
    {
        if (this._showEditing)
        {
            var editComp = this._currentCellEditor;
            if (editComp)
            {
                return editComp.text;
            }
        }
    };

    _pGrid.getEditingText = function ()
    {
        if (this._showEditing)
        {
            var editComp = this._currentCellEditor;
            if (editComp)
            {
                return editComp._getEditingText();
            }
        }
    };

    _pGrid.getEditValue = function ()
    {
        if (this._showEditing)
        {
            var editComp = this._currentCellEditor;
            if (editComp)
            {
                return editComp.value;
            }
        }
    };

    _pGrid.getEditingValue = function ()
    {
        if (this._showEditing)
        {
            var editComp = this._currentCellEditor;
            if (editComp)
            {
                return editComp._getEditingValue();
            }
        }
    };

    _pGrid.setEditValue = function (value)
    {
        if (this._showEditing)
        {
            var editComp = this._currentCellEditor;
            if (editComp)
            {
                return editComp.set_value(value);
            }
        }
    };

    _pGrid.setEditingValue = function (value)
    {
        if (this._showEditing)
        {
            var editComp = this._currentCellEditor;
            if (editComp)
            {
                return editComp._setEditingValue(value);
            }
        }
    };

    _pGrid.setEditText = _pGrid.setEditValue;

    _pGrid.setEditCaret = function (nPos)
    {
        //TODO
    };

    _pGrid.setEditSelect = function (nStart, nEnd)
    {
        var editor = this._currentCellEditor;

        if (!editor)
            return false;

        if (nStart == -1)
        {
            editor.setSelect(0, 0);
            return true;
        }
        else
        {
            if (editor.setSelect)
                return editor.setSelect(nStart, nEnd);
        }
        return false;
    };

    _pGrid.setEditSelectedText = function (strText)
    {
        //TODO
    };


    _pGrid.updateToDataset = function ()
    {
        if (this._dsEventOccured)
            return false;

        if (this._showEditing)
        {
            var editComp = this._currentCellEditor;
            if (editComp)
            {
                editComp._setDataset(false, this._currentCellRow);
                return true;
            }
            return false;
        }
        return false;
    };

    _pGrid.setTreeStatus = function (nRowIndex, bTreeStatus)
    {
        if (!this._hasTree)
        {
            return false;
        }

        bTreeStatus = nexacro._toBoolean(bTreeStatus);
        var indexes = this._treeIndexes;
        var rowcount = indexes.length;
        var rows = this._bodyBand._get_rows();

        if (rowcount <= nRowIndex || !rows || rows.length == 0)
        {
            return false;
        }

        var retn;

        if (bTreeStatus)
        {
            retn = this._setTreeState(nRowIndex, 1, true);
        }
        else
        {
            retn = this._setTreeState(nRowIndex, 0, true);
        }

        if (retn > 0)
            return true;

        return false;
    };

    _pGrid.getTreeStatus = function (nRowIndex)
    {
        if (!this._hasTree || !this._treeIndexes)
        {
            return -1;
        }

        var indexes = this._treeIndexes;
        var rowcount = indexes.length;
        var rows = this._bodyBand._get_rows();

        if (rowcount <= nRowIndex || !rows || rows.length == 0)
        {
            return -1;
        }

        var dsrowidx = indexes[nRowIndex];
        var state = this._treeStates[dsrowidx];

        var cellinfo = this._treeCellinfo;
        var editType = cellinfo._getEdittype(dsrowidx);

        if (editType == "tree" || editType == "rowgroup")
        {
            if (cellinfo.treestate._bindtype == 1)
            {
                var colid = cellinfo.treestate._bindexpr;
                var state2 = this._binddataset.getColumn(dsrowidx, colid);

                if (state2 > 1)
                {
                    state = state2;
                }
            }
        }

        if (state == 2)
        {
            state++;	// 2 -> 3 leaf
        }
        return state;
    };

    _pGrid.getTreeChildCount = function (nRowIndex, bIsDatasetRow)
    {
        if (this._hasTree)
        {
            var row = nRowIndex;

            if (bIsDatasetRow == undefined)
                bIsDatasetRow = true;
            else
                bIsDatasetRow = nexacro._toBoolean(bIsDatasetRow);

            if (bIsDatasetRow === false)
                row = this.getDatasetRow(nRowIndex);

            if (row < 0 || this._rowcount <= row)
                return 0;

            var cellinfo = this._treeCellinfo;
            var lvl1 = cellinfo._getTreeLevel(row);
            var lvl2, temp = -1;
            var cnt = 0;

            for (var i = row + 1, n = this._rowcount; i < n; i++)
            {
                lvl2 = cellinfo._getTreeLevel(i);
                if (lvl1 >= lvl2)
                    break;

                if (temp >= 0)
                {
                    if (temp >= lvl2)
                    {
                        if (temp > lvl2)
                            temp = lvl2;

                        cnt++;
                    }
                }
                else
                {
                    cnt++;
                    temp = lvl2;
                }
            }
            return cnt;
        }
        return 0;
    };

    _pGrid.getTreeChildRow = function (nRowIndex, nChildIndex, bIsDatasetRow)
    {
        if (this._hasTree)
        {
            var row = nRowIndex;

            if (bIsDatasetRow == undefined)
                bIsDatasetRow = true;
            else
                bIsDatasetRow = nexacro._toBoolean(bIsDatasetRow);

            if (bIsDatasetRow === false)
                row = this.getDatasetRow(nRowIndex);

            if (row < 0 || this._rowcount <= row)
                return -1;

            var cellinfo = this._treeCellinfo;
            var lvl1 = cellinfo._getTreeLevel(row);
            var lvl2, temp = -1;
            var lastrow = -1;
            var cnt = 0;

            for (var i = row + 1, n = this._rowcount; i < n; i++)
            {
                lvl2 = cellinfo._getTreeLevel(i);
                if (lvl1 >= lvl2)
                    break;

                if (temp >= 0)
                {
                    if (temp >= lvl2)
                    {
                        if (temp > lvl2)
                            temp = lvl2;

                        cnt++;
                        if (nChildIndex == cnt)
                            return i;

                        lastrow = i;
                    }
                }
                else
                {
                    temp = lvl2;
                    if (nChildIndex == 0)
                        return i;

                    lastrow = i;
                }
            }

            if (nChildIndex == -1)
                return lastrow;
        }

        return -1;
    };

    _pGrid.getTreeParentRow = function (nRowIndex, bIsDatasetRow)
    {
        if (this._hasTree)
        {
            var row = nRowIndex;

            if (bIsDatasetRow == undefined)
                bIsDatasetRow = true;
            else
                bIsDatasetRow = nexacro._toBoolean(bIsDatasetRow);

            if (bIsDatasetRow === false)
                row = this.getDatasetRow(nRowIndex);

            if (row < 0 || this._rowcount <= row)
                return -1;

            var cellinfo = this._treeCellinfo;
            var lvl1 = cellinfo._getTreeLevel(row);
            var lvl2;

            for (var i = row - 1; i >= 0; i--)
            {
                lvl2 = cellinfo._getTreeLevel(i);
                if (lvl1 > lvl2)
                    return i;
            }
        }
        return -1;
    };

    _pGrid.getTreeSiblingRow = function (nRowIndex, nOffset, bIsDatasetRow)
    {
        if (this._hasTree)
        {
            var row = nRowIndex;

            if (nOffset === undefined)
                nOffset = 1;

            if (bIsDatasetRow == undefined)
                bIsDatasetRow = true;
            else
                bIsDatasetRow = nexacro._toBoolean(bIsDatasetRow);

            if (bIsDatasetRow === false)
                row = this.getDatasetRow(nRowIndex);

            if (row < 0 || this._rowcount <= row)
                return -1;

            var cellinfo = this._treeCellinfo;
            var lvl1 = cellinfo._getTreeLevel(row);
            var lvl2;
            var set = 0;
            var i, n;

            if (nOffset < 0)
            {
                for (i = row - 1; i >= 0; i--)
                {
                    lvl2 = cellinfo._getTreeLevel(i);
                    if (lvl1 > lvl2)
                    {
                        break;
                    }
                    else if (lvl1 == lvl2)
                    {
                        set--;
                        if (nOffset == set)
                        {
                            return i;
                        }
                    }
                }
            }
            else if (nOffset > 0)
            {
                for (i = row + 1, n = this._rowcount; i < n; i++)
                {
                    lvl2 = cellinfo._getTreeLevel(i);
                    if (lvl1 > lvl2)
                    {
                        break;
                    }
                    else if (lvl1 == lvl2)
                    {
                        set++;
                        if (nOffset == set)
                        {
                            return i;
                        }
                    }
                }
            }
            else
            {
                return row;
            }
        }
        return -1;
    };

    _pGrid.getTreePath = function (nRowIndex, bIsDatasetRow)
    {
        if (this._hasTree)
        {
            var row = nRowIndex;

            if (bIsDatasetRow == undefined)
                bIsDatasetRow = true;
            else
                bIsDatasetRow = nexacro._toBoolean(bIsDatasetRow);

            if (bIsDatasetRow === false)
                row = this.getDatasetRow(nRowIndex);

            if (row < 0 || this._rowcount <= row)
                return "";

            var cellinfo = this._treeCellinfo;
            var val = [];
            var i = 0;

            while (row >= 0)
            {
                val[i] = cellinfo._getValue(row);
                row = this.getTreeParentRow(row);
                i++;
            }

            var str = "";
            for (i = val.length - 1; i >= 0; i--)
            {
                str += val[i];

                if (i > 0)
                    str += this._p_treepathdelimiter;
            }
            return str;
        }
        return "";
    };

    _pGrid.getTreeRow = function (nRowIndex)
    {
        if (this._hasTree)
        {
            if (typeof (nRowIndex) == "string")
            {
                var treepath = nRowIndex;
                var cnt = this._rowcount;
                var path;
                nRowIndex = -1;

                for (var i = 0; i < cnt; i++)
                {
                    path = this.getTreePath(i, true);
                    if (path == treepath)
                    {
                        nRowIndex = i;
                        break;
                    }
                }
            }
            if (nRowIndex >= 0)
            {
                var _treeIndexes = this._treeIndexes;
                var _treeIndexesLen = _treeIndexes.length;

                for (var k = 0; k < _treeIndexesLen; k++)
                {
                    if (_treeIndexes[k] == nRowIndex)
                        return k;
                }
            }
        }
        return -1;
    };

    _pGrid.getDatasetRow = function (nRowIndex)
    {
        if (nRowIndex >= 0)
        {
            if (this._hasTree)
            {
                if (this._treeIndexes.length > nRowIndex)
                    return this._treeIndexes[nRowIndex];
            }
            else
            {
                if (this._rowcount > nRowIndex)
                    return nRowIndex;
            }
        }
        return -1;
    };

    _pGrid.isTreeLeafRow = function (nRowIndex, bIsDatasetRow)
    {
        if (this._hasTree)
        {
            var cnt = this.getTreeChildCount(nRowIndex, bIsDatasetRow);
            if (cnt == 0)
            {
                if (bIsDatasetRow == undefined)
                    bIsDatasetRow = true;
                else
                    bIsDatasetRow = nexacro._toBoolean(bIsDatasetRow);

                var row = nRowIndex;
                if (bIsDatasetRow === false)
                    row = this.getDatasetRow(nRowIndex);

                if (row < 0 || this._rowcount <= row)
                    return false;

                return true;
            }
        }
        return false;
    };

    _pGrid.isTreeRootRow = function (nRowIndex, bIsDatasetRow)
    {
        if (this._hasTree)
        {
            var row = nRowIndex;

            if (bIsDatasetRow == undefined)
                bIsDatasetRow = true;
            else
                bIsDatasetRow = nexacro._toBoolean(bIsDatasetRow);

            if (bIsDatasetRow === false)
                row = this.getDatasetRow(nRowIndex);

            if (row < 0 || this._rowcount <= row)
                return false;

            var cellinfo = this._treeCellinfo;
            var lvl = cellinfo._getTreeLevel(row);
            var start = cellinfo._getTreeStartLevel(row);

            if (start == lvl)
                return true;
        }
        return false;
    };

    _pGrid.isTreeExpandedRow = function (nRowIndex, bIsDatasetRow)
    {
        if (this._hasTree)
        {
            var row = nRowIndex;

            if (bIsDatasetRow == undefined)
                bIsDatasetRow = true;
            else
                bIsDatasetRow = nexacro._toBoolean(bIsDatasetRow);

            if (bIsDatasetRow === false)
                row = this.getDatasetRow(nRowIndex);

            if (row < 0 || this._rowcount <= row)
                return false;

            while (row >= 0)
            {
                row = this.getTreeParentRow(row);

                if (row < 0)
                    break;

                var indexes = this._treeIndexes;
                var rowcount = indexes.length;

                if (row >= 0 && rowcount > 0)
                {
                    var state = this._treeStates[row];

                    if (state == 0)
                        return false;
                }
            }
            return true;
        }
        return false;
    };

    _pGrid.isTreeCollapsedRow = function (nRowIndex, bIsDatasetRow)
    {
        if (this._hasTree)
        {
            var row = nRowIndex;

            if (bIsDatasetRow == undefined)
                bIsDatasetRow = true;
            else
                bIsDatasetRow = nexacro._toBoolean(bIsDatasetRow);

            if (bIsDatasetRow === false)
                row = this.getDatasetRow(nRowIndex);

            if (row < 0 || this._rowcount <= row)
                return false;

            while (row >= 0)
            {
                row = this.getTreeParentRow(row);

                if (row < 0)
                    break;

                var indexes = this._treeIndexes;
                var rowcount = indexes.length;

                if (row >= 0 && rowcount > 0)
                {
                    var state = this._treeStates[row];

                    if (state == 0)
                        return true;
                }
            }
        }
        return false;
    };

    _pGrid.getCsvData = function (/*bSelOnly*/)
    {
        //TODO
    };

    _pGrid.getHeadValue = function (nCell)
    {
        var format = this._curFormat;
        if (format && format._headcells && nCell >= 0 && format._headcells.length > nCell)
        {
            var cellinfo = this._curFormat._headcells[nCell];

            if (cellinfo)
            {
                if (cellinfo._value != undefined)
                    return cellinfo._value;
                else
                    return cellinfo._getValue(this._currentDSrow);
            }

        }
        return null;
    };

    _pGrid.setHeadValue = function (nCell, v)
    {
        var format = this._curFormat;
        var prevalue;
        if (format && format._headcells && nCell >= 0 && format._headcells.length > nCell)
        {
            var cellinfo = this._curFormat._headcells[nCell];
            if (cellinfo)
                prevalue = cellinfo._value;

            if (cellinfo._setValue(v))
            {
                this._on_fire_onheadvaluechanged(prevalue, v, nCell);
                this._refreshHead(true);
            }
        };
    };

    _pGrid.getSummValue = function (nCell)
    {
        var format = this._curFormat;
        if (format && format._summcells && nCell >= 0 && format._summcells.length > nCell)
        {
            var cellinfo = this._curFormat._summcells[nCell];

            if (cellinfo)
                return cellinfo._getValue(this._currentDSrow);
        }
        return null;
    };

    _pGrid.getBindCellIndex = function (strBand, strColID)
    {
        var format = this._curFormat;

        if (!format)
            return -1;

        strBand = strBand.toLowerCase();

        var cellinfo;
        var i;

        if (strColID)
        {
            if (strBand == "head" && format._headcells)
            {
                var _headcells = format._headcells;
                var _headcellsLen = _headcells.length;

                for (i = 0; i < _headcellsLen; i++)
                {
                    cellinfo = _headcells[i];

                    if (cellinfo.text._bindexpr == strColID)
                        return i;
                }
            }
            else if (strBand == "body" && format._bodycells)
            {
                var _bodycells = format._bodycells;
                var _bodycellsLen = _bodycells.length;

                for (i = 0; i < _bodycellsLen; i++)
                {
                    cellinfo = _bodycells[i];

                    if (cellinfo.text._bindexpr == strColID)
                        return i;
                }
            }
            else if ((strBand == "summ" || strBand == "summary") && format._summcells)
            {
                var _summcells = format._summcells;
                var _summcellsLen = _summcells.length;

                for (i = 0; i < _summcellsLen; i++)
                {
                    cellinfo = _summcells[i];

                    if (cellinfo.text._bindexpr == strColID)
                        return i;
                }
            }
        }
        return -1;
    };

    _pGrid.isAboveSelected = function ()
    {
        //TODO
    };

    // VirtualMerge Method
    _pGrid.mergeCell = function (scol, ecol, srow, erow, ssubrow, esubrow)
    {
        return this._setVirtualMerge(scol, srow, ssubrow, ecol, erow, esubrow, false);
    };

    _pGrid.splitCell = function (scol, ecol, srow, erow, ssubrow, esubrow)
    {
        return this._setVirtualMerge(scol, srow, ssubrow, ecol, erow, esubrow, true);
    };

    _pGrid._absolutelyResetScrollPos = function (v)
    {
        var head = this._headBand;
        var body = this._bodyBand;
        var summ = this._summBand;

        if (this._control_element)
            this._control_element._reset_scrollpos = v;

        if (head && head._control_element)
            head._control_element._reset_scrollpos = v;

        if (body && body._control_element)
            body._control_element._reset_scrollpos = v;

        if (summ && summ._control_element)
            summ._control_element._reset_scrollpos = v;
    };

    _pGrid._no_use_onscroll_callback_after = false;
    _pGrid._moverow_frame_df = 0; // (nexacro._isTouchInteraction && nexacro._Browser != "Runtime") ? 1 : 0; // 필요?
    _pGrid._moverow_frame = _pGrid._moverow_frame_df;

    _pGrid._float_updown = false;
    _pGrid._float_center = false;
    _pGrid._float_move = false;
    _pGrid._floating_row_addsize = 2;
    _pGrid._floating_row_border = "1px solid gray";
    _pGrid._floating_row_shadow = "1px 1px 12px gray";
    _pGrid._floating_gap = 3;

    _pGrid._createHighlightRow = function ()
    {
        if (!this._use_blindscroll)
            return;

        var body = this._bodyBand;

        if (!body)
            return;

        if (!this._covercontrol)
        {
            this._covercontrol = new nexacro._GridCoverControl(this._bodyBand, this);
            this._covercontrol.createComponent();
        }

        var top;

        if (!this._highlight_row_main)
        {
            top = (this._float_center && !this._float_updown) ? ((body._getClientHeight() - (this._bodyrowheight + this._floating_row_addsize)) / 2) : this._floating_gap;
            var highlight_row_main = this._highlight_row_main = new nexacro._GridRowControl(body, this._floating_gap, top + this._fixed_height, null, this._bodyrowheight + this._floating_row_addsize, 0, false, true, this._floating_gap);
            highlight_row_main.set_border(this._floating_row_border);
            highlight_row_main.set_boxShadow(this._floating_row_shadow);
            highlight_row_main.set_visible(false);
            highlight_row_main._updateAll();
            highlight_row_main.createComponent();
        }

        if (!this._float_move)
        {
            if (this._float_updown)
            {
                if (!this._highlight_row_sublast)
                {
                    var highlight_row_sublast = this._highlight_row_sublast = new nexacro._GridRowControl(body, this._floating_gap, null, null, this._bodyrowheight + this._floating_row_addsize, 0, false, true, this._floating_gap, this._floating_gap - this._fixed_height);
                    highlight_row_sublast.set_border(this._floating_row_border);
                    highlight_row_sublast.set_boxShadow(this._floating_row_shadow);
                    highlight_row_sublast.set_visible(false);
                    highlight_row_sublast._updateAll();
                    highlight_row_sublast.createComponent();
                }
                if (this._float_center)
                {
                    if (!this._highlight_row_subcenter)
                    {
                        top = ((body._getClientHeight() - (this._bodyrowheight + this._floating_row_addsize)) / 2);
                        var highlight_row_subcenter = this._highlight_row_subcenter = new nexacro._GridRowControl(body, this._floating_gap, top + this._fixed_height, null, this._bodyrowheight + this._floating_row_addsize, 0, false, true, this._floating_gap);
                        highlight_row_subcenter.set_border(this._floating_row_border);
                        highlight_row_subcenter.set_boxShadow(this._floating_row_shadow);
                        highlight_row_subcenter.set_visible(false);
                        highlight_row_subcenter._updateAll();
                        highlight_row_subcenter.createComponent();
                    }
                }
            }
        }
    };

    _pGrid._updateHighlightrowPos = function ()
    {
        if (!this._bodyBand)
            return;

        if (!this._float_move)
        {
            var top;
            if (this._highlight_row_main)
            {
                top = (this._float_center && !this._float_updown) ? ((this._bodyBand._getClientHeight() - (this._bodyrowheight + this._floating_row_addsize)) / 2) : this._floating_gap;
                this._highlight_row_main._setTop(top + this._fixed_height);
                this._highlight_row_main._update_position();
            }
            if (this._highlight_row_sublast)
            {
                this._highlight_row_sublast._setBottom(this._floating_gap - this._fixed_height);
                this._highlight_row_sublast._update_position();
            }
            if (this._highlight_row_subcenter)
            {
                top = (this._bodyBand._getClientHeight() - (this._bodyrowheight + this._floating_row_addsize)) / 2 + this._fixed_height;
                this._highlight_row_subcenter._setTop(top);
                this._highlight_row_subcenter._update_position();
            }
        }
    };

    _pGrid._destroyHighlightRow = function ()
    {
        if (this._highlight_row_main)
            this._highlight_row_main.destroy();
        if (this._highlight_row_sublast)
            this._highlight_row_sublast.destroy();
        if (this._highlight_row_subcenter)
            this._highlight_row_subcenter.destroy();
        if (this._covercontrol)
            this._covercontrol.destroy();

        this._covercontrol = null;
        this._highlight_row_main = null;
        this._highlight_row_sublast = null;
        this._highlight_row_subcenter = null;
    };

    _pGrid._setBlindBody = function (v)
    {
        var body = this._bodyBand;

        if (this._covercontrol && body)
        {
            if (v)
                this._covercontrol._coverOn(0);
            else
                this._covercontrol._coverOff(0);
        }
    };

    _pGrid._getLastGridRowIdx = function ()
    {
        return this._p_rowcount - 1 + this._rowToPageRow(0);
    };

    _pGrid._getRowIdxInClient = function (top)
    {
        var lastrow = this._getLastGridRowIdx();
        var rowpos = this._toprowpos[0];
        var remain = this._toprowpos[1];
        var disprowcnt = this._disprowcnt;
        var bodyrow_h = this._bodyrowheight, incrow_h;
        var i;

        if (!this._is_variable_bodyrowsize)
        {
            incrow_h = remain - bodyrow_h + this._fixed_height;
            for (i = 0; i < disprowcnt; i++)
            {
                incrow_h += bodyrow_h;

                if (top < incrow_h)
                {
                    rowpos += i;
                    break;
                }
            }
        }
        else
        {
            var toppos = rowpos;
            var rowsizelist = this._rowSizeList;
            var rowsize;

            incrow_h = remain - rowsizelist[this._getDataRow(toppos)] + this._fixed_height;
            for (i = 0; i < disprowcnt; i++)
            {
                rowsize = rowsizelist[this._getDataRow(toppos + i)];
                incrow_h += rowsize;

                if (top < incrow_h)
                {
                    rowpos += i;
                    break;
                }
            }
        }

        if (rowpos > lastrow)
            rowpos = lastrow;

        return rowpos;
    };

    _pGrid._floatingScrollRows_callback = function (no_ani)
    {
        var control_elem = this._control_element;
        var vscroll_limit = Math.ceil(control_elem.vscroll_limit);
        var pos = this._vscrollmng._pos;
        var body = this._bodyBand;

        if (pos > vscroll_limit)
            pos = vscroll_limit;

        this._last_scroll_top = control_elem.scroll_top;
        this._toprowpos = this._getScreenTopRowPos(pos);
        this._bottomrowpos = this._getScreenBottomRowPos(pos);

        this._setBlindBody(true);

        var rowpos;
        var disprowcnt = this._disprowcnt;
        var highlight_row_main = this._highlight_row_main;
        var top;

        if (this._float_move)   // trackbarfollow
        {
            var ratio = (pos) ? this._vscrollmng._pos / this._vscrollmng._max : 0;
            var bodyrow_h = this._bodyrowheight;
            var body_height = body._getClientHeight();

            if (pos < vscroll_limit)
            {
                top = ((body_height - (bodyrow_h + this._floating_row_addsize)) * ratio) + this._fixed_height;
                rowpos = this._getRowIdxInClient(top);
            }
            else
            {
                top = body_height - (bodyrow_h + this._floating_row_addsize) + this._fixed_height;
                rowpos = this._getLastGridRowIdx();
            }

            highlight_row_main._changeRow(rowpos);
            highlight_row_main._updateAll(undefined, undefined, true);
            highlight_row_main.set_top(top);
            highlight_row_main._control_element.setElementHScrollPos(this._getScrollLeft());
            highlight_row_main.set_visible(true);
        }
        else // this._float_move = false
        {
            var centerpos = 0;

            rowpos = this._toprowpos[0];

            if (this._float_center)
            {
                top = (body._getClientHeight() - (this._bodyrowheight + this._floating_row_addsize)) / 2 + this._fixed_height;
                centerpos = this._getRowIdxInClient(top) - rowpos;
            }

            if (this._float_updown) // topbottom
            {
                highlight_row_main._changeRow(rowpos);
                highlight_row_main._updateAll(undefined, undefined, true);
                highlight_row_main._control_element.setElementHScrollPos(this._getScrollLeft());
                highlight_row_main.set_visible(true);

                var highlight_row_sublast = this._highlight_row_sublast;
                highlight_row_sublast._changeRow(rowpos + disprowcnt - 1);
                highlight_row_sublast._updateAll(undefined, undefined, true);
                highlight_row_sublast._control_element.setElementHScrollPos(this._getScrollLeft());
                highlight_row_sublast.set_visible(true);

                if (this._float_center) // topcenterbottom
                {
                    var highlight_row_subcenter = this._highlight_row_subcenter;
                    highlight_row_subcenter._changeRow(rowpos + centerpos);
                    highlight_row_subcenter._updateAll(undefined, undefined, true);
                    highlight_row_subcenter._control_element.setElementHScrollPos(this._getScrollLeft());
                    highlight_row_subcenter.set_visible(true);
                }
            }
            else // all, center, top
            {
                highlight_row_main._changeRow(rowpos + centerpos);
                highlight_row_main._updateAll(undefined, undefined, true);
                highlight_row_main._control_element.setElementHScrollPos(this._getScrollLeft());
                highlight_row_main.set_visible(true);
            }
        }

        if (!no_ani)
        {
            this._scroll_vpos_queue.pop();

            if (this._scroll_vpos_queue.length > 0)
                this._aniframe_rowscroll_float.start();
        }
        else
        {
            this._aniframe_rowscroll.stop();
            this._scroll_vpos_queue = [];
        }
    };

    _pGrid._adjustGridScrollRows_callback_end = function (callbacktimer)
    {
        if (this._aniframe_rowscroll_end._skipscrolltask && this._isflingend)
        {
            this._aniframe_rowscroll_end._skipscrolltask = undefined;

            return;
        }
        var control_elem = this._control_element;
        var vscroll_limit = Math.ceil(control_elem.vscroll_limit);
        var pos = this._vscrollmng._pos;
        var body = this._bodyBand;

        if (pos > vscroll_limit)
            pos = vscroll_limit;

        if (this._aniframe_rowscroll_float)
            this._aniframe_rowscroll_float.stop();

        this._aniframe_rowscroll_end.stop();

        if (!callbacktimer && this._applytask)
        {
            this._applytask.destroy();
            this._applytask = null;
        }

        this._last_scroll_top = control_elem.scroll_top;
        this._toprowpos = this._getScreenTopRowPos(pos);
        this._bottomrowpos = this._getScreenBottomRowPos(pos);

        this._scroll_vpos_queue = [];

        if (this._isLazyAutoVscroll())
        {
            this._resetRowSizeListBodyDisplay();
            body._update_rows = body._matrix._adjustScrollRows(pos, true, undefined, undefined, true);
        }
        else
        {
            body._update_rows = body._matrix._adjustScrollRows(pos, true);
        }

        if (this._use_blindscroll)
        {
            this._setBlindBody(false);

            if (this._highlight_row_main)
                this._highlight_row_main.set_visible(false);
            if (this._highlight_row_sublast)
                this._highlight_row_sublast.set_visible(false);
            if (this._highlight_row_subcenter)
                this._highlight_row_subcenter.set_visible(false);
        }

        body._on_refresh_rows(true, undefined, false);
        this._no_use_onscroll_callback_after = true;

        if (this._is_performance_scroll)
        {
            this._absolutelyResetScrollPos(true);   // 시점차이로 인해 node.scrollTop과 vpos가 안맞는 경우 보정처리
            control_elem.setElementVScrollPos(pos);
            this._absolutelyResetScrollPos(false);
        }
        else
        {
            control_elem.setElementVScrollPos(pos);
        }

        if (this._isLazyAutoVscroll())
            this._resetScrollMax(true);

        this._updateSelector("vscroll", pos - this._last_scroll_top);
        this._adjustOverlayControls(false);

        if (this._is_variable_bodyrowsize)
            body._clearScrollDisplayRows();

        var ext_cnt = body._control_element._getExtendContainerCount();
        if (ext_cnt > 0)
        {
            this._absolutelyResetScrollPos(true);
            this._control_element.setElementHScrollPos(this._control_element.scroll_left);
            this._absolutelyResetScrollPos(false);
        }

        if (this._isflingend)
        {
            nexacro._OnceCallbackTimer.callonce(this, function ()
            {
                this._isflingend = undefined;
            }, 200);


        }
    };

    _pGrid._adjustGridScrollRows_callback = function (no_ani)
    {
        var control_elem = this._control_element;
        var vscroll_limit = Math.ceil(control_elem.vscroll_limit);
        var pos = this._vscrollmng._pos;
        var body = this._bodyBand;

        if (pos > vscroll_limit)
            pos = vscroll_limit;

        this._last_scroll_top = control_elem.scroll_top;
        this._toprowpos = this._getScreenTopRowPos(pos);
        this._bottomrowpos = this._getScreenBottomRowPos(pos);

        if (!no_ani)
        {
            if (this._moverow_frame > 0)
            {
                if (body._update_rows.length > 0)
                    this._aniframe_rowscroll.start();
                else
                    this._scroll_vpos_queue = [];
            }
            else
            {
                this._scroll_vpos_queue.pop();

                if (this._scroll_vpos_queue.length > 0)
                    this._aniframe_rowscroll.start();
            }
        }
        else
        {
            this._aniframe_rowscroll.stop();
            this._scroll_vpos_queue = [];
        }
        body._update_rows = body._matrix._adjustScrollRows(pos, false, this._moverow_frame);
        body._on_refresh_rows(true, undefined, true);
        this._no_use_onscroll_callback_after = true;
        control_elem.setElementVScrollPos(pos);
        this._updateSelector("vscroll", pos - this._last_scroll_top);
        this._adjustOverlayControls(false);

        var ext_cnt = body._control_element._getExtendContainerCount();
        if (ext_cnt > 0)
        {
            this._absolutelyResetScrollPos(true);
            this._control_element.setElementHScrollPos(this._control_element.scroll_left);
            this._absolutelyResetScrollPos(false);
        }
    };

    //------------------------------------------------------------------------------------------
    _pGrid._scroll_interval = 0;
    _pGrid._scroll_threshold = 1000;
    _pGrid._scroll_end_divider = 3;

    _pGrid._use_enhance_performance_scrolling = false;
    _pGrid._scroll_frame_interval = 10;
    _pGrid._is_vscroll_frame_ticking = false;
    _pGrid._adjustGridScrollRows_callback_onscroll_after2 = function (pos) // each row 방식
    {
        var body = this._bodyBand;
        var control_elem = this._control_element;
        var vscroll_limit = Math.ceil(control_elem.vscroll_limit);

        var vpos = this._vscrollmng._pos;
        if (vpos > vscroll_limit)
            vpos = vscroll_limit;

        if (pos !== undefined)
        {
            body._rowscroll_info = body._matrix._getScrollRowsInfo(vpos, this._moverow_frame, body._rowscroll_info);
            this._toprowpos = body._rowscroll_info.toprow;
            this._bottomrowpos = body._rowscroll_info.bottomrow;
        }

        var rows_len = body._matrix._rows.length;
        var scroll_info = body._rowscroll_info;
        var scrollmode = scroll_info.scrollmode;
        var framecnt = (scrollmode == 0 ? rows_len : scroll_info.framecnt * (1 + (scroll_info.skipped | 0)));
        var starttime = scroll_info.starttime;
        var lasttime = scroll_info.timestamp;

        var timestamp = (performance ? performance.now() : (new Date()));
        if (pos == undefined)
        {
            if (scrollmode > 0 && starttime != lasttime && (timestamp - lasttime) < this._scroll_interval)
            {
                scroll_info.skipped = (scroll_info.skipped | 0) + 1;
                this._aniframe_rowscroll.start();
                return;
            }
            lasttime = timestamp;
            this._is_vscroll_frame_ticking = false;
        }

        var bcontinue = false;
        if (!this._is_vscroll_frame_ticking)
        {
            bcontinue = body._matrix._adjustScrollRows2(vpos, true, framecnt);
            body._on_refresh_rows(true, undefined, true);
        }

        timestamp = (performance ? performance.now() : (new Date()));

        if (this._use_enhance_performance_scrolling)
        {
            var timestamp_post = timestamp, singleframe_duration = 0;
            while (bcontinue && (timestamp - lasttime + singleframe_duration) <= this._scroll_frame_interval)
            {
                bcontinue = body._matrix._adjustScrollRows2(vpos, true, framecnt);
                body._on_refresh_rows(true, undefined, true);

                timestamp_post = (performance ? performance.now() : (new Date()));
                singleframe_duration = timestamp_post - timestamp;
                timestamp = timestamp_post;
            }
        }
        scroll_info.timestamp = timestamp;

        if (bcontinue)
        {
            if (!this._is_vscroll_frame_ticking)
            {
                this._aniframe_rowscroll.start();
                this._is_vscroll_frame_ticking = true;
            }
        }

        this._adjustOverlayControls(false);
    };

    _pGrid._adjustGridScrollRows_callback_onscroll_after = function (pos) // mobile onscroll callback / page, line 방식
    {
        if (this._no_use_onscroll_callback_after == true)
        {
            if (this._is_performance_scroll)
                this._aniframe_rowscroll.stop();
            this._is_vscroll_frame_ticking = false;

            this._no_use_onscroll_callback_after = false;
            return;
        }

        if (this._use_eachscroll)
            return this._adjustGridScrollRows_callback_onscroll_after2(pos);

        if (pos == undefined)
        {
            var body = this._bodyBand;
            pos = this._vscrollmng._pos;
            var control_elem = this._control_element;
            var vscroll_limit = Math.ceil(control_elem.vscroll_limit);

            if (pos > vscroll_limit)
                pos = vscroll_limit;

            body._update_rows = body._matrix._adjustScrollRows(pos, true, this._moverow_frame);

            if (this._moverow_frame > 0 && body._update_rows.length > 0)
                this._aniframe_rowscroll.start();

            body._on_refresh_rows(true, undefined, true);
            this._adjustOverlayControls(false);

            var ext_cnt = body._control_element._getExtendContainerCount();
            if (ext_cnt > 0)
            {
                this._absolutelyResetScrollPos(true);
                this._control_element.setElementHScrollPos(this._control_element.scroll_left);
                this._absolutelyResetScrollPos(false);
            }
            this._is_vscroll_frame_ticking = false;
        }
        else
        {
            var body = this._bodyBand;
            pos = this._vscrollmng._pos;
            var control_elem = this._control_element;
            var vscroll_limit = Math.ceil(control_elem.vscroll_limit);

            if (pos > vscroll_limit)
                pos = vscroll_limit;

            this._toprowpos = this._getScreenTopRowPos(pos);
            this._bottomrowpos = this._getScreenBottomRowPos(pos);

            if (!this._is_vscroll_frame_ticking)
            {
                this._aniframe_rowscroll.start();
                this._is_vscroll_frame_ticking = true;
            }
        }
    };

    _pGrid._adjustGridScrollRows_callback_onscroll = function () // mobile onscroll callback / page, line 방식
    {
        this._no_use_onscroll_callback_after = false;

        var pos = this._vscrollmng._pos;
        var control_elem = this._control_element;
        var vscroll_limit = Math.ceil(control_elem.vscroll_limit);

        if (pos > vscroll_limit)
            pos = vscroll_limit;

        this._last_scroll_top = control_elem.scroll_top;
        control_elem.setElementVScrollPos(pos);
        this._updateSelector("vscroll", pos - this._last_scroll_top);
    };

    _pGrid._callback_onvscroll = _pGrid._adjustGridScrollRows_callback_onscroll_after;

    _pGrid._applytask = null;
    _pGrid._startApplyTimer = function (kind, applytime)
    {
        var pthis = this;

        if (this._applytask)
        {
            this._applytask.destroy();
            this._applytask = null;
        }

        this._applytask = new nexacro._CallbackTimer(this, function (id) { return pthis._callbackApplyTimer(kind); }, applytime);
        this._applytask.start();
    };

    _pGrid._callbackApplyTimer = function (kind)
    {
        if (kind == "v")
            this._adjustGridScrollRows_callback_end(true);
        else if (kind == "h")
            this._adjustGridScrollCols_callback_end(true);

        this._applytask.destroy();
        this._applytask = null;
    };

    _pGrid._is_over_scroll = 0;
    _pGrid._on_beforescroll = function (prehpos, prevpos, posthpos, postvpos, evttype, evtkind)
    {
        var hmove = Math.abs(prehpos - posthpos);
        var vmove = Math.abs(prevpos - postvpos);

        if (hmove < vmove)
        {
            if (prevpos > postvpos || (prevpos < postvpos && this._vscrollmng._orgmax != prevpos))
            {
                if (evttype == "linedown")
                {
                    while (true)
                    {
                        var prev_scrollbar_pos = this._vscrollmng._pos;
                        this._vscrollmng.setPixelPos(postvpos, evtkind, true, true);

                        if (prev_scrollbar_pos == this._vscrollmng._pos)    // setPixelPos에서 _pos값 보정 후, 값이 달라질 때 까지..
                        {
                            postvpos++;
                            continue;
                        }

                        break;
                    }
                }
                else
                {
                    this._vscrollmng.setPixelPos(postvpos, evtkind, true, true);
                }

                this.on_vscroll(postvpos, evttype, evtkind);

                if (this._use_eachscroll || this._isLazyAutoVscroll())
                    this._startApplyTimer("v", 500);
            }
            else if (evttype == "trackend" || evttype == "trackstart")
            {
                this.on_vscroll(postvpos, evttype, evtkind);
            }
        }
        else if (hmove > vmove)
        {
            if (prehpos > posthpos || (prehpos < posthpos && this._hscrollmng._orgmax != prehpos))
            {
                this._hscrollmng.setPos(posthpos, evtkind, true);
                this.on_hscroll(posthpos, evttype, evtkind);

                if (this._is_performance_scroll)    // line, page
                    this._startApplyTimer("h", 10);
            }
            else if (evttype == "trackend" || evttype == "trackstart")
            {
                this.on_hscroll(posthpos, evttype, evtkind);
            }
        }
        else if (evttype == "trackend" || evttype == "trackstart")
        {
            if (evtkind == "vertical")
                this.on_vscroll(postvpos, evttype, evtkind);
            else if (evtkind == "horizontal")
                this.on_hscroll(posthpos, evttype, evtkind);
        }
    };

    _pGrid.on_vscroll = function (postvpos, evttype, evtkind)
    {
        if (this.scrolltype == "none" || this.scrolltype == "horizontal")
            return;

        this._is_over_scroll = 0;

        var vscroll = this._vscrollmng;

        if (!vscroll)
            return;

        if (this._scrollpixel != "all")
        {
            if (vscroll._pos > vscroll._orgmax)
                this._is_over_scroll = vscroll._pos - vscroll._orgmax;
        }

        var control_elem = this._control_element;

        if (!control_elem || !this._bodyBand || evttype == "trackstart" || evttype == "tracklastover" || evttype == "trackfirstover")
            return;

        if (evttype == "trackend" || evttype == "first" || evttype == "last")
            this._procRefreshDOM = true;

        this._aniframe_rowscroll_end._skipscrolltask = true;
        this._aniframe_rowscroll_end.stop();

        var cnt;
        var limit;

        if (this._is_performance_scroll && (!this._use_blindscroll || (evtkind != "fling" && evttype != "track" && evttype != "trackfirst" && evttype != "tracklast")))
        {
            if (evttype == "trackend")
                this._adjustGridScrollRows_callback_end();
            else
                this._adjustGridScrollRows_callback_onscroll();
        }
        else if (nexacro._isTouchInteraction && nexacro._Browser != "Runtime")   // mobile HTML only, runtime에서 반복 addrow시도시 animationframe이 잘 동작하지 않음.
        {
            if (evtkind == "mousewheel_v")
            {
                this._aniframe_rowscroll_end.start();
            }
            else if (this._use_blindscroll && evtkind == "fling")
            {
                limit = (this._bodyrowheight + this._floating_row_addsize) + this._floating_gap * 2;
                cnt = this._scroll_vpos_queue.push(postvpos);

                if (cnt == 1)
                {
                    if (this._bodyBand._getClientHeight() < limit)
                        this._aniframe_rowscroll_end.start();
                    else
                        this._aniframe_rowscroll_float.start();
                }
            }
            else
            {
                if (this._use_blindscroll || !evtkind)
                    this._aniframe_rowscroll_end.start();
                else
                    this._adjustGridScrollRows_callback_onscroll();
            }
        }
        else
        {
            if (evttype == "track" || evttype == "trackfirst" || evttype == "tracklast")
            {
                cnt = this._scroll_vpos_queue.push(postvpos);

                if (cnt == 1)
                {
                    if (this._use_blindscroll)
                    {
                        limit = (this._bodyrowheight + this._floating_row_addsize) + this._floating_gap * 2;
                        if (this._bodyBand._getClientHeight() < limit)
                            this._aniframe_rowscroll.start();
                        else
                            this._aniframe_rowscroll_float.start();
                    }
                    else
                    {
                        this._aniframe_rowscroll.start();
                    }
                }
            }
            else if (evtkind == "fling")  // fling animationframe 사용안함.
            {
                if (this._use_blindscroll)
                {
                    limit = (this._bodyrowheight + this._floating_row_addsize) + this._floating_gap * 2;

                    if (this._bodyBand._getClientHeight() < limit)
                        this._adjustGridScrollRows_callback(true);
                    else
                        this._floatingScrollRows_callback(true);
                }
                else
                {
                    this._adjustGridScrollRows_callback(true);
                }
            }
            else if (evttype != "trackstart")
            {
                this._adjustGridScrollRows_callback_end();
            }
        }

        this._procRefreshDOM = undefined;

        return true;
    };

    _pGrid._adjustGridScrollCols_callback = function ()
    {
        var control_elem = this._control_element;
        var pos = this._hscrollmng._pos;

        var hscroll_limit = control_elem.hscroll_limit;

        if (pos > hscroll_limit)
            pos = hscroll_limit;

        this._scroll_hpos_queue.pop();

        if (this._scroll_hpos_queue.length > 0)
        {
            this._aniframe_colscroll.start();
        }

        if (!nexacro._isTouchInteraction)
        {
            this._last_scroll_left = control_elem.scroll_left;
            this._control_element.setElementHScrollPos(pos);
            this._updateSelector("hscroll", pos - this._last_scroll_left);
        }

        var dir = pos - this._last_scroll_left;

        if (this._bodyBand)
            this._bodyBand._matrix._adjustColsDisplay(false, true, undefined, dir);
        if (this._headBand)
            this._headBand._matrix._adjustColsDisplay(false, true, undefined, dir);
        if (this._summBand)
            this._summBand._matrix._adjustColsDisplay(false, true, undefined, dir);

        this._adjustOverlayControls(false);
    };

    _pGrid._adjustGridScrollCols_callback2 = function (dir)
    {
        if (this._headBand)
            this._headBand._matrix._adjustColsDisplay2(dir);
        if (this._bodyBand)
            this._bodyBand._matrix._adjustColsDisplay2(dir);
        if (this._summBand)
            this._summBand._matrix._adjustColsDisplay2(dir);

        this._adjustOverlayControls(false);
    };

    _pGrid._adjustGridScrollCols_callback3 = function (dir, startcol, endcol, starttime, updatecol) // each 전용
    {
        //var control_elem = this._control_element;
        //var pos = this._hscrollmng._pos;
        //var hscroll_limit = control_elem.hscroll_limit;

        //if (pos > hscroll_limit)
        //  pos = hscroll_limit;

        var timestamp = (performance ? performance.now() : (new Date()));

        var nextcol, framecolcnt = 1;
        if (this._is_performance_scroll)
        {
            if (updatecol < 0)
            {
                this._bodyBand._matrix._adjustColsScrollEnd(startcol, endcol);
                return;
            }

            var duration = timestamp - starttime;
            if (duration > this._scroll_threshold)
            {
                framecolcnt = (endcol - startcol) / this._scroll_end_divider;
            }

            var start, end;
            if (dir > 0)
            {
                start = updatecol;
                end = endcol;
            }
            else if (dir < 0)
            {
                start = startcol;
                end = updatecol;
            }

            if (this._headBand)
                nextcol = this._headBand._matrix._adjustColsScroll(dir, start, end, framecolcnt);
            if (this._summBand)
                nextcol = this._summBand._matrix._adjustColsScroll(dir, start, end, framecolcnt);
            if (this._bodyBand)
                nextcol = this._bodyBand._matrix._adjustColsScroll(dir, start, end, framecolcnt);

            var bcontinue = false;
            if (dir > 0)
            {
                nextcol += 1;
                bcontinue = (nextcol <= endcol);
            }
            else if (dir < 0)
            {
                nextcol -= 1;
                bcontinue = (nextcol >= startcol);
            }

            if (bcontinue)
            {
                this._aniframe_colscroll.start();
            }
            else
            {
                if (this._bodyBand) 
                {
                    nextcol = -1;
                    this._aniframe_colscroll.start();
                }
            }
        }
        else
        {
            if (this._headBand)
                this._headBand._matrix._adjustColsDisplay2(dir);
            if (this._bodyBand)
                this._bodyBand._matrix._adjustColsDisplay2(dir);
            if (this._summBand)
                this._summBand._matrix._adjustColsDisplay2(dir);
        }

        this._adjustOverlayControls(false);

        return nextcol;
    };

    _pGrid._adjustGridScrollCols_callback_end = function ()
    {
        var pos = this._hscrollmng._pos;
        var control_elem = this._control_element;
        var hscroll_limit = control_elem.hscroll_limit;

        if (pos > hscroll_limit)
            pos = hscroll_limit;

        this._scroll_hpos_queue = [];

        if (this._aniframe_colscroll_end)
            this._aniframe_colscroll_end.stop();

        var dir = pos - this._last_scroll_left;

        this._last_scroll_left = this._control_element.scroll_left;
        this._control_element.setElementHScrollPos(pos);
        this._updateSelector("hscroll", pos - this._last_scroll_left);

        if (this._bodyBand)
            this._bodyBand._matrix._adjustColsDisplay(false, true, undefined, dir);
        if (this._headBand)
            this._headBand._matrix._adjustColsDisplay(false, true, undefined, dir);
        if (this._summBand)
            this._summBand._matrix._adjustColsDisplay(false, true, undefined, dir);

        this._adjustOverlayControls(false);
    };

    _pGrid._each_adjustGridScrollCols_callback = function (pthis, dir, start, end)
    {
        var starttime = (performance ? performance.now() : (new Date()));
        var updatecol = (dir > 0 ? start : (dir < 0 ? end : start));
        return function ()
        {
            updatecol = pthis._adjustGridScrollCols_callback3(dir, start, end, starttime, updatecol);
        };
    };

    _pGrid._adjustGridScrollCols_callback_onscroll_after = function (dir, pos, startcol, endcol)  // IE onscroll callback
    {
        if (!this._is_performance_scroll)
            return;

        if (this._last_scroll_left != pos)
        {
            this._last_scroll_left = pos;

            if (this._use_eachscroll)
            {
                this._aniframe_colscroll = new nexacro.AnimationFrame(this, this._each_adjustGridScrollCols_callback(this, dir, startcol, endcol));
                this._aniframe_colscroll.start();
            }
            else
            {
                this._aniframe_colscroll = new nexacro.AnimationFrame(this, this._adjustGridScrollCols_callback2(dir));
                this._aniframe_colscroll.start();
            }
        }
    };

    _pGrid._adjustGridScrollCols_callback_onscroll = function ()    // IE scrollleft 사용
    {
        var control_elem = this._control_element;
        this._no_use_onscroll_callback_after = false;
        var hscroll_limit = control_elem.hscroll_limit;
        var pos = this._hscrollmng._pos;

        if (pos > hscroll_limit)
            pos = hscroll_limit;

        this._last_scroll_left = control_elem.scroll_left;
        control_elem.setElementHScrollPos(pos);
        this._updateSelector("hscroll", pos - this._last_scroll_left);
    };

    _pGrid.on_hscroll = function (posthpos, evttype, evtkind)
    {
        if (this.scrolltype == "none" || this.scrolltype == "vertical")
            return;


        var control_elem = this._control_element;

        if (!control_elem || evttype == "tracklastover" || evttype == "trackfirstover")
            return;

        if (evttype == "trackend" || evttype == "first" || evttype == "last")
            this._procRefreshDOM = true;

        if (!this._aniframe_colscroll)
        {
            var pThis = this;
            this._scroll_hpos_queue = [];

            this._aniframe_colscroll = new nexacro.AnimationFrame(this, function () { pThis._adjustGridScrollCols_callback(); });
            this._aniframe_colscroll_end = new nexacro.AnimationFrame(this, function () { pThis._adjustGridScrollCols_callback_end(); });
        }
        else
            this._aniframe_colscroll_end.stop();

        if (this._is_performance_scroll)
        {
            this._aniframe_colscroll.stop();

            if (evttype == "trackend")
                this._adjustGridScrollCols_callback_end();
            else
                this._adjustGridScrollCols_callback_onscroll();
        }
        else
        {
            if (evttype == "track" || evttype == "trackfirst" || evttype == "tracklast")
            {
                var cnt = this._scroll_hpos_queue.push(posthpos);

                if (cnt == 1)
                    this._aniframe_colscroll.start();
            }
            else if (evttype != "trackstart")
            {
                this._adjustGridScrollCols_callback_end();
            }
        }
        this._procRefreshDOM = undefined;
        return true;
    };

    _pGrid._use_blindscroll = false;
    _pGrid.set_fastvscrolltype = function (v)
    {
        if (this._p_fastvscrolltype != v)
        {
            switch (v)
            {
                case "default":
                    this._float_updown = false;
                    this._float_center = false;
                    this._use_blindscroll = false;
                    this._float_move = false;
                    break;
                case "centerdisplay":
                    this._float_updown = false;
                    this._float_center = true;
                    this._use_blindscroll = true;
                    this._float_move = false;
                    break;
                case "topdisplay":
                    this._float_updown = false;
                    this._float_center = false;
                    this._use_blindscroll = true;
                    this._float_move = false;
                    break;
                case "topbottomdisplay":
                    this._float_updown = true;
                    this._float_center = false;
                    this._use_blindscroll = true;
                    this._float_move = false;
                    break;
                case "topcenterbottomdisplay":
                    this._float_updown = true;
                    this._float_center = true;
                    this._use_blindscroll = true;
                    this._float_move = false;
                    break;
                case "trackbarfollow":
                    this._float_updown = false;
                    this._float_center = false;
                    this._use_blindscroll = true;
                    this._float_move = true;
                    break;
                default:
                    return;
            }
            this._p_fastvscrolltype = v;
            this.on_apply_fastvscrolltype();
        }
    };

    _pGrid.on_apply_fastvscrolltype = function ()
    {
        this._destroyHighlightRow();
        this._createHighlightRow();

        if (!this._bodyBand)
            return;

        var pthis = this;

        if (this._use_blindscroll && !this._aniframe_rowscroll_float)
            this._aniframe_rowscroll_float = new nexacro.AnimationFrame(this, function () { pthis._floatingScrollRows_callback(); });
    };

    _pGrid._is_performance_scroll = false;
    _pGrid._use_eachscroll = false;
    _pGrid.set_scrolldisplaymode = function (v)
    {
        if (this._p_scrolldisplaymode != v)
        {
            switch (v)
            {
                case "normal":
                case "page":
                case "line":
                    this._p_scrolldisplaymode = v;
                    this.on_apply_scrolldisplaymode();
                    break;
            }
        }
    };

    _pGrid.on_apply_scrolldisplaymode = function ()
    {
        if (nexacro._Browser != "Runtime")
        {
            switch (this._p_scrolldisplaymode)
            {
                case "normal":
                    this._use_eachscroll = false;
                    this._moverow_frame = this._moverow_frame_df;
                    this._is_performance_scroll = false;
                    this._use_enhance_performance_scrolling = false;
                    break;
                case "page":
                    this._use_eachscroll = false;
                    this._moverow_frame = this._moverow_frame_df;
                    this._is_performance_scroll = true;
                    this._use_enhance_performance_scrolling = false;
                    break;
                case "line":
                    this._use_eachscroll = true;
                    this._moverow_frame = 1;
                    this._is_performance_scroll = true;
                    this._use_enhance_performance_scrolling = true;
                    break;
                default:
                    return;
            }
        }

        if (this._aniframe_rowscroll)
        {
            this._aniframe_rowscroll.destroy();
            this._aniframe_rowscroll = null;
        }

        if (this._aniframe_colscroll)
        {
            this._aniframe_colscroll.destroy();
            this._aniframe_colscroll = null;
        }

        var pThis = this;
        if (!this._aniframe_rowscroll_end)
            this._aniframe_rowscroll_end = new nexacro.AnimationFrame(this, function () { pThis._adjustGridScrollRows_callback_end(); });

        if (this._is_performance_scroll || (nexacro._isTouchInteraction && nexacro._Browser != "Runtime"))
        {
            if (this._bodyBand)
                this._bodyBand._control_element._setOnScrollCallbackTarget(this);

            this._aniframe_rowscroll = new nexacro.AnimationFrame(this, function () { pThis._adjustGridScrollRows_callback_onscroll_after(); });    // scrolltop -> onscroll -> callback call
        }
        else
        {
            this._aniframe_rowscroll = new nexacro.AnimationFrame(this, function () { pThis._adjustGridScrollRows_callback(); });
        }
    };

    _pGrid._isWheelScrollable = function (delta)
    {
        var control_elem = this._control_element;
        if (!control_elem) return false;

        var st = control_elem.scroll_top;
        var sh = control_elem.container_maxheight;
        var ch = this._getBodyClientSize()[1];

        if ((st + ch >= sh && delta < 0) || (st == 0 && delta > 0))
            return false;

        return true;
    };

    _pGrid._wheel_delta = 120;
    _pGrid._setVScrollDefaultAction = function (wheelDelta)
    {
        // IE는 wheelDelta 값이 grid의 크기에 따라 달라짐..120 값으로 보정해서 사용해야됨.
        if (this.scrolltype == "none" || this.scrolltype == "horizontal")
            return false;

        var absdelta = Math.abs(wheelDelta);
        var pos, max;
        var vscroll = this._vscrollmng;
        var prevpos = vscroll.pos;
        var cnt = Math.floor(absdelta / this._wheel_delta);

        if (cnt == 0)
            cnt = 1;

        var scrollrow = (this._p_wheelscrollrow * cnt);

        if (this._scrollpixel != "all")
        {
            if (wheelDelta < 0)
            {
                if (vscroll.max > vscroll.pos)
                {
                    pos = vscroll.pos + scrollrow;
                }
                else
                {
                    vscroll.setPixelPos(vscroll._pos - wheelDelta, "mousewheel_v");
                    if (prevpos != vscroll.pos)
                        return true;

                    return false;
                }
            }
            else
            {
                if (vscroll.min < vscroll.pos)
                {
                    pos = vscroll.pos - scrollrow;
                }
                else
                {
                    vscroll.setPixelPos(vscroll._pos - wheelDelta, "mousewheel_v");
                    if (prevpos != vscroll.pos)
                        return true;

                    return false;
                }
            }
        }
        else
        {
            // wheel 사용시 scrollpixel 이 all인 경우 _pos 값 사용 (pixel -> rowpos)
            if (wheelDelta < 0)
            {
                pos = vscroll._scroll_reverse_convert(vscroll._pos, true)[0];
                max = vscroll._scroll_reverse_convert(vscroll._max, true)[0];

                if (max > pos)
                {
                    pos += scrollrow;
                }
                else
                {
                    vscroll.setPixelPos(vscroll._pos - wheelDelta, "mousewheel_v");

                    if (prevpos != vscroll.pos)
                        return true;

                    return false;
                }
            }
            else
            {
                pos = vscroll._scroll_reverse_convert(vscroll._pos, true)[0];
                pos -= scrollrow;
            }
        }

        vscroll.setRowPos(this._rowToPageRow(pos + this._getFixRowCnt()), "mousewheel_v");

        if (prevpos != vscroll.pos)
            return true;

        return false;
    };

    _pGrid._makeEventInfo = function (cellobj, subcellobj, from_refer_comp)
    {
        var obj = { cell: -1, col: -1, row: -9, subrow: -1, mergecell: -1, mergecol: -1, mergerow: -1, pivotindex: -9 };

        if (cellobj && cellobj._type_name == "GridCellControl")
        {
            obj.cell = cellobj._cellidx;
            obj.col = cellobj._refinfo._col;
            obj.row = this._getDataRow(cellobj._rowidx);
            obj.subrow = cellobj._refinfo._row;

            if (subcellobj)
            {
                obj.col += subcellobj._refinfo._col;
                obj.mergecell = subcellobj._cellidx;
                obj.mergecol = subcellobj._refinfo._col;
                obj.mergerow = subcellobj._refinfo._row;
            }
        }
        else
        {
            var band = this._findBandObj(from_refer_comp);

            if (band)
            {
                if (band.id == "head")
                    obj.row = -1;
                else if (band.id == "summary")
                    obj.row = -2;
            }
        }
        return obj;
    };

    //==============================================================================
    //nexacro.Grid : Event Handlers
    //==============================================================================
    _pGrid.on_fire_onimageerror = function (obj, url, row, cell)
    {
        // GridImageControl fail loading image
        if (this.onimageerror && this.onimageerror._has_handlers)
        {
            var errormsg = nexacro._getErrorMessge("comm_fail_loadinvalidurl", url);
            var evt = new nexacro.GridImageErrorEventInfo(obj, "onimageerror", "ObjecrError", errormsg, url, row, cell);
            var ret = this.onimageerror._fireEvent(this, evt);
            return ret;
        }
        return true;
    };

    _pGrid.on_fire_sys_onslideend = function (elem, touch_manager, touchinfos, xaccvalue, yaccvalue, xdeltavalue, ydeltavalue, from_comp, from_refer_comp)
    {
        if (this._aniframe_colscroll_end)
            this._aniframe_colscroll_end.start();
        if (this._aniframe_rowscroll_end)
            this._aniframe_rowscroll_end.start();

        this._applyResizer();
        return nexacro.Component.prototype.on_fire_sys_onslideend.call(this, elem, touch_manager, touchinfos, xaccvalue, yaccvalue, xdeltavalue, ydeltavalue, from_comp, from_refer_comp);
    };

    _pGrid.on_fire_sys_onflingend = function (/*elem, fling_handler, xstartvalue, ystartvalue, xdeltavalue, ydeltavalue, touchlen, from_comp, from_refer_comp*/)
    {
        if (this._aniframe_colscroll_end)
            this._aniframe_colscroll_end.start();
        if (this._aniframe_rowscroll_end)
        {
            this._aniframe_rowscroll_end._skipscrolltask = undefined;
            this._aniframe_rowscroll_end.start();
        }

        this._isflingend = true;

        return true;
    };

    _pGrid._on_nodataareaclick = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        if (!this._is_alive) return;
        if (this._p_enable) this.on_fire_onnodataareaclick(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
        return true;
    };

    _pGrid.on_fire_onnodataareaclick = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        if (this.onnodataareaclick && this.onnodataareaclick._has_handlers)
        {
            var evt = new nexacro.MouseEventInfo(from_comp, "onnodataareaclick", button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
            return this.onnodataareaclick._fireEvent(this, evt);
        }
        return true;
    };

    _pGrid._on_nodataareadblclick = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        if (!this._is_alive) return;
        if (this._p_enable) this.on_fire_onnodataareadblclick(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
        return true;
    };

    _pGrid.on_fire_onnodataareadblclick = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        if (this.onnodataareadblclick && this.onnodataareadblclick._has_handlers)
        {
            var evt = new nexacro.MouseEventInfo(from_comp, "onnodataareadblclick", button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
            return this.onnodataareadblclick._fireEvent(this, evt);
        }
        return true;
    };

    _pGrid.on_fire_user_ondragenter = function (src_comp, src_refer_comp, dragdata, userdata, datatype, filelist,
        button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        if (this._noFireDragFlag == true || (src_comp && src_comp._selectscrollmode && (src_comp._selectscrollmode == "scroll")))
            return true;

        var cellobj = from_refer_comp;
        cellobj = this._findCellObj(cellobj);

        if (cellobj)
        {
            if (cellobj.parentcell)
                cellobj = cellobj.parentcell;
        }

        var posobj = this._recalcXY(cellobj, canvasX, canvasY, false, from_refer_comp);
        canvasX = posobj.canvasX;
        canvasY = posobj.canvasY;
        clientX = posobj.clientX;
        clientY = posobj.clientY;

        return nexacro.Component.prototype.on_fire_user_ondragenter.call(this, src_comp, src_refer_comp, dragdata, userdata, datatype, filelist,
            button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
    };

    _pGrid.on_fire_user_ondragleave = function (src_comp, src_refer_comp, dragdata, userdata, datatype, filelist,
        button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        if (this._noFireDragFlag == true || (src_comp && src_comp._selectscrollmode && (src_comp._selectscrollmode == "scroll")))
            return true;

        var cellobj = from_refer_comp;
        cellobj = this._findCellObj(cellobj);

        if (cellobj)
        {
            if (cellobj.parentcell)
                cellobj = cellobj.parentcell;
        }

        var posobj = this._recalcXY(cellobj, canvasX, canvasY, false, from_refer_comp);
        canvasX = posobj.canvasX;
        canvasY = posobj.canvasY;
        clientX = posobj.clientX;
        clientY = posobj.clientY;

        return nexacro.Component.prototype.on_fire_user_ondragleave.call(this, src_comp, src_refer_comp, dragdata, userdata, datatype, filelist,
            button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
    };

    _pGrid.on_fire_user_ondragmove = function (src_comp, src_refer_comp, dragdata, userdata, datatype, filelist,
        button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        var cellobj = from_refer_comp;
        cellobj = this._findCellObj(cellobj);

        if (from_refer_comp && from_refer_comp.parent instanceof nexacro._GridGroupControl)
        {
            if (this._groupdragcell)
            {
                var dragcursor = nexacro.CursorObject("copy");
                from_refer_comp._updateCursor(dragcursor);
            }
        }

        var trackInfo = nexacro._cur_track_info;
        if (this._noFireDragFlag == true)
        {
            if (trackInfo && trackInfo.target && trackInfo.target._is_tracking == true && (this._resizer_rowctrl == trackInfo.target || this._resizer_colctrl == trackInfo.target))
            {
                trackInfo.target._on_movetrack(trackInfo.distX, trackInfo.distY);
            }
            return true;
        }

        var ret = false;
        var subcellobj;

        if (cellobj)
        {
            if (cellobj.parentcell)
            {
                subcellobj = cellobj;
                cellobj = cellobj.parentcell;
            }
        }

        var posobj = this._recalcXY(cellobj, canvasX, canvasY, false, from_refer_comp);
        canvasX = posobj.canvasX;
        canvasY = posobj.canvasY;
        clientX = posobj.clientX;
        clientY = posobj.clientY;

        if (!src_comp || !src_comp._selectscrollmode || src_comp._selectscrollmode && (src_comp._selectscrollmode !== "scroll"))
        {
            if (this.ondragmove && this.ondragmove._has_handlers)
            {
                var evtinfo = this._makeEventInfo(cellobj, subcellobj, from_refer_comp);
                var cell = evtinfo.cell;
                var col = evtinfo.col;
                var mergecell = evtinfo.mergecell;
                var mergecol = evtinfo.mergecol;
                var mergerow = evtinfo.mergerow;
                var pivotindex = evtinfo.pivotindex;
                var row = evtinfo.row;
                var subrow = evtinfo.subrow;

                var evt = new nexacro.GridDragEventInfo(this, "ondragmove", dragdata, userdata, datatype, filelist, src_comp, src_refer_comp, from_comp, from_refer_comp, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, cell, col, mergecell, mergecol, mergerow, pivotindex, row, subrow, meta_key);

                ret = this.ondragmove._fireUserEvent(this, evt);
            }
        }

        if (trackInfo && trackInfo.target && trackInfo.target._is_tracking == true && (this._resizer_rowctrl == trackInfo.target || this._resizer_colctrl == trackInfo.target))
        {
            trackInfo.target._on_movetrack(trackInfo.distX, trackInfo.distY);
        }
        return ret;
    };

    _pGrid.on_fire_sys_ondragmove = function (src_comp, src_refer_comp, dragdata, userdata, datatype, filelist,
        button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, xdeltavalue, ydeltavalue, meta_key)
    {
        if (this._selectscrollmode == "select")
        {
            if (!this._is_drag_sameselect)
            {
                return this._areaselectMove(from_refer_comp, canvasX, canvasY);
            }
            else
            {
                this._is_drag_selecting = true;
            }
        }
        else
        {
            return nexacro.Component.prototype.on_fire_sys_ondragmove.call(this, src_comp, src_refer_comp, dragdata, userdata, datatype, filelist,
                button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, xdeltavalue, ydeltavalue, meta_key);
        }

    };

    _pGrid._noFireDragFlag = false;
    _pGrid.on_fire_user_ondrag = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, self_refer_comp, meta_key)
    {
        var cellobj = from_refer_comp;
        cellobj = this._findCellObj(cellobj);

        var subcellobj;
        if (cellobj)
        {
            if (cellobj.parentcell)
            {
                subcellobj = cellobj;
                cellobj = cellobj.parentcell;
            }
        }
        this._noFireDragFlag = false;

        var evt = null;
        var userdata = null;
        var dragdata = this._getDragData();
        var ret = null;

        this._drag_start_obj = from_refer_comp;

        if (this.ondrag && this.ondrag._has_handlers)
        {
            var posobj = this._recalcXY(cellobj, canvasX, canvasY, false, from_refer_comp);
            canvasX = posobj.canvasX;
            canvasY = posobj.canvasY;
            clientX = posobj.clientX;
            clientY = posobj.clientY;

            var evtinfo = this._makeEventInfo(cellobj, subcellobj, from_refer_comp);
            var cell = evtinfo.cell;
            var col = evtinfo.col;
            var mergecell = evtinfo.mergecell;
            var mergecol = evtinfo.mergecol;
            var mergerow = evtinfo.mergerow;
            var pivotindex = evtinfo.pivotindex;
            var row = evtinfo.row;
            var subrow = evtinfo.subrow;
            evt = new nexacro.GridDragEventInfo(this, "ondrag", this._getDragData(), null, "text", null, this, self_refer_comp, from_comp, from_refer_comp, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, cell, col, mergecell, mergecol, mergerow, pivotindex, row, subrow, meta_key);

        }
        if (this._selectscrollmode !== "scroll")
        {
            if (evt)
            {
                if (this.ondrag._fireUserEvent(this, evt) == true)
                {
                    ret = [true, this, self_refer_comp, evt.dragdata, evt._p_userdata];
                }
                else if (this.ondrag.defaultprevented == true)
                    ret = [false, this, self_refer_comp, evt.dragdata, evt._p_userdata];
            }
        }
        else
        {
            this._noFireDragFlag = true;
        }



        var resize_cursor;
        var resizer = false;
        if (this._resizer_rowctrl && this._resizer_rowctrl._is_tracking == true)
        {
            resize_cursor = nexacro.CursorObject("row-resize");
            this._setGlobalCursor(resize_cursor, cellobj, cellobj);
            resizer = true;

        }
        else if (this._resizer_colctrl && this._resizer_colctrl._is_tracking == true)
        {
            resize_cursor = nexacro.CursorObject("col-resize");
            this._setGlobalCursor(resize_cursor, cellobj, cellobj);
            resizer = true;

        }
        else if (cellobj && cellobj._type_name == "GridCellControl" && cellobj._rowidx == -1)
        {
            if (this._selectscrollmode != "scroll")
            {
                var cellinfo = cellobj._refinfo;

                if (this._p_cellmovingtype != "none" && cellinfo._groupcol < 0)
                {
                    var colidx = cellinfo._col;
                    var info0 = this._getColMergeInfo("head", colidx);
                    var info1 = this._getColMergeInfo("body", colidx);
                    var info2 = this._getColMergeInfo("summ", colidx);
                    var dragcursor = nexacro.CursorObject("move");

                    if (info0[1] == 1 && (info1 == null || info1[1] == 1) && (info2 == null || info2[1] == 1))
                    {
                        this._movingcell = cellobj;
                        cellobj.parent._setTempCursor(dragcursor);
                        //this._noFireDragFlag = true;
                    }
                }
                else
                {
                    this._movingcell = null;
                }

                var groupfield = cellinfo._getAttrValue(cellinfo._p_groupcolumn, -1);

                if (groupfield)
                {
                    this._groupdragcell = cellobj;

                    var dragcursor = nexacro.CursorObject("move");
                    cellobj.parent._setTempCursor(dragcursor);
                }
                else
                {
                    this._groupdragcell = null;
                }
            }
            else
            {
                this._movingcell = null;
                this._groupdragcell = null;
            }

            if (this._movingcell != null || this._groupdragcell != null)
            {
                if (ret)   // fireevent handler
                {
                    this._noFireDragFlag = !ret[0];
                    ret[0] = true;
                }
                else
                {
                    this._noFireDragFlag = true;
                    ret = [true, this, self_refer_comp, dragdata, userdata];
                }
            }
            else
            {
                if (this._selectscrollmode == "scroll")
                    ret = [this._noFireDragFlag, this, self_refer_comp, dragdata, userdata];
            }
        }
        else if (this._selectscrollmode == "scroll")
        {
            ret = [this._noFireDragFlag, this, self_refer_comp, dragdata, userdata];
        }

        if (!ret)
        {
            ret = [false];
        }

        if (this._noFireDragFlag == true)
        {
            var dragInfo = nexacro._cur_drag_info;
            if (dragInfo)
                dragInfo.isSelfAction = true;
        }
        return ret;
    };
    // cellmoving type 때문에 재정의 필요함 
    _pGrid._on_bubble_drag = function (elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, fire_comp, refer_comp, meta_key)
    {
        if (!this._is_alive) return;
        var clientXY, canvas;
        var pThis;
        var is_parent_bubble = false;
        var ret;
        var bubblefire = false;
        if (event_bubbles === undefined) //this is fire_comp or subcontrol
        {
            var is_subcontrol_bubble;

            if (!refer_comp)
            {
                refer_comp = this;

            }

            pThis = this._getFromComponent(this);

            if (this._is_subcontrol)
            {
                is_subcontrol_bubble = true;
            }
            else
            {
                if (this._p_visible && this._isEnable())
                {
                    is_subcontrol_bubble = false;
                    clientXY = this._getClientXY(canvasX, canvasY);

                    event_bubbles = this.on_fire_user_ondrag(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientXY[0], clientXY[1], this, refer_comp, refer_comp, meta_key);
                    is_parent_bubble = (event_bubbles[0] == true && this._noFireDragFlag == true && this._selectscrollmode != "scroll");
                    if (!event_bubbles || event_bubbles[0] !== true)
                    {
                        if (!this.ondrag || (pThis && (pThis.ondrag && !pThis.ondrag.defaultprevented)))
                        {
                            this.on_fire_sys_ondrag(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientXY[0], clientXY[1], this, refer_comp, refer_comp, meta_key);
                        }
                    }
                }
            }

            if (!event_bubbles || event_bubbles[0] !== true || is_parent_bubble)
            {
                if (pThis && (!pThis.ondrag || (pThis.ondrag && !pThis.ondrag.stoppropagation)) && !this._window && this.parent && !this.parent._is_application)
                {
                    canvas = this._getRecalcCanvasXY(elem, canvasX, canvasY);

                    canvasX = canvas[0];
                    canvasY = canvas[1];
                    if (is_subcontrol_bubble)
                    {
                        ret = this.parent._on_bubble_drag(elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, event_bubbles, this, refer_comp, meta_key);
                    }
                    else
                    {
                        ret = this.parent._on_bubble_drag(elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, false, this, refer_comp, meta_key);
                    }
                    bubblefire = true;


                }
            }
            if (!is_parent_bubble && !this._noFireDragFlag == true && bubblefire == true)
                return ret;
            return event_bubbles;
        }
        else
        {
            if ((!event_bubbles || event_bubbles[0] !== true || (event_bubbles[0] == true && this._noFireDragFlag == true)) && this.parent && !this.parent._is_application)
            {
                clientXY = this._getClientXY(canvasX, canvasY);
                if (this._p_visible && this._isEnable())
                {
                    event_bubbles = this.on_fire_user_ondrag(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientXY[0], clientXY[1], this, refer_comp, this, meta_key);
                    is_parent_bubble = (event_bubbles[0] == true && this._noFireDragFlag == true && this._selectscrollmode != "scroll");
                }
                if (!event_bubbles || event_bubbles[0] !== true || is_parent_bubble)
                {
                    pThis = this._getFromComponent(this);

                    if (this._p_visible && this._isEnable())
                    {
                        if (pThis && (!pThis.ondrag || (pThis.ondrag && !pThis.ondrag.defaultprevented)))
                        {
                            this.on_fire_sys_ondrag(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientXY[0], clientXY[1], this, refer_comp, this, meta_key);
                        }
                    }

                    if (pThis && (!pThis.ondrag || (pThis.ondrag && !pThis.ondrag.stoppropagation)) && !this._window && this.parent && !this.parent._is_application)
                    {
                        canvas = this._getRecalcCanvasXY(elem, canvasX, canvasY);

                        canvasX = canvas[0];
                        canvasY = canvas[1];

                        ret = this.parent._on_bubble_drag(elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, false, fire_comp, refer_comp, meta_key);
                        bubblefire = true;
                    }
                }
            }
            if (!is_parent_bubble && !this._noFireDragFlag == true && bubblefire == true)
                return ret;
            return event_bubbles;
        }
    };
    _pGrid.on_fire_user_ondrop = function (src_comp, src_refer_comp, dragdata, userdata, datatype, filelist, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        var cellobj = from_refer_comp;
        cellobj = this._findCellObj(cellobj);

        var subcellobj;
        if (cellobj)
        {
            if (cellobj.parentcell)
            {
                subcellobj = cellobj;
                cellobj = cellobj.parentcell;
            }
        }

        var posobj = this._recalcXY(cellobj, canvasX, canvasY, false, from_refer_comp);
        canvasX = posobj.canvasX;
        canvasY = posobj.canvasY;
        clientX = posobj.clientX;
        clientY = posobj.clientY;

        if (this._resizer_rowctrl && this._resizer_rowctrl._is_tracking == true)
        {
            this._setGlobalCursor(null, cellobj, cellobj);
        }
        else if (this._resizer_colctrl && this._resizer_colctrl._is_tracking == true)
        {
            this._setGlobalCursor(null, cellobj, cellobj);
        }
        else if (this._p_cellmovingtype != "none" && this._movingcell) // 다른 Grid에서 부터 drag되어 drop될경우 this._movingcell == null
        {
            var movingcell = this._movingcell;
            var format = this._curFormat;

            movingcell.parent._setTempCursor(null);

            if (movingcell && movingcell._is_alive && movingcell != cellobj && cellobj._rowidx == -1)
            {
                var fromcol = movingcell._refinfo._col;
                //var fromidx = movingcell._refinfo._cellidx;
                var tocol = cellobj._refinfo._col;
                var fromcolspan = movingcell._refinfo._colspan;

                var info = this._getColMergeInfo("head", tocol);
                tocol = info[0];
                var tocolspan = info[1];

                this._autofitcol_rate = [];
                format._moveColumn(fromcol, tocol, fromcolspan, tocolspan, this._p_cellmovingtype);

                this._initChecked();
                this._addRefreshContents("cellmoving", this._headBand);
                this._addRefreshContents("cellmoving", this._bodyBand);
                this._addRefreshContents("cellmoving", this._summBand);
            }
            this._movingcell = null;
        }

        if (this._groupdragcell)
        {
            var groupdragcell = this._groupdragcell;

            groupdragcell.parent._setTempCursor(null);

            var refc = from_refer_comp;

            while (refc)
            {
                refc._updateCursor(null);

                if (refc instanceof nexacro._GridGroupControl || refc instanceof nexacro.Grid)
                    break;

                refc = refc.parent;
            }

            if (groupdragcell && groupdragcell._rowidx == -1)
            {
                var fromcellinfo = groupdragcell._refinfo;
                var groupcolumn = fromcellinfo._getAttrValue(fromcellinfo._p_groupcolumn, -1);
                var is_groupbar = (from_refer_comp instanceof nexacro._GridGroupControl) || (from_refer_comp.parent instanceof nexacro._GridGroupControl);

                if (is_groupbar)
                {
                    var innerds = this._groupBar._innerdataset;
                    var selectrow = innerds.findRow("codecolumn", groupcolumn);
                    this._groupBar.setSelect(selectrow, true);
                    this._groupBar._setDataset();
                }
            }
            this._groupdragcell = null;
        }

        if (this._noFireDragFlag == true || (src_comp && src_comp._selectscrollmode && (src_comp._selectscrollmode == "scroll")))
        {
            if (src_comp && src_comp._noFireDragFlag)
            {
                src_comp._noFireDragFlag = false;
            }
            this._noFireDragFlag = false;
            return true;
        }

        if (this.ondrop && this.ondrop._has_handlers)
        {
            var evtinfo = this._makeEventInfo(cellobj, subcellobj, from_refer_comp);
            var cell = evtinfo.cell;
            var col = evtinfo.col;
            var mergecell = evtinfo.mergecell;
            var mergecol = evtinfo.mergecol;
            var mergerow = evtinfo.mergerow;
            var pivotindex = evtinfo.pivotindex;
            var row = evtinfo.row;
            var subrow = evtinfo.subrow;

            var evt = new nexacro.GridDragEventInfo(this, "ondrop", dragdata, userdata, datatype, filelist, src_comp, src_refer_comp, from_comp, from_refer_comp, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, cell, col, mergecell, mergecol, mergerow, pivotindex, row, subrow, meta_key);

            return this.ondrop._fireUserEvent(this, evt);
        }
        return false;
    };

    _pGrid._isDownUpScroll = function ()    // touch scroll
    {
        if ((this._down_scroll_top >= 0 && this._down_scroll_top != this._last_scroll_top) || this._isflingend)
            return true;

        return false;
    };

    _pGrid._mouseSelection = function (cellobj, ctrl_key, shift_key, canvasX, canvasY, from_comp, from_refer_comp, no_select, meta_key)
    {
        var editor = this._currentCellEditor;
        var fobj = from_refer_comp;
        var bhide = true;

        if (fobj._editor && fobj._editor == editor)
        {
            fobj = fobj._editor;
        }

        while (fobj)
        {
            if (fobj == editor || fobj instanceof nexacro.ScrollBarControl || (editor && editor._control == fobj))
            {
                bhide = false;
                break;
            }
            fobj = fobj.parent;
        }

        // cell 아닌 grid 내부 mouse click시 hide edit되지 않는 문제로 복원함
        this._select_cancel = true;

        if (bhide && editor)
        {
            this._hideEditor();
            editor = null;
        }

        var select_cancel = this._select_cancel;
        this._select_cancel = undefined;

        if (!select_cancel)
            return;
        if (this._resizer_colctrl && this._resizer_colctrl._is_tracking)
            return;
        if (this._resizer_rowctrl && this._resizer_rowctrl._is_tracking)
            return;
        if (this._isDownUpScroll())
            return;

        if (cellobj && cellobj._type_name == "GridCellControl")
        {
            this._lbuttondown_proc = true;
            cellobj._static_create = false; //for accessibility static editor

            var band = cellobj._band.id;
            var retn = this._on_grid_lbuttondown(cellobj, band, ctrl_key, shift_key, no_select, meta_key);

            if (!cellobj._is_alive || no_select) // selection후 cell이 recreate 된 상황
                return;

            var datarow;
            if (this._tryShowEditorCell)
            {
                if (nexacro._toBoolean(this._p_readonly) == false)
                {
                    if (retn)
                    {
                        var currow = this._selectinfo.currow;
                        var curcell = this._selectinfo.curcell;

                        if (currow < 0 || (this._beforeEditRowIdx != currow || this._beforeEditCellIdx != curcell))
                        {
                            var cell = cellobj;

                            datarow = this._getDataRow(cell._rowidx);
                            var rowtype = this._binddataset.getRowType(datarow);

                            if (rowtype != 16 && rowtype != 32)
                            {
                                if (cell._virtualmerge)
                                {
                                    this._showEditorMergeCell(cell, true);
                                }
                                else if (cell._hasEditor())
                                {
                                    cell._showEditor(true);

                                    this._beforeEditRowIdx = datarow;
                                    this._beforeEditCellIdx = cell._cellidx;
                                    this._showEditing = true;
                                }
                                else
                                {
                                    cell._setSubControlFocus(true);
                                }
                            }
                        }
                    }
                    else
                    {
                        this._onceTime_focus = true;
                        this._showEditor();
                        this._onceTime_focus = false;
                    }
                }
                this._tryShowEditorCell = false;
            }
            else
            {
                if (editor && this._showEditing)
                {
                    if (nexacro._OS == "iOS")
                        editor._apply_setfocus("touch");
                }
                else
                {
                    if (nexacro._isTouchInteraction)
                        cellobj._apply_setfocus("touch", true);
                }
            }

            if (this._p_selectchangetype == "down" && nexacro._toBoolean(this._p_readonly) == false)
            {
                datarow = this._getDataRow(cellobj._rowidx);
                var displayType = cellobj._refinfo._getDisplaytype(datarow);

                if (displayType == "checkboxcontrol" || displayType == "radioitemcontrol")
                {
                    if (this._p_cellclickbound == "cell")
                    {
                        cellobj._needToggle("onlbuttondown", cellobj);
                    }
                    else
                    {
                        let _env = this._env;
                        if (cellobj != from_refer_comp || (_env._a11ytype == 5 && _env._p_enableaccessibility))
                        {
                            if (cellobj._subComp)
                            {
                                if (cellobj._subComp._toggleCheck)
                                {
                                    if (cellobj.selected || datarow == -1)
                                        cellobj._subComp._toggleCheck();
                                }
                                else if (cellobj._subComp._itemSelect)
                                {
                                    cellobj._subComp._itemSelect();
                                }
                            }
                        }
                    }
                }
                else
                {
                    cellobj._needToggle("onlbuttondown", cellobj);
                }
            }
            this._lbuttondown_proc = false;
        }
    };

    _pGrid._common_fire_sys_lbuttondown = function (cellobj, ctrl_key, shift_key, canvasX, canvasY, from_comp, from_refer_comp, meta_key)
    {
        if (!this._is_alive) return;

        if (this._p_selectchangetype == "up")
        {
            if (this._isAreaSelect() && this._selectscrollmode == "select")
                this._mouseSelection(cellobj, ctrl_key, shift_key, canvasX, canvasY, from_comp, from_refer_comp, meta_key);
            else if (this._p_selecttype == "multirow")
                this._mouseSelection(cellobj, ctrl_key, shift_key, canvasX, canvasY, from_comp, from_refer_comp, true, meta_key);

            var win = this._getWindow();
            if (!win._cur_ldown_elem)   // alert이 뜨고 cancelevent가 발생되어 초기화된 상태
            {
                this._setdataobj = null;
            }
        }
        else
        {
            this._mouseSelection(cellobj, ctrl_key, shift_key, canvasX, canvasY, from_comp, from_refer_comp, meta_key);
        }

        if (this._is_down_act)
            this._on_last_lbuttonup(true);
    };

    _pGrid._common_fire_user_lbuttondown = function (cellobj, ctrl_key, shift_key, canvasX, canvasY, from_comp, from_refer_comp, meta_key)
    {
        if (!this._is_alive) return;

        canvasX = this._adjustRtlCanvasX(from_refer_comp, canvasX, false);
        this._resizerStart(canvasX, canvasY, cellobj, "down", from_refer_comp);

        var resizer_colctrl = this._resizer_colctrl;
        var resizer_rowctrl = this._resizer_rowctrl;
        var client = this._getClientXY(canvasX, canvasY);
        var win = this._getWindow();

        if (resizer_colctrl && resizer_colctrl._is_range)
        {
            resizer_colctrl._setTracksize(this._getClientHeight());

            if (resizer_colctrl._direction == "horizon")
            {
                resizer_colctrl.move(client[0], this._getClientTop(), 1, resizer_colctrl._tracksize);
            }

            nexacro._setTrackInfo(win, resizer_colctrl, win._curWindowX, win._curWindowY);
        }
        else if (resizer_rowctrl && resizer_rowctrl._is_range)
        {
            resizer_rowctrl._setTracksize(this._getClientWidth());

            if (resizer_rowctrl._direction == "vertical")
            {
                resizer_rowctrl.move(this._getClientLeft(), client[1], resizer_rowctrl._tracksize, 1);
            }

            nexacro._setTrackInfo(win, resizer_rowctrl, win._curWindowX, win._curWindowY);
        }

        //if (this._select_ctrl && this._isAreaSelect() && nexacro._isTouchInteraction)
        if (this._select_ctrl)
        {
            this._select_ctrl._initTrackInfo();
        }
    };

    _pGrid._recalcTouchInfosXY = function (obj, touchinfos, need_recalcXY, from_refer_comp)
    {
        var touchinfo, posobj;
        for (var i = 0, n = touchinfos.length; i < n; i++)
        {
            if (touchinfo = touchinfos[i])
            {
                posobj = this._recalcXY(obj, touchinfo.canvasx, touchinfo.canvasy, need_recalcXY, from_refer_comp);
                touchinfo.canvasx = posobj.canvasX;
                touchinfo.canvasy = posobj.canvasY;
                touchinfo.clientx = posobj.clientX;
                touchinfo.clienty = posobj.clientY;
            }
        }
    };

    _pGrid._getRecalcCanvasXY = function (elem, canvasX, canvasY)
    {
        if (this._recalcXY_info)
        {
            canvasX = this._recalcXY_info[0] + this._adjust_left;   // _recalcXY_info 에서 scroll 계산됨.
            canvasY = this._recalcXY_info[1] + this._adjust_top;
            this._recalcXY_info = null;
        }
        else
        {
            canvasX += this._adjust_left - this._scroll_left || 0;
            canvasY += this._adjust_top - this._scroll_top || 0;
        }
        // grid는 padding 사용 cell에서 함.
        return [canvasX, canvasY];
    };

    _pGrid._recalcXY = function (obj, canvasX, canvasY, need_recalcXY, from_refer_comp)
    {
        var real_canvasX = canvasX;
        var real_canvasY = canvasY;
        var rect;

        if (obj._type_name == "GridCellControl")
        {
            if (need_recalcXY) // cell에서의 좌표.
            {
                rect = obj._setPositionInGrid(null, false, true);

                real_canvasX = canvasX + rect.orgl;
                real_canvasY = canvasY + rect.orgt;
            }
            else // cell의 parent까지 계산된 좌표지만 fix영역은 계산되지 않음.
            {
                var area = obj._refinfo._area;
                var band = obj._band.id;

                if (area == "body")
                {
                    real_canvasX = canvasX + this._curFormat.leftWidth;
                    real_canvasX -= this._getScrollLeft();
                }
                else if (area == "right")
                {
                    var gridrow = obj._getRowControl();
                    rect = gridrow._getAreaRect(area);
                    var areal = rect.left;
                    real_canvasX = canvasX + areal;
                }

                if (band == "body" && !obj.parent._fixed)
                {
                    real_canvasY -= this._getScrollTop();
                    real_canvasY += this._fixed_height;
                }
            }
        }

        if (!(from_refer_comp instanceof nexacro.Grid))
        {
            if (from_refer_comp._type_name == "GridRowControl")
            {
                real_canvasY -= this._getScrollTop();
            }

            var cur_border = this._border || this._getCSSStyleValue("border", this._status);
            if (cur_border)
            {
                real_canvasX += cur_border.left._width;
                real_canvasY += cur_border.top._width;
            }
        }

        this._recalcXY_info = [real_canvasX, real_canvasY];
        var real_clientXY = this._getClientXY(real_canvasX, real_canvasY);

        return { canvasX: real_canvasX, canvasY: real_canvasY, clientX: real_clientXY[0], clientY: real_clientXY[1] };
    };

    _pGrid.on_fire_user_ontouchstart = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp, need_recalcXY)
    {
        return this.on_fire_ontouchstart(touchinfos, changedtouchinfos, from_comp, from_refer_comp, true, need_recalcXY);
    };

    _pGrid.on_fire_sys_ontouchstart = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp, need_recalcXY)
    {
        return this.on_fire_ontouchstart(touchinfos, changedtouchinfos, from_comp, from_refer_comp, false, need_recalcXY);
    };

    _pGrid._down_scroll_top = -1;
    _pGrid.on_fire_ontouchstart = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp, user_fire, need_recalcXY)
    {
        var cellobj = from_refer_comp;

        cellobj = this._findCellObj(cellobj);

        this._recalcTouchInfosXY(cellobj, changedtouchinfos, need_recalcXY, from_refer_comp);

        var touchinfo = nexacro._getFirstTouchInfo(changedtouchinfos);
        //  var subcellobj;

        if (cellobj)
        {
            if (cellobj.parentcell)
            {
                //            subcellobj = cellobj;
                cellobj = cellobj.parentcell;
            }
        }

        var retn = false;
        if (this.ontouchstart && this.ontouchstart._has_handlers)
        {
            /*
            var evtinfo = this._makeEventInfo(cellobj, subcellobj, from_refer_comp);
            var cell = evtinfo.cell;
            var col = evtinfo.col;
            var mergecell = evtinfo.mergecell;
            var mergecol = evtinfo.mergecol;
            var mergerow = evtinfo.mergerow;
            var pivotindex = evtinfo.pivotindex;
            var row = evtinfo.row;
            var subrow = evtinfo.subrow;
            */
            var evt = new nexacro.TouchEventInfo(this, "ontouchstart", touchinfos, changedtouchinfos, from_comp, from_refer_comp);

            if (user_fire)
                retn = this.ontouchstart._fireUserEvent(this, evt);
            else
                retn = this.ontouchstart._fireSysEvent(this, evt);
        }

        this._down_scroll_top = this._last_scroll_top;

        if (touchinfo)
        {
            if (user_fire)
            {
                this._common_fire_user_lbuttondown(cellobj, false, false, touchinfo.canvasx, touchinfo.canvasy, from_comp, from_refer_comp);
            }
            else
            {
                if (this._selectscrollmode == "select")
                {
                    if (cellobj._band && cellobj._band.id == "body")
                    {
                        //mobile에서도 selectchanetype이 down이면 touchstart에서 select되게함
                        //if (this._isAreaSelect())
                        if (this._isAreaSelect())
                            this._common_fire_sys_lbuttondown(cellobj, false, false, touchinfo.canvasx, touchinfo.canvasy, from_comp, from_refer_comp);
                    }
                }
            }
        }
        return retn;
    };

    _pGrid.on_fire_user_onlbuttondown = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key, need_recalcXY)
    {
        return this.on_fire_onlbuttondown(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, true, need_recalcXY, meta_key);
    };

    _pGrid.on_fire_sys_onlbuttondown = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key, need_recalcXY)
    {
        return this.on_fire_onlbuttondown(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, false, need_recalcXY, meta_key);
    };

    _pGrid.on_touch_lbuttondown_basic_action = function (elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, fire_comp, refer_comp, meta_key)
    {
        var retn = nexacro.Component.prototype.on_touch_lbuttondown_basic_action.call(this, elem, button, alt_key, ctrl_key, shift_key, canvasX, canvasY, screenX, screenY, fire_comp, refer_comp, meta_key);

        var cellobj = refer_comp;

        cellobj = this._findCellObj(cellobj);

        //     var subcellobj;
        if (cellobj)
        {
            if (cellobj.parentcell)
            {
                //           subcellobj = cellobj;
                cellobj = cellobj.parentcell;
            }
        }

        var posobj = this._recalcXY(cellobj, canvasX, canvasY, false, refer_comp);
        canvasX = posobj.canvasX;
        canvasY = posobj.canvasY;
        this._lastmouseentercell = cellobj;
        this._down_scroll_top = this._last_scroll_top;
        this._common_fire_user_lbuttondown(cellobj, ctrl_key, shift_key, canvasX, canvasY, fire_comp, refer_comp, meta_key);

        if (this._selectscrollmode == "select")
        {
            if (cellobj._band && cellobj._band.id == "body")
            {
                if (this._isAreaSelect())
                    this._common_fire_sys_lbuttondown(cellobj, ctrl_key, shift_key, canvasX, canvasY, fire_comp, refer_comp, meta_key);
            }
        }

        return retn;
    };

    _pGrid.on_fire_onlbuttondown = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, user_fire, need_recalcXY, meta_key)
    {
        var cellobj = from_refer_comp;

        cellobj = this._findCellObj(cellobj);

        var subcellobj;
        if (cellobj)
        {
            if (cellobj.parentcell)
            {
                subcellobj = cellobj;
                cellobj = cellobj.parentcell;
            }
        }

        // RP 100476 터치 환경에서 마우스 입력인 경우 초기화(터치 환경에서만 사용하는 변수로 초기값)
        if (!nexacro._SupportTouchEvent || button != "touch")
        {
            this._down_scroll_top = -1;
        }

        var posobj = this._recalcXY(cellobj, canvasX, canvasY, need_recalcXY, from_refer_comp);
        canvasX = posobj.canvasX;
        canvasY = posobj.canvasY;
        clientX = posobj.clientX;
        clientY = posobj.clientY;

        var retn = false;
        if (this.onlbuttondown && this.onlbuttondown._has_handlers)
        {
            var evtinfo = this._makeEventInfo(cellobj, subcellobj, from_refer_comp);
            //from_comp = this._getRootComponent(from_comp);

            var obj = this._getRootComponent(from_comp);
            var cell = evtinfo.cell;
            var col = evtinfo.col;
            var mergecell = evtinfo.mergecell;
            var mergecol = evtinfo.mergecol;
            var mergerow = evtinfo.mergerow;
            var pivotindex = evtinfo.pivotindex;
            var row = evtinfo.row;
            var subrow = evtinfo.subrow;

            var evt = new nexacro.GridMouseEventInfo(obj, "onlbuttondown", cell, col, mergecell, mergecol, mergerow, pivotindex, row, subrow, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);

            if (user_fire)
                retn = this.onlbuttondown._fireUserEvent(this, evt);
            else
                retn = this.onlbuttondown._fireSysEvent(this, evt);
        }


        //if (button != "touch")
        /* Touch Mobile 기기에서 lbuttondown event 처리 안함 */
        if (!nexacro._isTouchInteraction && button != "touch")
        {
            if (user_fire)
                this._common_fire_user_lbuttondown(cellobj, ctrl_key, shift_key, canvasX, canvasY, from_comp, from_refer_comp, meta_key);
            else
                this._common_fire_sys_lbuttondown(cellobj, ctrl_key, shift_key, canvasX, canvasY, from_comp, from_refer_comp, meta_key);
        }
        return retn;
    };

    _pGrid.on_fire_user_onrbuttondown = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        var cellobj = from_refer_comp;

        cellobj = this._findCellObj(cellobj);

        var subcellobj;
        if (cellobj)
        {
            if (cellobj.parentcell)
            {
                subcellobj = cellobj;
                cellobj = cellobj.parentcell;
            }
        }

        var posobj = this._recalcXY(cellobj, canvasX, canvasY, false, from_refer_comp);
        canvasX = posobj.canvasX;
        canvasY = posobj.canvasY;
        clientX = posobj.clientX;
        clientY = posobj.clientY;

        if (this.onrbuttondown && this.onrbuttondown._has_handlers)
        {
            var evtinfo = this._makeEventInfo(cellobj, subcellobj, from_refer_comp);
            //from_refer_comp = this._getRootComponent(from_refer_comp);

            var obj = this._getRootComponent(from_refer_comp);
            var cell = evtinfo.cell;
            var col = evtinfo.col;
            var mergecell = evtinfo.mergecell;
            var mergecol = evtinfo.mergecol;
            var mergerow = evtinfo.mergerow;
            var pivotindex = evtinfo.pivotindex;
            var row = evtinfo.row;
            var subrow = evtinfo.subrow;

            var evt = new nexacro.GridMouseEventInfo(obj, "onrbuttondown", cell, col, mergecell, mergecol, mergerow, pivotindex, row, subrow, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
            return this.onrbuttondown._fireUserEvent(this, evt);
        }
        return false;
    };

    _pGrid.on_fire_user_onmousedown = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        return this.on_fire_onmousedown(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, true, meta_key);
    };

    _pGrid.on_fire_sys_onmousedown = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        return this.on_fire_onmousedown(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, false, meta_key);
    };

    _pGrid.on_fire_onmousedown = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, user_fire, meta_key)
    {
        var cellobj = from_refer_comp;

        cellobj = this._findCellObj(cellobj);

        var subcellobj;
        if (cellobj)
        {
            if (cellobj.parentcell)
            {
                subcellobj = cellobj;
                cellobj = cellobj.parentcell;
            }
        }

        var posobj = this._recalcXY(cellobj, canvasX, canvasY, false, from_refer_comp);
        canvasX = posobj.canvasX;
        canvasY = posobj.canvasY;
        clientX = posobj.clientX;
        clientY = posobj.clientY;

        var retn = false;
        if (this.onmousedown && this.onmousedown._has_handlers)
        {
            var evtinfo = this._makeEventInfo(cellobj, subcellobj, from_refer_comp);
            //from_comp = this._getRootComponent(from_comp);

            var obj = this._getRootComponent(from_comp);
            var cell = evtinfo.cell;
            var col = evtinfo.col;
            var mergecell = evtinfo.mergecell;
            var mergecol = evtinfo.mergecol;
            var mergerow = evtinfo.mergerow;
            var pivotindex = evtinfo.pivotindex;
            var row = evtinfo.row;
            var subrow = evtinfo.subrow;

            var evt = new nexacro.GridMouseEventInfo(obj, "onmousedown", cell, col, mergecell, mergecol, mergerow, pivotindex, row, subrow, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);

            if (user_fire)
                retn = this.onmousedown._fireUserEvent(this, evt);
            else
                retn = this.onmousedown._fireSysEvent(this, evt);
        }

        return retn;
    };

    _pGrid._resetFixSize = function ()
    {
        var rowsizes = this._rowSizeList;
        var fixrow_height = 0, fix_height = 0;
        var srow = this._fixed_startrow;
        var erow = this._fixed_endrow;

        if (srow < 0)
            return;

        for (var i = this._rowToPageRow(0), n = rowsizes.length; i < n; i++)
        {
            fixrow_height += rowsizes[i];

            if (srow > i)
                continue;

            fix_height += rowsizes[i];

            if (erow == i)
                break;
        }

        this._fixed_height = fix_height;
        this._fixedrow_height = fixrow_height;

        this._updateHighlightrowPos();
    };

    _pGrid.setFixedRow = function (row)
    {
        this._setFixedRow(row, undefined);
    };

    _pGrid._setFixedRow = function (fixrow, no_redraw)
    {
        if (fixrow >= 0 && (this._hasTree || this._isPagination()))
            return;

        var bfix = (fixrow < 0) ? false : true;
        var srow, erow = this._endrowpos;

        srow = this._fixed_startrow;

        fixrow = this._rowToPageRow(fixrow);

        if (srow < 0)
            srow = this._toprowpos[0];

        if (fixrow >= 0 && (fixrow < srow || fixrow > erow))   // 화면에 있는 row안에서만 동작함.
            return;

        if (bfix)
        {
            if (this._fixed_height)
            {
                this._setFixedRow(-1);
                return;
            }
        }

        if (bfix)
        {
            var rowcnt = this._getGridRowCount();
            var toppos = this._toprowpos[0];
            var fixedheight = 0, fixedrow_height = 0;
            var bset = false;
            var rowheight = 0;
            var row;

            for (var i = 0; i < rowcnt; i++)
            {
                this._fixed_rowcnt++;
                row = this._rowToPageRow(i);
                rowheight = this._getRowSize(row);
                fixedrow_height += rowheight;

                if (row >= toppos)
                {
                    if (this._fixed_startrow < 0)
                        this._fixed_startrow = row;

                    fixedheight += rowheight;
                    bset = true;
                }

                if (row >= fixrow)
                    break;
            }

            if (bset)
            {
                this._fixedrow_height = fixedrow_height;
                this._fixed_endrow = fixrow;
                this._fixed_height = fixedheight;

                if (!no_redraw)
                    this._recreate_contents_all(false, true, true);
            }
            else
            {
                this._fixed_startrow = -9;
                this._fixed_endrow = -9;
                this._fixed_height = 0;
                this._fixedrow_height = 0;
                this._fixed_rowcnt = 0;
            }
        }
        else
        {
            srow = this._fixed_startrow;

            this._fixed_endrow = -9;
            this._fixed_height = 0;
            this._fixedrow_height = 0;
            this._fixed_rowcnt = 0;
            this._fixed_startrow = -9;

            if (!no_redraw)
            {
                this._recreate_contents_all(false, false, true);

                if (srow >= 0)
                    this._vscrollmng.setRowPos(srow);
            }
        }

        this._destroyHighlightRow();
        this._createHighlightRow();
    };

    _pGrid._getFixRowCnt = function ()
    {
        return (this._bodyBand) ? this._fixed_rowcnt : 0;
    };

    _pGrid._on_last_lbuttonup = function (down_act)
    {
        if (this._afterrecreatetask)
        {
            this._afterrecreatetask.destroy();
            this._afterrecreatetask = null;
        }

        if (this._movingcell)   // cellmoving 시도 후 grid 밖에 drop하는 경우
        {
            this._movingcell.parent._setTempCursor(null);
            this._movingcell = null;
        }

        if (this._groupdragcell)   // cell drag 시도 후 grid 밖에 drop하는 경우
        {
            this._groupdragcell.parent._setTempCursor(null);
            this._groupdragcell = null;
        }

        this._is_down_act = false;
        this._setdataobj = null;

        var args = this._after_recreate_contents_all;
        if (args != null)
        {
            if (!this._after_recreate)
            {
                this._is_after_recreate = true;
                this._recreate_contents_all(args[0], args[1], args[2], args[3]);
                this._after_recreate_contents_all = null;
                this._is_after_recreate = false;
                this._moveCellAfterFocus();
            }
        }

        if (this._after_recreate)
        {
            this._is_after_recreate = true;
            this._recreate();
            this._after_recreate = false;
            this._is_after_recreate = false;
            this._after_recreate_contents_all = null;
        }

        if (this._currentCellEditor && this._currentCellEditor._user_push)
        {
            this._currentCellEditor._user_push = false;
            this._currentCellEditor._changeStatus("focused", true);
            this._currentCellEditor._is_pushed_area = false;
            this._currentCellEditor._is_push = false;
        }

        if (this._after_hideeditor)
            this._hideEditorMergeCell(this._after_hideeditor);
    };

    _pGrid._on_last_keyup = function (down_act)
    {
        if (this._afterrecreatetask)
        {
            this._afterrecreatetask.destroy();
            this._afterrecreatetask = null;
        }

        this._is_down_act = false;
        this._setdataobj = null;

        var args = this._after_recreate_contents_all;
        if (args != null)
        {
            if (!this._after_recreate)
            {
                this._is_after_recreate = true;
                this._recreate_contents_all(args[0], args[1], args[2], args[3]);
                this._after_recreate_contents_all = null;
                this._is_after_recreate = false;
                this._moveCellAfterFocus();
            }
        }

        if (this._after_recreate)
        {
            this._is_after_recreate = true;
            this._recreate();
            this._after_recreate = false;
            this._is_after_recreate = false;
            this._after_recreate_contents_all = null;
        }

        if (this._after_hideeditor)
            this._hideEditorMergeCell(this._after_hideeditor);
    };

    _pGrid._common_fire_sys_lbuttonup = function (cellobj, altKey, ctrlKey, shiftKey, metaKey)
    {
        if (!this._is_alive) return;
        if (!this._p_enable) return true;

        if (cellobj && cellobj._type_name == "GridCellControl")
        {
            var newPos = this._getDataRow(cellobj._rowidx);

            if (this._isFakeCell(newPos))
            {
                this._is_drag_selectstart = false;
                this._is_drag_selecting = false;
                this._is_drag_sameselect = false;
                this._drag_start_obj = null;
                return true;
            }
            if (ctrlKey == false && shiftKey == false && this._is_drag_selecting == false && newPos >= 0)
            {
                if (this._isMultiSelected())
                {
                    if (this._isIncludeSelectpos(cellobj._cellidx, newPos))
                    {
                        this._clrMultiSelect();
                        this._refreshAll(true);
                        this._ChangeSelect(this._selectinfo.curcell, this._selectinfo.curcol, this._selectinfo.curdsrow, this._selectinfo.cursubrow, this._selectinfo.curpvt, false, this._selectinfo.curcell, this._selectinfo.curcol, this._selectinfo.curdsrow, this._selectinfo.cursubrow, this._selectinfo.curpvt, "body", "lbuttonup");
                    }
                }
            }
        }

        this._is_drag_selectstart = false;
        this._is_drag_selecting = false;
        this._is_drag_sameselect = false;
        this._drag_start_obj = null;
        this._execRefreshContents("colsizing", false, true);
        this._execRefreshContents("rowsizing", false, false);
        this._execRefreshContents("cellmoving", true);
        this._exeFuncQueue("colsizing");
        this._exeFuncQueue("rowsizing");

        this._is_user_change_colsize = false; //init
    };

    _pGrid._is_down_act = false;
    _pGrid._cancelEvent = function (target_comp)
    {
        this._endExtraTrack();
        this._is_drag_selectstart = false;
        this._is_drag_selecting = false;
        this._is_drag_sameselect = false;
        this._drag_start_obj = null;
        this._is_down_act = this._isDownActionKeyMouse();
        this._setdataobj = null;
        this._focus_proc = null;

        if (this._afterrecreatetask)
        {
            this._afterrecreatetask.destroy();
            this._afterrecreatetask = null;
        }

        if (this._select_cancel)
            this._select_cancel = false;

        this._is_event_canceling = undefined;
    };

    _pGrid._cancelingEvent = function ()
    {
        this._is_event_canceling = true;
    };

    _pGrid.on_fire_user_ontouchend = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp, need_recalcXY)
    {
        this._is_up_act = true;
        var retn = this.on_fire_ontouchend(touchinfos, changedtouchinfos, from_comp, from_refer_comp, true, need_recalcXY);
        this._is_up_act = false;

        return retn;
    };

    _pGrid.on_fire_sys_ontouchend = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp, need_recalcXY)
    {
        return this.on_fire_ontouchend(touchinfos, changedtouchinfos, from_comp, from_refer_comp, false, need_recalcXY);
    };

    _pGrid.on_fire_ontouchend = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp, user_fire, need_recalcXY)
    {
        var cellobj = from_refer_comp;

        cellobj = this._findCellObj(cellobj);

        this._recalcTouchInfosXY(cellobj, changedtouchinfos, need_recalcXY, from_refer_comp);

        //var subcellobj;
        if (cellobj)
        {
            if (cellobj.parentcell)
            {
                //      subcellobj = cellobj;
                cellobj = cellobj.parentcell;
            }
        }

        var retn = false;
        if (this.ontouchend && this.ontouchend._has_handlers)
        {/*
            var evtinfo = this._makeEventInfo(cellobj, subcellobj, from_refer_comp);
            //from_refer_comp = this._getRootComponent(from_refer_comp);

            var cell = evtinfo.cell;
            var col = evtinfo.col;
            var mergecell = evtinfo.mergecell;
            var mergecol = evtinfo.mergecol;
            var mergerow = evtinfo.mergerow;
            var pivotindex = evtinfo.pivotindex;
            var row = evtinfo.row;
            var subrow = evtinfo.subrow;
            */
            var evt = new nexacro.TouchEventInfo(this, "ontouchend", touchinfos, changedtouchinfos, from_comp, from_refer_comp);

            if (user_fire)
                retn = this.ontouchend._fireUserEvent(this, evt);
            else
                retn = this.ontouchend._fireSysEvent(this, evt);
        }

        if (!user_fire)
            this._common_fire_sys_lbuttonup(cellobj, false, false, false);

        return retn;
    };

    _pGrid._isCheckAlive = function (comp)
    {
        var parent = comp;
        while (parent != this)
        {
            if (!parent || parent._is_alive == false)
            {
                return false;
            }
            parent = parent.parent;
        }
        return true;
    };

    _pGrid._on_afterHideWaitComp = function (pseudo)
    {
        if (this._currentCellEditor)
        {
            this._currentCellEditor._setFocus(false);
        }
    };
    _pGrid.on_fire_user_onlbuttonup = function (button, altKey, ctrlKey, shiftKey, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, metaKey, need_recalcXY)
    {
        this._is_up_act = true;
        var retn = this.on_fire_onlbuttonup(button, altKey, ctrlKey, shiftKey, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, true, need_recalcXY, metaKey);
        this._is_up_act = false;

        return retn;
    };

    _pGrid.on_fire_sys_onlbuttonup = function (button, altKey, ctrlKey, shiftKey, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, metaKey, need_recalcXY)
    {
        return this.on_fire_onlbuttonup(button, altKey, ctrlKey, shiftKey, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, false, need_recalcXY, metaKey);
    };

    _pGrid.on_fire_onlbuttonup = function (button, altKey, ctrlKey, shiftKey, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, user_fire, need_recalcXY, metaKey)
    {
        var lastfocus = this._find_lastFocused();

        if (lastfocus instanceof nexacro.Div)
            lastfocus = lastfocus._getLastFocused();

        if (lastfocus == this)
        {
            if (this._focus_proc)
            {
                if (!this._showEditing)
                {
                    if (this._isCheckAlive(this._focus_proc.parent))
                    {
                        // cell vscroll 보정은 scrollpixel이 all일 경우만
                        var is_vscroll = false;
                        if (this._scrollpixel == "all")
                        {
                            is_vscroll = true;
                        }
                        if (!this._isDownUpScroll()) // flingscroll이 끝날때까지 처리하지 않음 
                        {
                            this._focus_proc.parent._showfull(is_vscroll);    // focus를 주기전 보이도록 처리해야 DOM scroll이 왔다갔다 하지 않음. 
                        }
                        this._focus_proc.parent._setFocus(false); // scrollbutton없는 테마에서 elementfocus주면 scroll이 튀는 현상(IE만)
                    }
                }
                else if (this._currentCellEditor && this._currentCellEditor.setCaretPos && !this._currentCellEditor.parent._is_mergetemp)
                {
                    if (this._currentCellEditor._p_autoselect)
                    {
                        this._currentCellEditor.setSelect(0, -1);
                    }
                    else
                    {
                        this._currentCellEditor.setCaretPos(0);
                    }
                }
                this._focus_proc = null;
            }
        }

        var cellobj = from_refer_comp;

        cellobj = this._findCellObj(cellobj);

        var subcellobj;
        if (cellobj)
        {
            if (cellobj.parentcell)
            {
                subcellobj = cellobj;
                cellobj = cellobj.parentcell;
            }
        }

        var posobj = this._recalcXY(cellobj, canvasX, canvasY, need_recalcXY, from_refer_comp);
        canvasX = posobj.canvasX;
        canvasY = posobj.canvasY;
        clientX = posobj.clientX;
        clientY = posobj.clientY;

        var retn = false;
        if (this.onlbuttonup && this.onlbuttonup._has_handlers)
        {
            var evtinfo = this._makeEventInfo(cellobj, subcellobj, from_refer_comp);
            //from_refer_comp = this._getRootComponent(from_refer_comp);

            var obj = this._getRootComponent(from_refer_comp);
            var cell = evtinfo.cell;
            var col = evtinfo.col;
            var mergecell = evtinfo.mergecell;
            var mergecol = evtinfo.mergecol;
            var mergerow = evtinfo.mergerow;
            var pivotindex = evtinfo.pivotindex;
            var row = evtinfo.row;
            var subrow = evtinfo.subrow;

            var evt = new nexacro.GridMouseEventInfo(obj, "onlbuttonup", cell, col, mergecell, mergecol, mergerow, pivotindex, row, subrow, button, altKey, ctrlKey, shiftKey, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, metaKey);
            if (user_fire)
                retn = this.onlbuttonup._fireUserEvent(this, evt);
            else
                retn = this.onlbuttonup._fireSysEvent(this, evt);
        }

        if (!user_fire)
        {
            if (cellobj)
            {
                if (this._p_selectchangetype == "up")
                {
                    if (this._p_selecttype != "area" && this._p_selecttype != "multiarea")
                    {
                        var dragobj;

                        if (this._is_drag_selecting)
                        {
                            dragobj = this._drag_start_obj;

                            if (this._findCellObj(dragobj) == this._findCellObj(from_elem))
                                dragobj = null;
                        }

                        if (!dragobj)
                        {
                            this._mouseSelection(cellobj, ctrlKey, shiftKey, canvasX, canvasY, from_comp, from_refer_comp, metaKey);
                            this._endExtraTrack();
                        }
                    }
                }
            }

            this._common_fire_sys_lbuttonup(cellobj, altKey, ctrlKey, shiftKey, metaKey);

            canvasX = this._adjustRtlCanvasX(from_refer_comp, canvasX, false);
            this._resizerStart(canvasX, canvasY, cellobj, "up", from_refer_comp);
        }
        return retn;
    };

    _pGrid.on_fire_user_onrbuttonup = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, from_elem, meta_key)
    {
        var cellobj = from_refer_comp;

        cellobj = this._findCellObj(cellobj);

        var subcellobj;
        if (cellobj)
        {
            if (cellobj.parentcell)
            {
                subcellobj = cellobj;
                cellobj = cellobj.parentcell;
            }
        }

        var posobj = this._recalcXY(cellobj, canvasX, canvasY, false, from_refer_comp);
        canvasX = posobj.canvasX;
        canvasY = posobj.canvasY;
        clientX = posobj.clientX;
        clientY = posobj.clientY;

        if (this.onrbuttonup && this.onrbuttonup._has_handlers)
        {
            var evtinfo = this._makeEventInfo(cellobj, subcellobj, from_refer_comp);
            //from_refer_comp = this._getRootComponent(from_refer_comp);

            var obj = this._getRootComponent(from_refer_comp);
            var cell = evtinfo.cell;
            var col = evtinfo.col;
            var mergecell = evtinfo.mergecell;
            var mergecol = evtinfo.mergecol;
            var mergerow = evtinfo.mergerow;
            var pivotindex = evtinfo.pivotindex;
            var row = evtinfo.row;
            var subrow = evtinfo.subrow;

            var evt = new nexacro.GridMouseEventInfo(obj, "onrbuttonup", cell, col, mergecell, mergecol, mergerow, pivotindex, row, subrow, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
            this._is_up_act = true;
            var retn = this.onrbuttonup._fireUserEvent(this, evt);
            this._is_up_act = false;

            return retn;
        }
        return false;
    };

    _pGrid.on_fire_oncontextmenu = function (from_comp, from_refer_comp, button, canvasX, canvasY, clientX, clientY, alt_key, ctrl_key, shift_key, screenX, screenY, meta_key)
    {
        var cellobj = from_refer_comp;

        cellobj = this._findCellObj(cellobj);

        var subcellobj;
        if (cellobj)
        {
            if (cellobj.parentcell)
            {
                subcellobj = cellobj;
                cellobj = cellobj.parentcell;
            }
        }

        var posobj = this._recalcXY(cellobj, canvasX, canvasY, false, from_refer_comp);
        canvasX = posobj.canvasX;
        canvasY = posobj.canvasY;
        clientX = posobj.clientX;
        clientY = posobj.clientY;

        if (this.oncontextmenu && this.oncontextmenu._has_handlers)
        {
            var evtinfo = this._makeEventInfo(cellobj, subcellobj, from_refer_comp);

            var obj = this._getRootComponent(from_refer_comp);
            var cell = evtinfo.cell;
            var col = evtinfo.col;
            var mergecell = evtinfo.mergecell;
            var mergecol = evtinfo.mergecol;
            var mergerow = evtinfo.mergerow;
            var pivotindex = evtinfo.pivotindex;
            var row = evtinfo.row;
            var subrow = evtinfo.subrow;

            var evt = new nexacro.GridContextMenuEventInfo(obj, "oncontextmenu", cell, col, mergecell, mergecol, mergerow, pivotindex, row, subrow, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
            var retn = this.oncontextmenu._fireEvent(this, evt);

            return retn;
        }
        return false;
    };

    _pGrid.on_fire_user_onmouseup = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        this._is_up_act = true;
        var retn = this.on_fire_onmouseup(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, true, meta_key);
        this._is_up_act = false;

        return retn;
    };

    _pGrid.on_fire_sys_onmouseup = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        return this.on_fire_onmouseup(button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, false, meta_key);
    };

    _pGrid.on_fire_onmouseup = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, user_fire, meta_key)
    {
        var cellobj = from_refer_comp;

        cellobj = this._findCellObj(cellobj);

        var subcellobj;
        if (cellobj)
        {
            if (cellobj.parentcell)
            {
                subcellobj = cellobj;
                cellobj = cellobj.parentcell;
            }
        }

        var posobj = this._recalcXY(cellobj, canvasX, canvasY, false, from_refer_comp);
        canvasX = posobj.canvasX;
        canvasY = posobj.canvasY;
        clientX = posobj.clientX;
        clientY = posobj.clientY;

        var retn = false;
        if (this.onmouseup && this.onmouseup._has_handlers)
        {
            var evtinfo = this._makeEventInfo(cellobj, subcellobj, from_refer_comp);
            //from_comp = this._getRootComponent(from_comp);

            var obj = this._getRootComponent(from_comp);
            var cell = evtinfo.cell;
            var col = evtinfo.col;
            var mergecell = evtinfo.mergecell;
            var mergecol = evtinfo.mergecol;
            var mergerow = evtinfo.mergerow;
            var pivotindex = evtinfo.pivotindex;
            var row = evtinfo.row;
            var subrow = evtinfo.subrow;

            var evt = new nexacro.GridMouseEventInfo(obj, "onmouseup", cell, col, mergecell, mergecol, mergerow, pivotindex, row, subrow, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
            if (user_fire)
                retn = this.onmouseup._fireUserEvent(this, evt);
            else
                retn = this.onmouseup._fireSysEvent(this, evt);
        }

        return retn;
    };
    /*
    _pGrid.on_fire_user_onlongpress = function (elem, touchinfos, from_comp, from_refer_comp)
    {
        var cellobj = from_refer_comp;

        cellobj = this._findCellObj(cellobj);

        this._recalcTouchInfosXY(cellobj, touchinfos, false, from_refer_comp);

        var touchinfo = nexacro._getFirstTouchInfo(touchinfos);
        var subcellobj;

        if (cellobj)
        {
            if (cellobj.parentcell)
            {
                subcellobj = cellobj;
                cellobj = cellobj.parentcell;
            }
        }

        var retn = false;

        if (this.onlongpress && this.onlongpress._has_handlers)
        {
            var evtinfo = this._makeEventInfo(cellobj, subcellobj, from_refer_comp);
            var cell = evtinfo.cell;
            var col = evtinfo.col;
            var mergecell = evtinfo.mergecell;
            var mergecol = evtinfo.mergecol;
            var mergerow = evtinfo.mergerow;
            var pivotindex = evtinfo.pivotindex;
            var row = evtinfo.row;
            var subrow = evtinfo.subrow;

            var evt = new nexacro.GridLongPressEventInfo(this, "onlongpress", touchinfos, from_comp, from_refer_comp, cell, col, row, subrow, pivotindex, mergecell, mergecol, mergerow);
            return this.onlongpress._fireUserEvent(this, evt);
        }
        return false;
    };
    */
    _pGrid._resizerStart = function (canvasX, canvasY, cellobj, kind, from_refer_comp)
    {
        if (this._movingcell || this._groupdragcell)
            return;

        var resizer_colctrl = this._resizer_colctrl;
        var resizer_rowctrl = this._resizer_rowctrl;

        if ((resizer_colctrl && resizer_colctrl._is_tracking) || (resizer_rowctrl && resizer_rowctrl._is_tracking))
            return;

        var r_canvasX = canvasX;
        var r_canvasY = canvasY;
        var rowidx = cellobj._rowidx;
        var cellidx = cellobj._cellidx;

        if (cellobj._is_alive == false)
        {
            if (rowidx == -1)
                cellobj = this._getCurrentHeadCell(cellidx, true);
            else
                cellobj = this._getCurrentBodyCell(rowidx, cellidx);
        }

        if (!cellobj)
            return;

        var area = (cellobj._refinfo) ? cellobj._refinfo._area : "";
        var band = (cellobj._band) ? cellobj._band.id : "";
        if (band == "summary")
            band = "summ"; // summary일 경우 resizer_range "summ"으로 check되어 있다.
        if (area == "body")
        {
            r_canvasX += this._getScrollLeft();
        }
        if (band == "body")
        {
            if (!cellobj.parent._fixed)
                r_canvasY += this._getScrollTop();
        }

        var action = false;
        var resize_cursor;
        var resizer_range;
        var resizer_arr_length;
        var i;
        var range;

        if (resizer_colctrl && !resizer_colctrl._is_tracking)
        {
            resize_cursor = nexacro.CursorObject("col-resize");
            resizer_range = this._resizerColRange;
            resizer_arr_length = resizer_range.length;

            if (resizer_arr_length > 0)
            {
                resizer_colctrl._is_range = false;

                for (i = 0; i < resizer_arr_length; i++)
                {
                    range = resizer_range[i];

                    if (r_canvasX >= (range.left - 2) && r_canvasX <= (range.right + 2))
                    {
                        if (area != range.area)
                            continue;

                        if (r_canvasY >= range.top && r_canvasY <= range.bottom)
                        {
                            this.a = r_canvasX;
                            resizer_colctrl._is_range = true;
                            resizer_colctrl._setIndex(range.index);
                            this._setGlobalCursor(resize_cursor, cellobj, cellobj);
                            action = true;
                            break;
                        }
                    }
                }
            }
            if (!resizer_colctrl._is_range && !resizer_colctrl._is_tracking && (!resizer_rowctrl || !resizer_rowctrl._is_tracking))
            {
                if (cellobj._type_name != "GridCellControl")
                    this._setGlobalCursor(null, from_refer_comp, from_refer_comp);
                else
                    this._setGlobalCursor(null, cellobj, cellobj);
                action = false;
            }
            else if (resizer_colctrl._is_tracking)
            {
                this._setGlobalCursor(resize_cursor, cellobj, cellobj);
                action = true;
            }
        }

        if (action)
            return;

        if (resizer_rowctrl && !resizer_rowctrl._is_tracking)
        {
            resize_cursor = nexacro.CursorObject("row-resize");
            resizer_range = this._resizerRowRange;
            resizer_arr_length = resizer_range.length;

            if (resizer_arr_length > 0)
            {
                resizer_rowctrl._is_range = false;

                for (i = 0; i < resizer_arr_length; i++)
                {
                    range = resizer_range[i];

                    if (r_canvasY >= range.top && r_canvasY <= range.bottom)
                    {
                        if (band != range.area)
                            continue;

                        if (r_canvasX >= range.left && r_canvasX <= range.right)
                        {
                            resizer_rowctrl._is_range = true;
                            resizer_rowctrl._setIndex(range.index);
                            this._setGlobalCursor(resize_cursor, cellobj, cellobj);
                            break;
                        }
                    }
                }
            }
            if (!resizer_rowctrl._is_range && !resizer_rowctrl._is_tracking && (!resizer_colctrl || !resizer_colctrl._is_tracking))
            {
                if (cellobj._type_name != "GridCellControl")
                    this._setGlobalCursor(null, from_refer_comp, from_refer_comp);
                else
                    this._setGlobalCursor(null, cellobj, cellobj);
            }
            else if (resizer_rowctrl._is_tracking)
            {
                this._setGlobalCursor(resize_cursor, cellobj, cellobj);
            }
        }
    };

    _pGrid.on_fire_user_ontouchmove = function (touchinfos, changedtouchinfos, from_comp, from_refer_comp)
    {
        var cellobj = from_refer_comp;

        cellobj = this._findCellObj(cellobj);

        this._recalcTouchInfosXY(cellobj, changedtouchinfos, false, from_refer_comp);
        /*
        var subcellobj;
        if (cellobj)
        {
            if (cellobj.parentcell)
            {
                subcellobj = cellobj;
                cellobj = cellobj.parentcell;
            }
        }
        */
        var retn = false;
        if (this.ontouchmove && this.ontouchmove._has_handlers)
        {/*
            var evtinfo = this._makeEventInfo(cellobj, subcellobj, from_refer_comp);
            //from_refer_comp = this._getRootComponent(from_refer_comp);

            var cell = evtinfo.cell;
            var col = evtinfo.col;
            var mergecell = evtinfo.mergecell;
            var mergecol = evtinfo.mergecol;
            var mergerow = evtinfo.mergerow;
            var pivotindex = evtinfo.pivotindex;
            var row = evtinfo.row;
            var subrow = evtinfo.subrow;
            */
            var evt = new nexacro.TouchEventInfo(this, "ontouchmove", touchinfos, changedtouchinfos, from_comp, from_refer_comp);
            retn = this.ontouchmove._fireUserEvent(this, evt);
        }

        return retn;
    };

    _pGrid.on_fire_user_onmousemove = function (button, altKey, ctrlKey, shiftKey, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, metaKey)
    {
        if (!from_refer_comp._is_alive)
            return;

        var cellobj = from_refer_comp;

        cellobj = this._findCellObj(cellobj);

        var subcellobj;
        if (cellobj)
        {
            if (cellobj.parentcell)
            {
                subcellobj = cellobj;
                cellobj = cellobj.parentcell;
            }
        }

        var posobj = this._recalcXY(cellobj, canvasX, canvasY, false, from_refer_comp);
        canvasX = posobj.canvasX;
        canvasY = posobj.canvasY;
        clientX = posobj.clientX;
        clientY = posobj.clientY;

        var retn = false;
        if (this.onmousemove && this.onmousemove._has_handlers)
        {
            var evtinfo = this._makeEventInfo(cellobj, subcellobj, from_refer_comp);
            //from_refer_comp = this._getRootComponent(from_refer_comp);

            var obj = this._getRootComponent(from_refer_comp);
            var cell = evtinfo.cell;
            var col = evtinfo.col;
            var mergecell = evtinfo.mergecell;
            var mergecol = evtinfo.mergecol;
            var mergerow = evtinfo.mergerow;
            var pivotindex = evtinfo.pivotindex;
            var row = evtinfo.row;
            var subrow = evtinfo.subrow;

            var evt = new nexacro.GridMouseEventInfo(obj, "onmousemove", cell, col, mergecell, mergecol, mergerow, pivotindex, row, subrow, button, altKey, ctrlKey, shiftKey, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, metaKey);
            retn = this.onmousemove._fireUserEvent(this, evt);
        }

        if (!nexacro._isTouchInteraction)
        {
            canvasX = this._adjustRtlCanvasX(from_refer_comp, canvasX);
            this._resizerStart(canvasX, canvasY, cellobj, "move", from_refer_comp);
        }

        return retn;
    };

    _pGrid._adjustRtlCanvasX = function (obj, canvasX)
    {
        if (this._isRtl())
        {
            if (obj._type_name == "GridCellControl" && obj._is_alive)
            {
                var real_canvasX = canvasX;

                var area = obj._refinfo._area;
                var band = obj._band.id;
                var rect;

                if (area == "body")
                {
                    real_canvasX = canvasX - this._curFormat.leftWidth * 2;
                    real_canvasX += this._getScrollLeft() * 2;
                }
                else if (area == "right")
                {
                    var gridrow = obj._getRowControl();
                    rect = gridrow._getAreaRect(area);
                    var areal = rect.left;
                    real_canvasX = canvasX - areal * 2;
                }
            }
            canvasX = (obj.left * 2) + obj._adjust_width - real_canvasX;
        }

        return canvasX;
    };

    _pGrid._prevAreaCellObj = null;

    _pGrid._areaselectMove = function (from_refer_comp, canvasX, canvasY)
    {
        if (this._is_drag_selectstart && !this._showEditing && this._selectscrollmode == "select")
        {
            var cellobj = from_refer_comp;

            cellobj = this._findCellObj(cellobj);

            var subcellobj;//, area;
            var fixed_endrow, selectinfo;
            var cur_selected_area;
            var cur_srow;
            var cur_erow;
            var cur_vscrollpos;
            var mode;

            if (cellobj && (cellobj._type_name == "GridCellControl" || cellobj._type_name == "GridSubCellControl"))
            {
                if (cellobj.parentcell)
                {
                    subcellobj = cellobj;
                    cellobj = cellobj.parentcell;
                }

                var posobj = this._recalcXY(cellobj, canvasX, canvasY, false, from_refer_comp);
                canvasX = posobj.canvasX;
                canvasY = posobj.canvasY;

                if ((this._prevAreaCellObj == cellobj) && !this._fixed_row_scrolling)
                    return;

                //                area = cellobj._refinfo._area;

                var newPos = this._getDataRow(cellobj._rowidx);
                if (newPos == undefined)
                    newPos = 0;

                if (this._isFakeCell(newPos) || newPos < 0)
                    return true;

                var beforeCell = this._beforebodycellpos = this._selectinfo.curcell;
                var beforeCol = this._beforebodycolpos = this._selectinfo.curcol;
                var beforeRow = this._beforebodyrowpos = this._selectinfo.curdsrow;
                var beforeSubrow = this._beforebodysubrowpos = this._selectinfo.cursubrow;
                var beforePvt = this._beforepvt = this._selectinfo.curpvt;

                // current
                var afterCell = cellobj._cellidx;
                var afterCol = cellobj._refinfo._col;
                var afterRow = newPos;
                var afterSubrow = cellobj._refinfo._row;
                var afterPvt = -9;

                if (subcellobj)
                {
                    afterCol += subcellobj._refinfo._col;
                }

                if (this._fixed_rowcnt > 0)
                {
                    //                  var fixed_startrow = this._fixed_startrow;
                    fixed_endrow = this._fixed_endrow;

                    selectinfo = this._selectinfo;
                    if (selectinfo.area.length > 0)
                    {
                        cur_selected_area = selectinfo.area[selectinfo.area.length - 1];
                        cur_srow = cur_selected_area.begrow;
                        cur_erow = cur_selected_area.endrow;
                        cur_vscrollpos = this._vscrollmng.pos;

                        if (afterRow < beforeRow)
                            mode = "up";
                        else if (afterRow > beforeRow)
                            mode = "down";
                        else
                            mode = "keep";

                        if (mode == "up")
                        {
                            this._fixed_row_scrolling = true;
                            if (cur_erow > afterRow && afterRow <= fixed_endrow && cur_erow > fixed_endrow)
                            {
                                this._vscrollmng.setPos(cur_vscrollpos - 1);
                            }
                            else
                            {
                                this._fixed_row_scrolling = false;
                            }
                        }
                        else if (mode == "down")
                        {
                            if (cur_srow <= this._fixed_endrow && cur_erow <= this._fixed_endrow)
                                this._fixed_row_scroll_zeroset = true;
                            else
                                this._fixed_row_scroll_zeroset = false;

                            if (this._fixed_row_scroll_zeroset && afterRow && (afterRow <= 0 ||
                                (afterRow <= this._fixed_endrow && cur_erow > this._fixed_endrow) ||
                                (afterRow > this._fixed_endrow && cur_srow <= this._fixed_endrow)))
                            {
                                if (cur_vscrollpos > 0)
                                {
                                    this._vscrollmng.setPos(0);
                                    this._fixed_row_scroll_zeroset = false;
                                    return;
                                }
                            }
                        }
                        else
                        {
                            if (cur_vscrollpos == 0)
                                this._fixed_row_scrolling = false;
                            else if (this._fixed_row_scrolling)
                                this._vscrollmng.setPos(cur_vscrollpos - 1);
                        }
                    }
                }

                while (true)
                {
                    if (this._p_selecttype == "multirow" && afterRow == beforeRow)
                        break;

                    this._setSelectedInfo(afterCell, afterCol, afterRow, afterSubrow, afterPvt);
                    this._ChangeSelect(afterCell, afterCol, afterRow, afterSubrow, afterPvt, false, beforeCell, beforeCol, beforeRow, beforeSubrow, beforePvt, cellobj._band.id, "mousemove");
                    break;  // 소나큐브무시
                }
                this._prevAreaCellObj = cellobj;
            }
        }
    };

    _pGrid._on_start_extratrack = function (windowX, windowY, screenX, screenY, keepstart)
    {
        if (!this._lastmouseentercell) return;
        var scroll_left = this._getScrollLeft();
        var scroll_top = this._getScrollTop();

        this._track_point.x = screenX;
        this._track_point.y = screenY;
        this._track_point.w = 0;
        this._track_point.h = 0;
        this._track_point.cur_rect = { l: 0, t: 0, w: 0, h: 0 };

        this._track_start_info = {};
        this._track_start_info.target = this._lastmouseentercell;
        //this._track_start_info.screenX = nexacro.System.clientToScreenX(this._lastmouseentercell, 0);
        //this._track_start_info.screenY = nexacro.System.clientToScreenY(this._lastmouseentercell, 0);

        this._track_start_info.cell_screenX = nexacro.System.clientToScreenX(this._lastmouseentercell, 0);
        this._track_start_info.cell_screenY = nexacro.System.clientToScreenY(this._lastmouseentercell, 0);


        var frame = this._getOwnerFrame();

        if (frame && (frame._window_type == 1 || frame._window_type == 4 || frame._window_type == 5))
        {
            var adjust_x = this._lastmouseentercell._adjust_left;
            var adjust_y = this._lastmouseentercell._adjust_top;

            var parent = this._lastmouseentercell.parent;

            while (parent)
            {
                if (parent._is_frame)
                {
                    break;
                }
                adjust_x += parent._adjust_left;
                adjust_y += parent._adjust_top;

                parent = parent.parent;
            }

            var frame_screenx = nexacro.System.clientToScreenX(frame, 0);
            //            var frame_screeny = nexacro.System.clientToScreenY(frame, 0);
            if (frame_screenx == 0 && frame._adjust_left < 0)
                frame_screenx = frame._adjust_left;
            //          if (frame_screeny == 0 && frame._adjust_top < 0)
            //            frame_screeny = frame._adjust_top;

            this._track_start_info.cell_screenX = frame_screenx + adjust_x;
            // this._track_start_info.cell_screenY = frame_screeny + adjust_y;
        }

        this._track_start_info.start_screenX = screenX;
        this._track_start_info.start_screenY = screenY;
        this._track_start_info.scrollLeft = scroll_left;
        this._track_start_info.scrollTop = scroll_top;

        this._track_start_info._start_begarea = this._selectinfo.arearect.barea;
        this._track_start_info._start_endarea = this._selectinfo.arearect.earea;

        //        var cur_rect = this._getSelectRect(false, true);
        var rectinfo = this._getExtraTrackSelectRect(screenX, screenY, 0, 0, true);

        if (!keepstart)
            this._startAreaSizing(rectinfo, rectinfo.idx);

        this._track_mode = "areaselect";
    };

    _pGrid._on_move_extratrack = function (obj, windowX, windowY, distX, distY, screenX, screenY)
    {
        var rootcomp = this._getRootComponent(obj);

        // runtime 드래그로 app 밖으로 나갈 시 obj == null
        if (!obj || (this._showEditing == false && (rootcomp != this || (rootcomp == this && obj instanceof nexacro._GridCellControl && (obj._band.id == "head" || obj._band.id == "summary")) ||
            (rootcomp == this && obj instanceof nexacro._GridRowControl && obj._band.id == "body") ||
            (rootcomp == this && obj.id == "body"))))
        //if (rootcomp != this && !(obj instanceof nexacro.GridCell ) )
        {
            var rectinfo = this._getExtraTrackSelectRect(screenX, screenY, distX, distY, false);
            var idx = rectinfo.idx;

            var typeinfo = this._getTrackType(this._track_start_info, rectinfo.l, rectinfo.t, rectinfo.w, rectinfo.h, idx, false);

            var select_area = this._selectinfo.area;
            if (this._fixed_rowcnt > 0 && select_area.length)
            {
                var cur_area = select_area[select_area.length - 1];
                var cur_srow = cur_area.begrow;
                var cur_erow = cur_area.endrow;

                var ctrlpoint = this._selectinfo.ctrlpoint;
                //              var cur_row = ctrlpoint.row;
                //              var cur_col = ctrlpoint.col;

                var border = this._getCurrentStyleBorder();
                var border_top = (border) ? parseInt(border.right._width, 10) : 0;

                var headheight = this._getHeadHeight();
                var fixedheight = this._fixed_height;
                var fixedbottom = headheight + fixedheight + border_top;
                //              var fixedsrow = this._fixed_startrow;
                var fixederow = this._fixed_endrow;
                var t = rectinfo.t;
                var h = rectinfo.h;

                var cur_scrolltop = this._getScrollTop();
                var vscroll = this._vscrollmng;

                if (cur_srow <= fixederow && cur_erow <= fixederow && cur_scrolltop > 0 && (t + h) > fixedbottom)
                {
                    vscroll.setPos(0);
                }
                else if (cur_srow <= fixederow && cur_erow >= fixederow && cur_scrolltop > 0 && (t + h) <= fixedbottom)
                {
                    vscroll.setPos(vscroll.pos - 1);
                }
                else if (ctrlpoint.row > fixederow && cur_scrolltop > 0 && t <= fixedbottom)
                {
                    vscroll.setPos(vscroll.pos - 1);
                }


            }

            this._applySelectorScroll(typeinfo.type);
            this._applyAreaSizing(rectinfo, idx);
            //          var cur_rect = this._getSelectRect(false, true);

            this._extratrack_typeinfo = typeinfo;
            this._extratrack_rectinfo = rectinfo;
            this._extratrack_idx = idx;

            var init_interval = 500;
            var min_intervalgap = 10;

            function getTimerInterval(obj)
            {
                var interval = init_interval;

                var grid_x = nexacro.System.clientToScreenX(obj, 0);
                var grid_y = nexacro.System.clientToScreenY(obj, 0);
                var frame = obj._getOwnerFrame();

                if (frame && (frame._window_type == 1 || frame._window_type == 4))
                {
                    var adjust_x = obj._adjust_left;
                    var adjust_y = obj._adjust_top;

                    var parent = obj.parent;

                    while (parent)
                    {

                        if (parent._is_frame)
                        {
                            break;
                        }

                        adjust_x += parent._adjust_left;
                        adjust_y += parent._adjust_top;

                        parent = parent.parent;
                    }


                    var frame_screenx = nexacro.System.clientToScreenX(frame, 0);
                    //                    var frame_screeny = nexacro.System.clientToScreenY(frame, 0);
                    if (frame_screenx == 0 && frame._adjust_left < 0)
                        frame_screenx = frame._adjust_left;
                    //                    if (frame_screeny == 0 && frame._adjust_top < 0)
                    //                        frame_screeny = frame._adjust_top;

                    grid_x = frame_screenx + adjust_x;
                    // grid_y = frame_screeny + adjust_y;
                }

                var grid_r = grid_x + parseInt(obj._adjust_width);
                var grid_b = grid_y + parseInt(obj._adjust_height);

                var wgap = (screenX < grid_x) ? (grid_x - screenX) : (screenX - grid_r);
                var hgap = (screenY < grid_y) ? (grid_y - screenY) : (screenY - grid_b);

                if (wgap >= 0)
                {
                    interval = interval - (wgap * 10);

                    return interval > 0 ? interval : 1;
                }

                if (hgap >= 0)
                {
                    interval = interval - (hgap * 10);

                    return interval > 0 ? interval : 1;
                }

                return -1;
            }

            var timer_interval = getTimerInterval(this);

            if (timer_interval > 0 && timer_interval < min_intervalgap)
                timer_interval = min_intervalgap;

            if (timer_interval > 0)
            {
                if (!this._extratrack_timer)
                {
                    this._extratrack_timer = {};
                    this._extratrack_timer._handle = null;
                    this._extratrack_timer._interval = timer_interval;

                    this._extratrack_timer._handle = new nexacro._CallbackTimer(this, function ()
                    {
                        this._applySelectorScroll(this._extratrack_idx, this._extratrack_typeinfo.type);
                        this._applyAreaSizing(this._extratrack_rectinfo, this._extratrack_idx);
                        //            var cur_rect = this._getSelectRect(false, true);

                    }, timer_interval);

                    this._extratrack_timer._handle.start();
                }
                else
                {
                    if (this._extratrack_timer && this._extratrack_timer._interval != timer_interval)
                    {
                        if (timer_interval > 0)
                        {
                            this._extratrack_timer._interval = timer_interval;
                            this._extratrack_timer._handle.setInterval(timer_interval);
                            this._extratrack_timer._handle.start();
                        }
                        else
                            this._extratrack_timer._handle.stop();
                    }
                }
            }
        }
        else
        {
            if (this._extratrack_timer)
                this._extratrack_timer._handle.stop();
        }

    };

    _pGrid._on_end_extratrack = function (x, y, dragdata)
    {
        //        var p = this._select_ctrl;

        this._track_start_info = null;
        this._track_idx = -1;
        this._track_mode = "";

        if (this._extratrack_timer)
        {
            this._extratrack_timer._handle.stop();
            this._extratrack_timer._handle = null;
            this._extratrack_timer = null;
        }

        this._getSelectRect(false, true);
        //     this._updateSelector();
    };

    _pGrid._endExtraTrack = function ()
    {
        this._on_end_extratrack();
        nexacro._cur_extra_track_info = null;
    };

    _pGrid._trackingHScroll = function (idx, left, right, start_begarea, start_endarea, bodystart, rightstart, scroll_left, scroll_max)
    {
        var retn = [0, 0];

        if (this.scrolltype == "none" || this.scrolltype == "vertical")
            return retn;

        var hscroll = this._hscrollmng;

        if (idx == 0 || idx == 2)
        {
            if (start_begarea == "right") // right -> body로 조절
            {
                if (left < rightstart && left > bodystart)
                    hscroll.setPos(scroll_max);
            }
            else if (start_begarea == "left") // left -> body로 조절
            {
                if (left > bodystart && left < rightstart)
                {
                    hscroll.setPos(0);
                    retn[1] = scroll_left;
                }
            }
        }
        else
        {
            if (start_endarea == "left")  // left -> body로 조절
            {
                if (right > bodystart && right < rightstart)
                    hscroll.setPos(0);
            }
            else if (start_endarea == "right") // right -> body로 조절
            {
                if (right < rightstart && right > bodystart)
                {
                    hscroll.setPos(scroll_max);
                    retn[0] = scroll_left - scroll_max;
                    retn[1] = scroll_max - scroll_left;
                }
            }
        }
        return retn;
    };

    _pGrid._getTrackType = function (obj, left, top, width, height, idx, onlyarea)
    {
        var hmin, hmax, vmin, vmax;
        var grid = this;
        var format = grid._curFormat;
        var type = ["", ""];
        var area = grid._selectinfo.ctrlpoint.area;

        var leftwidth = format.leftWidth;
        var rightstart = grid._getClientWidth() - format.rightWidth;
        var bodylast = format.leftWidth + format.bodyWidth;
        var scroll_left = grid._getScrollLeft();
        var scroll_max = grid._getScollMaxLeft();
        var right = left + width;
        var headheight = grid._getHeadHeight();
        var fixedheight = grid._fixed_height;
        var fixedbottom = headheight + fixedheight;


        if (onlyarea)
        {
            if (area == "left")
            {
                hmin = 0;
                hmax = leftwidth;
            }
            else if (area == "right")
            {
                hmin = rightstart;
                hmax = grid._getClientWidth();
            }
            else
            {
                hmin = leftwidth;
                hmax = (bodylast < rightstart) ? bodylast : rightstart;
            }
        }
        else
        {
            var move = this._trackingHScroll(idx, left, right, leftwidth, obj._start_begarea, obj._start_endarea, rightstart, scroll_left, scroll_max);

            left += move[0];
            width += move[1];
            //            right = left + width;

            if (area == "left")
            {
                hmin = 0;

                if (scroll_left == scroll_max)
                    hmax = (bodylast < grid._getClientWidth()) ? bodylast : grid._getClientWidth();
                else
                    hmax = (bodylast < rightstart) ? bodylast : rightstart;
            }
            else if (area == "right")
            {
                if (scroll_left == 0)
                    hmin = 0;
                else
                    hmin = leftwidth;

                hmax = grid._getClientWidth();
            }
            else  // body
            {
                if (scroll_left == 0)
                    hmin = 0;
                else
                    hmin = leftwidth;

                if (scroll_left == scroll_max)
                    hmax = (bodylast < grid._getClientWidth()) ? bodylast : grid._getClientWidth();
                else
                    hmax = (bodylast < rightstart) ? bodylast : rightstart;
            }
        }

        vmin = this._bodyBand._adjust_top;
        vmax = this._bodyBand.getOffsetBottom();

        var b, r;

        if (idx == 0)
        {
            if (left < hmin)
            {
                width -= (hmin - left);
                left = hmin;

                if (this._start_begarea != "left")
                    type[0] = "leftover0";
            }
            else if (left > hmax || (scroll_left < scroll_max && left > rightstart))
            {
                type[0] = "rightover0";
            }

            if (grid._fixed_rowcnt > 0)
            {
                if (top < (fixedheight + headheight))
                {
                    type[1] = "topover0";
                }
                else if (top > vmax)
                {
                    type[1] = "bottomover0";
                }
            }
            else
            {
                if (top < vmin)
                {
                    height -= (vmin - top);
                    top = vmin;
                    type[1] = "topover0";
                }
                else if (top > vmax)
                {
                    type[1] = "bottomover0";
                }
            }

            if (width <= 0)
                left += width - 1;

            if (height <= 0)
                top += height - 1;
        }
        else if (idx == 1)
        {
            r = left + width;
            b = top + height;

            if (r < hmin || (scroll_left > 0 && r < leftwidth))
            {
                type[0] = "leftover1";
            }
            else if (r > hmax)
            {
                width = hmax - left;

                if (this._start_endarea != "right")
                    type[0] = "rightover1";
            }

            if (b < vmin)
            {
                type[1] = "topover1";
            }
            else if (b > vmax)
            {
                height = vmax - top;
                type[1] = "bottomover1";
            }
        }
        else if (idx == 2)
        {
            b = top + height;

            if (left < hmin)
            {
                width -= (hmin - left);
                left = hmin;

                if (this._start_begarea != "left")
                    type[0] = "leftover0";
            }
            else if (left > hmax || (scroll_left < scroll_max && left > rightstart))
            {
                type[0] = "rightover0";
            }
            if (b < vmin || b > fixedbottom)
            {
                type[1] = "topover1";
            }
            else if (b > vmax)
            {
                height = vmax - top;
                type[1] = "bottomover1";
            }
        }
        else if (idx == 3)
        {
            r = left + width;

            if (r < hmin || (scroll_left > 0 && r < leftwidth))
            {
                type[0] = "leftover1";
            }
            else if (r > hmax)
            {
                width = hmax - left;

                if (this._start_endarea != "right")
                    type[0] = "rightover1";
            }
            if (top < vmin)
            {
                type[1] = "topover1";
            }
            else if (top > vmax)
            {
                height = vmax - top;
                type[1] = "bottomover1";
            }
        }

        return { type: type, adjust_l: left, adjust_t: top, adjust_w: width, adjust_h: height };
    };

    _pGrid._getExtraTrackSelectRect = function (screenX, screenY, distX, distY, bApplyFixedRow)
    {
        var idx = 1;
        var startinfo = this._track_start_info;

        var start_cell_startX = startinfo.start_screenX;
        var start_cell_startY = startinfo.start_screenY;
        //        var start_cell_screenX = startinfo.cell_screenX;
        //        var start_cell_screenY = startinfo.cell_screenY;


        var start_cell_scrollLeft = startinfo.scrollLeft;
        var start_cell_scrollTop = startinfo.scrollTop;


        //        var start_cell_width = startinfo.target.width;
        //        var start_cell_height = startinfo.target.height;
        var start_cell_row = startinfo.target._rowidx;
        /*
        var start_cell_startTopGap = start_cell_screenY - start_cell_startY;
        var start_cell_startBottomGap = start_cell_screenY - start_cell_startY + start_cell_height;
        var start_cell_startLeftGap = start_cell_startX - start_cell_screenX;
        var start_cell_startRightGap = start_cell_screenX - start_cell_startX + start_cell_width;
        */
        var scroll_left = this._getScrollLeft();
        var scroll_top = this._getScrollTop();
        var scroll_left_gap = scroll_left - start_cell_scrollLeft;
        var scroll_top_gap = scroll_top - start_cell_scrollTop;
        var adjust_scroll_top_gap = scroll_top_gap;

        var grid_body_screenx = nexacro.System.clientToScreenX(this, 0);
        var grid_body_screeny = nexacro.System.clientToScreenY(this, 0);

        var frame = this._getOwnerFrame();

        if (frame && (frame._window_type == 1 || frame._window_type == 4 || frame._window_type == 5))
        {
            var adjust_x = this._adjust_left;
            var adjust_y = this._adjust_top;

            var parent = this.parent;

            while (parent)
            {
                if (parent._is_frame)
                {
                    break;
                }

                adjust_x += parent._adjust_left;
                adjust_y += parent._adjust_top;

                parent = parent.parent;
            }
            var frame_screenx = nexacro.System.clientToScreenX(frame, 0);
            //            var frame_screeny = nexacro.System.clientToScreenY(frame, 0);
            if (frame_screenx == 0 && frame._adjust_left < 0)
                frame_screenx = frame._adjust_left;
            //            if (frame_screeny == 0 && frame._adjust_top < 0)
            //                frame_screeny = frame._adjust_left;

            grid_body_screenx = frame_screenx + adjust_x;
            // grid_body_screeny = frame_screeny + adjust_y;
        }

        var bApply_scroll_top = true;
        if (this._fixed_rowcnt > 0 && start_cell_row >= this._fixed_startrow && start_cell_row <= this._fixed_endrow)
            bApply_scroll_top = false;

        if (!bApply_scroll_top)
            adjust_scroll_top_gap = 0;

        if (screenX < (start_cell_startX - scroll_left_gap) && screenY < (start_cell_startY - adjust_scroll_top_gap))
        {
            idx = 0;

        }
        else if (screenX > (start_cell_startX - scroll_left_gap) && screenY > (start_cell_startY - adjust_scroll_top_gap))
        {
            idx = 1;
        }
        else if (screenX < (start_cell_startX - scroll_left_gap) && screenY > (start_cell_startY - adjust_scroll_top_gap))
        {
            idx = 2;
        }
        else if (screenX > (start_cell_startX - scroll_left_gap) && screenY < (start_cell_startY - adjust_scroll_top_gap))
        {
            idx = 3;
        }


        var x = distX;
        var y = distY;

        //        var type = new Array(2);
        /*
        var border = this._getCurrentStyleBorder();
        var border_left = (border) ? border.left._width : 0;
        var border_right = (border) ? border.right._width : 0;
        var border_top = (border) ? border.right._width : 0;
        var border_bottom = (border) ? border.right._width : 0;
        */
        var l, t, w, h;

        if (idx == 0)
        {
            l = this._track_point.x - grid_body_screenx + x;
            t = this._track_point.y - grid_body_screeny + y;
            w = -(x);
            h = -(y) - (bApply_scroll_top ? scroll_top_gap : 0);
        }
        else if (idx == 1)
        {
            l = this._track_point.x - grid_body_screenx - scroll_left_gap;
            t = this._track_point.y - grid_body_screeny - (bApply_scroll_top ? scroll_top_gap : 0);
            w = x + scroll_left_gap;
            h = y + (bApply_scroll_top ? scroll_top_gap : 0);
        }
        else if (idx == 2)
        {
            l = this._track_point.x - grid_body_screenx + x;
            t = this._track_point.y - grid_body_screeny - (bApply_scroll_top ? scroll_top_gap : 0);
            w = -(x) - scroll_left_gap;

            h = y + (bApply_scroll_top ? scroll_top_gap : 0);
        }
        else if (idx == 3)
        {
            l = this._track_point.x - grid_body_screenx - scroll_left_gap;
            t = this._track_point.y - grid_body_screeny + y;
            w = x + scroll_left_gap;
            h = -(y) - (bApply_scroll_top ? scroll_top_gap : 0);
        }

        return { idx: idx, l: l, t: t, w: w, h: h };
    };

    _pGrid.on_fire_sys_onmousemove = function (button, altKey, ctrlKey, shiftKey, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, metaKey)
    {
        if (!this._p_enable)
            return true;

        var win = this._getWindow();
        if (win && win._cur_ldown_elem)
        {
            return this._areaselectMove(from_refer_comp, canvasX, canvasY);
        }
    };

    _pGrid._setSelectedInfo = function (cell, col, datarow, subrow, pvt, areainfo)
    {
        if (this._currentBand != "body")
            return;

        if (cell !== null)
            this._selectinfo.curcell = this._p_currentcell = cell;
        if (col !== null)
            this._selectinfo.curcol = this._p_currentcol = col;
        if (datarow !== null)
        {
            this._selectinfo.curdsrow = this._currentDSrow = datarow;
            this._selectinfo.currow = this._p_currentrow = (datarow < 0) ? datarow : this._getTreeRowPosition(datarow);
        }
        if (subrow !== null)
            this._selectinfo.cursubrow = this._p_currentsubrow = subrow;
        if (pvt !== null)
            this._selectinfo.curpvt = this._p_currentpivot = pvt;

        if (areainfo)
        {
            this._selectinfo.areainfo = null;
            this._selectinfo.areainfo = {
                srow: areainfo.srow,
                erow: areainfo.erow,
                scell: areainfo.scell,
                ecell: areainfo.ecell,
                scol: areainfo.scol,
                ecol: areainfo.ecol,
                ssubrow: areainfo.ssubrow,
                esubrow: areainfo.esubrow,
                spvt: areainfo.spvt,
                epvt: areainfo.epvt
            };
        }
    };

    _pGrid._is_drag_selecting = false;
    _pGrid._on_grid_lbuttondown = function (cellobj, band, ctrlkey, shiftkey, no_select, metakey)
    {
        if (!this._is_alive) return;
        if (!this._p_enable)
            return true;

        var newPos = this._getDataRow(cellobj._rowidx);
        if (newPos == undefined)
            newPos = 0;

        if (this._isFakeCell(newPos) || newPos < 0)
            return true;

        var beforeCell = this._beforebodycellpos = this._selectinfo.curcell;
        var beforeCol = this._beforebodycolpos = this._selectinfo.curcol;
        var beforeRow = this._beforebodyrowpos = this._selectinfo.curdsrow;
        var beforeSubrow = this._beforebodysubrowpos = this._selectinfo.cursubrow;
        var beforePvt = this._beforepvt = this._selectinfo.curpvt;

        // current
        var afterCell = cellobj._cellidx;
        var afterCol = cellobj._refinfo._col;
        var afterRow = newPos;
        var afterSubrow = cellobj._refinfo._row;
        var afterPvt = -9;

        var parentcell = cellobj.parentcell;
        this._prevAreaCellObj = cellobj;

        if (parentcell)
        {
            afterCell = parentcell._cellidx;
            afterCol += parentcell._refinfo._col;
            this._prevAreaCellObj = parentcell;
        }

        if (!no_select)
            this._setSelectedInfo(afterCell, afterCol, afterRow, afterSubrow, afterPvt);

        if (ctrlkey == true)
        {
            if (this._isMultiSelect())
                this._multiselect = "ctrl";
            else
                this._multiselect = "none";
        }
        else if (shiftkey == true)
        {
            if (this._isMultiSelect() || this._isAreaSelect())
                this._multiselect = "shift";
            else
                this._multiselect = "none";
        }
        else
        {
            if (this._multiselect != "none")
                this._selectClear = true;

            this._multiselect = "none";
        }

        if ((this._isAreaSelect() || this._isMultiSelect()) && !nexacro._isTouchInteraction && this._p_selectchangetype == "down")
            this._is_drag_selectstart = true;

        var retn = false;

        if (!no_select)
            retn = this._ChangeSelect(afterCell, afterCol, afterRow, afterSubrow, afterPvt, false, beforeCell, beforeCol, beforeRow, beforeSubrow, beforePvt, band, "lbuttondown");

        var win = this._getWindow();
        if (win && (!this._env._p_enabletouchevent && !win._cur_ldown_elem))
            return;

        if (this._selectscrollmode != "select") return retn;
        this._is_drag_sameselect = retn ? false : true;

        if (this._is_event_canceling)
            return;

        if (!nexacro._isTouchInteraction && (this._isAreaSelect() || this._p_selecttype == "multirow"))
        {
            if (nexacro._Browser == "Runtime")
            {
                var frame = this._getOwnerFrame();

                if (frame._window_type != 2 && frame._window_type != 5) //not modeless, not modal window
                    frame = this._getApplication().mainframe;

                var x = win._curWindowX - ((frame._adjust_left >= 0) ? frame._adjust_left : 0);
                var y = win._curWindowY - ((frame._adjust_top >= 0) ? frame._adjust_top : 0);
                x = x * nexacro._getDevicePixelRatio(this.getElement());
                y = y * nexacro._getDevicePixelRatio(this.getElement());

                var parent_scroll_left = 0, parent_scroll_top = 0;
                var parent = this.parent;

                while (parent)
                {
                    if (parent._type_name == "Form")
                    {
                        parent_scroll_left = parent._control_element.scroll_left;
                        parent_scroll_top = parent._control_element.scroll_top - (parent._control_element.scroll_top > 0 ? this._adjust_top : 0); // this._adjust_top... runtime bug?
                        break;
                    }
                    parent = parent.parent;
                }

                var screenX = nexacro.System.clientToScreenX(frame, 0) + parent_scroll_left + x;
                var screenY = nexacro.System.clientToScreenY(frame, 0) + parent_scroll_top + y;

                nexacro._setExtraTrackInfo(win, this, win._curWindowX, win._curWindowY, screenX, screenY, shiftkey || no_select);
            }
            else
            {
                nexacro._setExtraTrackInfo(win, this, win._curWindowX, win._curWindowY, win._cur_screen_pos.x, win._cur_screen_pos.y, shiftkey || no_select);
            }
        }

        return retn;
    };

    _pGrid.on_fire_onselectchanged = function (obj, cell, col, row, subrow, pvt, oldcell, oldcol, oldrow, oldsubrow, oldpvt, selectendcol,
        selectendpivot, selectendrow, selectendsubrow, selectstartcol, selectstartpivot, selectstartrow, selectstartsubrow)
    {
        if (this.onselectchanged && this.onselectchanged._has_handlers)
        {
            var evt = new nexacro.GridSelectEventInfo(obj, "onselectchanged", cell, col, row, subrow, pvt, oldcell, oldcol, oldrow, oldsubrow, oldpvt, selectendcol,
                selectendpivot, selectendrow, selectendsubrow, selectstartcol, selectstartpivot, selectstartrow, selectstartsubrow);
            return this.onselectchanged._fireEvent(this, evt);
        }
        return true;
    };

    _pGrid.on_fire_oncellposchanged = function (obj, cell, col, row, subrow, pvt, oldcell, oldcol, oldrow, oldsubrow, oldpvt, selectendcol,
        selectendpivot, selectendrow, selectendsubrow, selectstartcol, selectstartpivot, selectstartrow, selectstartsubrow)
    {
        if (this.oncellposchanged && this.oncellposchanged._has_handlers)
        {
            var evt = new nexacro.GridSelectEventInfo(obj, "oncellposchanged", cell, col, row, subrow, pvt, oldcell, oldcol, oldrow, oldsubrow, oldpvt, selectendcol,
                selectendpivot, selectendrow, selectendsubrow, selectstartcol, selectstartpivot, selectstartrow, selectstartsubrow);
            return this.oncellposchanged._fireEvent(this, evt);
        }
        return true;
    };

    _pGrid.on_fire_user_onkeyup = function (keyCode, altKey, ctrlKey, shiftKey, obj, refer_comp, metaKey)
    {
        if (!this._p_enable)
            return true;

        if (shiftKey == false && ctrlKey == false)
        {
            if (keyCode != nexacro.Event.KEY_SHIFT && keyCode != nexacro.Event.KEY_CTRL)
                this._multiselect = "none";
        }

        if (this._iskey_movetocell)
            this._moveCellAfterFocus();

        this._iskey_movetocell = false;
        this._keydown_elem = null;
        this._keydown_keycode = undefined;

        this._is_up_act = true;
        var retn = nexacro.Component.prototype.on_fire_user_onkeyup.call(this, keyCode, altKey, ctrlKey, shiftKey, obj, refer_comp, metaKey);
        this._is_up_act = false;

        if (!this._is_alive)
            return retn;

        if (keyCode == nexacro.Event.KEY_RIGHT && altKey)
        {
            var format = this._curFormat;
            if (format)
            {
                var bodycells = format._bodycells;
                if (bodycells && bodycells.length)
                {
                    var cellinfo = this._getBodyCellInfo(this._selectinfo.curcell);
                    if (cellinfo)
                    {
                        var expandshow = cellinfo._getAttrValue(cellinfo._p_expandshow, this._selectinfo.curdsrow);
                        if (expandshow == "show")
                        {
                            if (this.onkeyup && this.onkeyup.defaultprevented == true)
                                ;
                            else
                                this.on_fire_onexpandup("none", altKey, ctrlKey, shiftKey, -1, -1, -1, -1, -1, -1, obj, refer_comp, metaKey);
                        }
                    }
                }
            }
        }

        return retn;
    };

    _pGrid._getColumnCellinfos = function (col, datarow, subrow)
    {
        var retn = [];
        var format = this._curFormat;
        var cellinfos;

        if (datarow == -1)
            cellinfos = format._headcells;
        else if (datarow == -2)
            cellinfos = format._summcells;
        else
            cellinfos = format._bodycells;

        for (var cell = 0; cell < cellinfos.length; cell++)
        {
            if (cellinfos[cell]._col == col && (subrow == undefined || cellinfos[cell]._row == subrow))
                retn.push(cellinfos[cell]);
        }

        return retn;
    };

    _pGrid._getCheckSubrow = function (col, datarow, subrow)
    {
        if (!this._check_subrow_map)
            this._check_subrow_map = [];

        var map = this._check_subrow_map[col];

        if (!map)
        {
            this._mappingCheckSubrow(col);
            map = this._check_subrow_map[col];
        }

        if (datarow >= 0)
        {
            for (var i = 0; i < map.length; i++)
            {
                if (map[i].bodysubrow == subrow)
                {
                    return map[i].headsubrow;
                }
            }
        }
        else
        {
            for (var i = 0; i < map.length; i++)
            {
                if (map[i].headsubrow == subrow)
                {
                    return map[i].bodysubrow;
                }
            }
        }
    }

    _pGrid._mappingCheckSubrow = function (col)
    {
        this._check_subrow_map[col] = [];

        var cells = this._getColumnCellinfos(col, -1);
        var sub;

        for (sub = 0; sub < cells.length; sub++)
        {
            if (cells[sub]._getEdittype(-1) == "checkbox")
                this._check_subrow_map[col].push({ headsubrow: cells[sub]._row, bodysubrow: -1 })
        }

        cells = this._getColumnCellinfos(col, 0);

        var headidx = 0;
        for (sub = 0; sub < cells.length; sub++)
        {
            if (cells[sub]._getEdittype(0) == "checkbox")
            {
                if (this._check_subrow_map[col][headidx])
                    this._check_subrow_map[col][headidx].bodysubrow = cells[sub]._row;
                else
                    this._check_subrow_map[col].push({ headsubrow: -1, bodysubrow: cells[sub]._row })

                headidx++;
            }
        }
    };

    _pGrid._checkAll = function (actioncell, datarow, v)
    {
        var dataset = this._binddataset;
        var edittype = actioncell._getEdittype(datarow);

        if (edittype != "checkbox")
            return;

        var colcells = this._getColumnCellinfos(actioncell._col, 0);

        this._act_checkall_col = actioncell._col;
        var redraw = this._p_enableredraw;
        this.enableredraw = false;

        if (datarow == -1)
        {
            var head_v = actioncell._convCheckValueToBoolean(v, -1);

            for (var row = 0; row < dataset.rowcount; row++)
            {
                for (var i = 0; i < colcells.length; i++)
                {
                    var edittype = colcells[i]._getEdittype(-1);
                    var subrow = this._getCheckSubrow(actioncell._col, -1, actioncell._row);

                    if (edittype == "checkbox" && subrow >= 0)
                    {
                        v = colcells[i]._convBooleanToCheckValue(head_v, row);
                        this._setCheck(actioncell._col, row, subrow, v, colcells[i]._getAttrValue(colcells[i]._p_checkboxfalsevalue, row), true);
                    }
                }
            }
        }

        this.enableredraw = redraw;
        this._act_checkall_col = undefined;
    };

    _pGrid._checkAllGroup = function (col, row, subrow, val)
    {
        if (row < 0)
            return;

        var cell = this._getColumnCellinfos(col, row, subrow)[0];
        var dataset = this._binddataset;
        var edittype = cell._getEdittype(row);

        if (edittype != "checkbox")
            return;

        this._act_checkall_col = col;
        var redraw = this._p_enableredraw;
        this.enableredraw = false;

        var count = dataset.getGroupRangeCount(row);
        var head_v = cell._convCheckValueToBoolean(val, row);

        row++;

        if (dataset._p_grouprowtype != "header")
            count++;

        for (var i = 0; i < count; i++)
        {
            val = cell._convBooleanToCheckValue(head_v, i + row);
            this._setCheck(col, i + row, subrow, val, cell._getAttrValue(cell._p_checkboxfalsevalue, i + row), true);
        }

        this.enableredraw = redraw;
        this._act_checkall_col = undefined;
    };

    _pGrid._on_fire_onhtmlcontrolapplyvalue = function (value, band, cell, rootnode)
    {
        var ret;
        if (this.onhtmlcontrolapplyvalue && this.onhtmlcontrolapplyvalue._has_handlers)
        {
            var band = band;
            var evt = new nexacro.GridHTMLControlApplyValueEventInfo(this, "", value, band, cell, rootnode);
            evt.cancelable = true;

            return this.onhtmlcontrolapplyvalue._fireEvent(this, evt);
        }
        return ret;
    };

    _pGrid._on_fire_onheadvaluechanged = function (oldvalue, newvalue, cell, no_defact)
    {
        var ret;
        if (this.onheadvaluechanged && this.onheadvaluechanged._has_handlers)
        {
            var evt = new nexacro.GridHeadValueChangedEventInfo(this, "onheadvaluechanged", oldvalue, newvalue, cell);
            ret = this.onheadvaluechanged._fireEvent(this, evt);

            if (this.onheadvaluechanged.defaultprevented == true)
                return ret;
        }

        if (!no_defact)
            this._checkAll(this._curFormat._headcells[cell], -1, newvalue);

        return ret;
    };

    _pGrid._makeCopyMatrix = function ()
    {
        var seltype = this._p_selecttype;
        var format = this._curFormat;
        var cells = format._bodycells;
        var collen = format._cols.length;
        var rowslen = format._bodyrows.length;
        var srow, erow, ssrow, scol;
        var matrix = [];

        if (cells)
        {
            if (seltype == "cell")
            {
                srow = erow = this._currentDSrow;
                scol = cells[this._p_currentcell]._col;
                ssrow = cells[this._p_currentcell]._row;
            }
            else if (seltype == "row")
            {
                srow = erow = this._currentDSrow;
                scol = 0;
                ssrow = 0;
            }
            else if (seltype == "multirow")
            {
                var select = this._selectinfo;
                if (select.area.length)
                {
                    var selinfo = select.area[select.area.length - 1];

                    srow = selinfo.begrow;
                    erow = selinfo.endrow;
                    scol = 0;
                    ssrow = 0;
                }
            }
            else
            {
                var select = this._selectinfo;
                if (select.area.length)
                {
                    var selinfo = select.area[select.area.length - 1];

                    srow = selinfo.begrow;
                    erow = selinfo.endrow;
                    scol = selinfo.begcol;
                    ssrow = selinfo.begsubrow[0];
                }
            }

            var matrix = [];

            if (srow == undefined)
                return matrix;

            function addMatrix(x, y, text)
            {
                y -= (srow * rowslen + ssrow);
                x -= scol;

                if (!matrix[y])
                    matrix[y] = [];

                if (text == null)
                    text = "";

                matrix[y][x] = text;
            }

            for (var row = srow; row <= erow; row++)
            {
                for (var i = 0; i < cells.length; i++)
                {
                    if (this._isSelectedCell(cells[i]._cellidx, row))
                    {
                        if (cells[i]._subcells.length)
                        {
                            var subcells = cells[i]._subcells;
                            for (var j = 0; j < subcells.length; j++)
                            {
                                var text = subcells[j]._getDisplayText(row);
                                addMatrix(cells[i]._col + subcells[j]._col, row * rowslen + cells[i]._row + subcells[j]._row, text);
                            }
                        }
                        else
                        {
                            var text = cells[i]._getDisplayText(row);
                            var colspan = cells[i]._colspan;
                            var rowspan = cells[i]._rowspan;

                            for (var j = 0; j < rowspan; j++)
                            {
                                for (var k = 0; k < colspan; k++)
                                {
                                    addMatrix(cells[i]._col + k, row * rowslen + cells[i]._row + j, text);
                                    text = "";
                                }
                            }

                        }
                    }
                }
            }
        }
        return matrix;
    };

    _pGrid._copyGridDataToTextClipboard = function (gridData)
    {
        var pthis = this;
        function escapeForExcel(text)
        {
            const needsEscape = /[\t\n\r]/g.test(text) || text.includes(pthis._copyseparator);

            if (needsEscape)
                return `"${text}"`;

            return text;
        }

        // gridData: 2D array (rows x columns)
        const lines = gridData.map(row =>
            row.map(text => escapeForExcel(text)).join(this._copyseparator)
        );
        const tsv = lines.join('\r\n');

        return new Blob([tsv], { type: 'text/plain' });
    }

    _pGrid._copyGridDataToHtmlClipboard = function (gridData)
    {
        var pthis = this;
        function escapeForExcel(text)
        {
            return text.replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/ /g, '&nbsp;')
                .replace(/\r\n/g, '<br>')
                .replace(/\n/g, '<br>');
        }

        var htmltable = `<html><head>
            <style>
                br {mso-data-placement:same-cell;}
            </style>
        </head>
        <body>
        <table><col>
        ${gridData.map(row =>
            `<tr>${row.map(text => `<td>${escapeForExcel(text)}</td>`).join('')}</tr>`
        ).join('')}
        </table></body></html>`.trim();

        return new Blob([htmltable], { type: 'text/html' });
    };


    _pGrid.on_fire_sys_onkeydown = function (keycode, alt_key, ctrl_key, shift_key, fire_comp, refer_comp, meta_key)
    {
        if (keycode == "67" && this._p_allowcopy)    // "C"
        {
            if (ctrl_key)
            {
                var copytext = "";
                var matrix = this._makeCopyMatrix();
                var blob_text = this._copyGridDataToTextClipboard(matrix);
                var blob_html = this._copyGridDataToHtmlClipboard(matrix);

                try
                {
                    var clipboardItem = new ClipboardItem({ 'text/plain': blob_text, 'text/html': blob_html });
                    navigator.clipboard.write([clipboardItem])
                }
                catch (e)
                {
                    trace("Copy failed: HTTPS or localhost required.");
                }
            }
        }

        if (this._is_down_act)
            this._on_last_keyup(true);
    };

    _pGrid._accessibilityHotkeyAction = function (keyCode, altKey, ctrlKey, shiftKey, metaKey)
    {
        var accGridHotkey = nexacro._AccessibilityUtil.checkComponentHotkey(this, keyCode, altKey, ctrlKey, shiftKey, metaKey);
        if (accGridHotkey)
        {
            this._hideEditor();
            var row = this._p_currentrow;
            switch (accGridHotkey)
            {
                case nexacro._AccessibilityUtil.Hotkey.FIRSTCELL:
                    this._p_currentcell = 0;
                    this._currentBand = "grid";
                    if (this._vscrollmng)
                    {
                        this._vscrollmng.setPos(0);
                    }
                    this._setAccessibilityBandFocus("next", false, true);
                    break;
                case nexacro._AccessibilityUtil.Hotkey.LASTCELL:
                    this._p_currentcell = this._getAccessibilityCellIndex() - 1;
                    this._currentBand = "grid";
                    if (this._vscrollmng)
                    {
                        this._vscrollmng.setPos(this._vscrollmng._max);
                    }
                    this._setAccessibilityBandFocus("prev", false, true);
                    break;
                case nexacro._AccessibilityUtil.Hotkey.FIRSTCELLINROW:
                    this._p_currentcol = 0;
                    if (this._env._p_enableaccessibility)
                        this._moveToPosAccessibilityCell(row, 0);
                    else
                        this._moveToPosCell(row, 0);
                    break;
                case nexacro._AccessibilityUtil.Hotkey.LASTCELLINROW:
                    this._p_currentcol = this._curFormat._cols.length - 1;
                    if (this._env._p_enableaccessibility)
                        this._moveToPosAccessibilityCell(row, this._p_currentcol);
                    else
                        this._moveToPosCell(row, this._p_currentcol);
                    break;
                case nexacro._AccessibilityUtil.Hotkey.FIRSTCELLINCOLUMN:
                    this._currentBand = "grid";
                    if (this._vscrollmng)
                    {
                        this._vscrollmng.setPos(0);
                    }

                    if (this._env._p_enableaccessibility)
                        this._setAccessibilityBandFocus("next", false, true);
                    else
                        this._moveToPosCell(0, this._p_currentcol);
                    break;
                case nexacro._AccessibilityUtil.Hotkey.LASTCELLINCOLUMN:
                    this._currentBand = "grid";
                    if (this._vscrollmng)
                    {
                        this._vscrollmng.setPos(this._vscrollmng._max);
                    }

                    if (this._env._p_enableaccessibility)
                        this._setAccessibilityBandFocus("prev", false, true);
                    else
                        this._moveToPosCell(this._rowcount - 1, this._p_currentcol);
                    break;
                /* accGridHotkey switch end */
            }
            return true;
        }
        return false;
    };
    /*
    _pGrid._isUsingCustomkeyAction = function (keyCode, altKey, ctrlKey, shiftKey, obj, refer_comp, metaKey)
    {
        while (refer_comp && refer_comp != this)
        {
            if (refer_comp._linked_interface && refer_comp._linked_interface instanceof nexacro._GridCustomControl)
            {
                var want = true;

                if (keyCode == nexacro.Event.KEY_ENTER)
                    want = refer_comp._getDlgCode(keyCode, altKey, ctrlKey, shiftKey).want_return;

                if (!want)
                    return false;

                return refer_comp._linked_interface._isUsingCustomKeyAction();
            }

            refer_comp = refer_comp.parent;
        }
        return false;
    };
    */
    _pGrid.on_fire_user_onkeydown = function (keyCode, altKey, ctrlKey, shiftKey, obj, refer_comp, metaKey)
    {
        if (this._env._p_enableaccessibility && this._accessibilityHotkeyAction(keyCode, altKey, ctrlKey, shiftKey, metaKey))
            return true;

        if (!this._p_enable) return true;

        var ret = nexacro.Component.prototype.on_fire_user_onkeydown.call(this, keyCode, altKey, ctrlKey, shiftKey, obj, refer_comp, metaKey);

        if ((this.onkeydown && this.onkeydown.defaultprevented == true) || !this._is_alive)
            return ret;

        //if (this._isUsingCustomkeyAction(keyCode, altKey, ctrlKey, shiftKey, obj, refer_comp, metaKey))
          //  return true;

        this._keydown_elem = this._getWindow()._keydown_element;

        if (!this._keydown_elem)    // alert으로 인한 초기화 등..
            return false;

        this._keydown_keycode = keyCode;

        var ref_comp = refer_comp;
        var is_popup_visible = false;

        if (keyCode != nexacro.Event.KEY_TAB)
        {
            if (refer_comp instanceof nexacro._GridCalendarControl || refer_comp.parent instanceof nexacro._GridCalendarControl ||
                refer_comp instanceof nexacro._GridComboControl || refer_comp.parent instanceof nexacro._GridComboControl ||
                refer_comp instanceof nexacro._GridMultiComboControl || refer_comp.parent instanceof nexacro._GridMultiComboControl ||
                refer_comp instanceof nexacro._GridGroupControl || refer_comp.parent instanceof nexacro._GridGroupControl)
            {
                while (ref_comp && ref_comp != this)
                {
                    if (ref_comp._isPopupVisible())
                    {
                        is_popup_visible = true;
                        break;
                    }
                    ref_comp = ref_comp.parent;
                }

                if (is_popup_visible)
                {
                    if (keyCode == nexacro.Event.KEY_ENTER && this._showEditing)
                    {
                        this._need_confirm_control_value = true;
                        this.on_fire_onenterdown(keyCode, altKey, ctrlKey, shiftKey, obj, refer_comp, "", metaKey);
                        this._need_confirm_control_value = false;
                    }

                    return ret;
                }
            }
        }

        var areamove = false;

        if (this._isAreaSelect())
            areamove = true;

        if (shiftKey == true)
        {
            if (keyCode == nexacro.Event.KEY_SHIFT)
                return ret;

            if (this._isMultiSelect() || this._isAreaSelect())
                this._multiselect = "shift";
            else
                this._multiselect = "none";
        }
        else if (ctrlKey == true)
        {
            if (keyCode == nexacro.Event.KEY_CTRL)
                return ret;

            if (this._multiselect != "none")
                this._selectClear = true;

            this._multiselect = "none";
        }
        else
        {
            if (this._multiselect != "none")
                this._selectClear = true;

            this._multiselect = "none";
        }

        var bEnterDown = false;
        var bShowEditor = true;
        this._is_data_enter_apply = false;

        if (this._p_autoenter == "key")
        {
            if (ctrlKey == false && altKey == false)
            {
                if (this._isChar(keyCode) || keyCode == 25 || (keyCode == 229 && nexacro._Browser == "Runtime" && nexacro._OS == "Windows")) // 오른쪽 alt, ctrl, 한/영키 처리 필요? keycode 229
                {
                    if (!this._showEditing)
                    {
                        this._showEditor();

                        if (keyCode == nexacro.Event.KEY_ENTER)
                        {
                            bEnterDown = true;
                        }
                        else
                        {
                            if (this._currentCellEditor && this._currentCellEditor._cellobj._writable)
                                this._currentCellEditor.set_value("");
                        }
                    }
                }
            }
        }

        if (!bEnterDown && keyCode == nexacro.Event.KEY_ENTER && this._showEditing)
        {
            var edit = this._currentCellEditor;
            var edittype = edit._cellinfo._getEdittype(this._getDataRow(edit._cellobj._rowidx));
            var acceptsenter = edit._cellinfo._getAttrValue(edit._cellinfo._p_textareaacceptsenter, this._selectinfo.curdsrow);
            acceptsenter = nexacro._toBoolean(acceptsenter);

            if (edittype == "textarea" && ((!acceptsenter && (altKey || ctrlKey || shiftKey)) || (acceptsenter && !altKey && !ctrlKey && !shiftKey)))
            {
                //
            }
            else if (edittype == "text" || edittype == "mask" || edittype == "date" || edittype == "combo" || edittype == "multicombo" || edittype == "textarea" /*|| edittype == "customcontrol"*/)
            {
                bEnterDown = true;
                bShowEditor = false;

                var ref_comp = refer_comp;
                var is_popup_visible = false;

                while (ref_comp && ref_comp != this)
                {
                    if (ref_comp._isPopupVisible())
                    {
                        is_popup_visible = true;
                        break;
                    }
                    ref_comp = ref_comp.parent;
                }

                if (is_popup_visible)
                    ;
                else
                {
                    this._hideEditor();
                    if (this._setdataobj && this._setdataobj.succ == false)
                    {
                        bShowEditor = true;
                    }
                    else
                    {
                        if (this._p_autoenter == "select")
                        {
                            var cellobj = this._findCellObj(refer_comp);
                            if (cellobj)
                            {
                                // bodycell 일때 enter 확정시 dataset에서 false되면 다시 열림
                                if (cellobj._band && cellobj._band._isBody)
                                {
                                    if (cellobj.parentcell)
                                    {
                                        cellobj = cellobj.parentcell;
                                    }

                                    if (!cellobj._virtualmerge && (cellobj._rowidx != this._p_currentrow || cellobj._cellidx != this._p_currentcell))
                                    {
                                        bShowEditor = true;
                                    }
                                    else
                                    {
                                        this._is_data_enter_apply = true;
                                    }
                                }
                            }
                            else
                            {
                                this._is_data_enter_apply = true;
                            }
                        }
                    }
                }
            }
        }

        var firecomp = refer_comp;
        var postvalue = "";
        var newpos;
        var editType;
        var format = this._curFormat;
        var bodycells;
        var cellinfo;

        if (keyCode == nexacro.Event.KEY_UP)
        {
            if (this._isEditorKeyAction(this._keydown_elem, refer_comp, keyCode, altKey, ctrlKey, shiftKey, metaKey) == false)
            {
                if (ctrlKey)
                {
                    if (this._scrollpixel == "all")
                        newpos = this._vscrollmng.pos - 25;
                    else
                        newpos = this._vscrollmng.pos - 1;

                    if (newpos < 0)
                        newpos = 0;

                    this._vscrollmng.setPos(newpos);
                }
                else
                {
                    if (this._env._p_enableaccessibility)
                        ret = this._moveToAccessibilityCell("up", false);
                    else
                        this._moveToCell("up");
                }
            }
        }
        else if (keyCode == nexacro.Event.KEY_DOWN)
        {
            if (this._isEditorKeyAction(this._keydown_elem, refer_comp, keyCode, altKey, ctrlKey, shiftKey, metaKey) == false)
            {
                if (ctrlKey)
                {
                    if (this._scrollpixel == "all")
                        newpos = this._vscrollmng.pos + 25;
                    else
                        newpos = this._vscrollmng.pos + 1;

                    if (newpos > this._vscrollmng.max)
                        newpos = this._vscrollmng.max;

                    this._vscrollmng.setPos(newpos);
                }
                else
                {
                    if (this._env._p_enableaccessibility)
                        ret = this._moveToAccessibilityCell("down", false);
                    else
                        this._moveToCell("down");
                }
            }
        }
        else if (keyCode == nexacro.Event.KEY_SPACE)
        {
            if (format)
            {
                var cells;
                if (this._env._p_enableaccessibility)
                {
                    if (this._currentBand == "head")
                        cells = format._headcells;
                    else if (this._currentBand == "body")
                        cells = format._bodycells;
                }
                else
                {
                    cells = format._bodycells;
                }

                if (cells && cells.length)
                {
                    cellinfo = cells[this._selectinfo.curcell];
                    if (cellinfo)
                    {
                        editType = cellinfo._getEdittype(this._selectinfo.curdsrow);
                        if (nexacro._toBoolean(this._p_readonly) == false)
                        {
                            if (editType == "checkbox")
                            {
                                if (this._toggleVal(this._selectinfo.curdsrow, cellinfo))
                                {
                                    this._jumpCurrentRow(this._selectinfo.currow);
                                }
                            }
                            else if (editType == "radioitem")
                            {
                                if (this._selectVal(this._selectinfo.curdsrow, cellinfo))
                                {
                                    this._jumpCurrentRow(this._selectinfo.currow);
                                }
                            }
                        }
                    }
                }
            }
        }
        else if (keyCode == nexacro.Event.KEY_ENTER)
        {
            if (!this._env._p_enableaccessibility || this._env._p_enableaccessibility && this._currentBand == "body")
            {
                //             if (this._p_autoenter != "select") 현재 체크 필요없어 보임. 2015.10.30
                {
                    editType = "";

                    if (refer_comp._type_name == "GridCellControl")
                    {
                        editType = refer_comp._refinfo._getEdittype(this._getDataRow(refer_comp._rowidx));
                        postvalue = refer_comp._refinfo._getValue(this._getDataRow(refer_comp._rowidx));
                    }
                    else if (refer_comp instanceof nexacro._GridCheckboxControl)
                    {
                        postvalue = refer_comp._cellinfo._getValue(this._getDataRow(refer_comp._cellobj._rowidx));
                    }
                    else if (refer_comp.parent instanceof nexacro._GridCheckboxControl)
                    {
                        postvalue = refer_comp.parent._cellinfo._getValue(this._getDataRow(refer_comp.parent._cellobj._rowidx));
                    }

                    function isEnterAction(refer_comp)
                    {
                        while (refer_comp && refer_comp != this)
                        {
                            if (refer_comp instanceof nexacro._GridEditControl ||
                                refer_comp instanceof nexacro._GridTextAreaControl ||
                                refer_comp instanceof nexacro._GridMaskEditControl ||
                                refer_comp instanceof nexacro._GridCheckboxControl ||
                                refer_comp instanceof nexacro._GridCalendarControl ||
                                refer_comp instanceof nexacro._GridComboControl ||
                                refer_comp instanceof nexacro._GridMultiComboControl)
                                return true;

                            //if (refer_comp._linked_interface && refer_comp._linked_interface instanceof nexacro._GridCustomControl)
                              //  return true;

                            refer_comp = refer_comp.parent;
                        }
                        return false;
                    }

                    if (editType == "checkbox" || isEnterAction(refer_comp))
                    {
                        if (this._showEditing || editType == "checkbox")
                        {
                            if (!altKey && !ctrlKey && !shiftKey)
                                bEnterDown = true;
                        }
                        else if (bShowEditor)
                        {
                            if (this._find_lastFocused() == this)
                            {
                                if (!this._getWindow()._modal_frame_stack.length)   // modal 창이 존재할 경우 pass (keydown)
                                {
                                    nexacro._OnceCallbackTimer.callonce(this, function ()
                                    {
                                        if (this._find_lastFocused() == this)
                                        {
                                            if (!this._getWindow()._modal_frame_stack.length)    // modal 창이 존재할 경우 pass (keydown이 끝난 후 enterdown 등)
                                                this._showEditor();
                                        }
                                    });
                                }
                            }
                        }
                    }
                    else
                    {
                        if (!this._showEditing)
                        {
                            nexacro._OnceCallbackTimer.callonce(this, function ()
                            {
                                this._showEditor();
                            });
                        }
                    }
                }
            }
        }
        else if (keyCode == nexacro.Event.KEY_LEFT)
        {
            if (format)
            {
                bodycells = format._bodycells;
                if (bodycells && bodycells.length)
                {
                    cellinfo = this._getBodyCellInfo(this._selectinfo.curcell);
                    if (cellinfo)
                    {
                        editType = cellinfo._getEdittype(this._selectinfo.curdsrow);
                        if (this._hasTree && (editType == "tree" || editType == "rowgroup") && (this._p_treeuseexpandkey || (altKey && ctrlKey)))
                        {
                            this._is_editor_keyaction = false;
                            this._treeStateKeyAction(this._selectinfo.currow, 0);
                        }
                        else if ((editType == "combo" && cellinfo._getAttrValue(cellinfo._p_combotype, this._selectinfo.curdsrow) == "dropdown") ||
                            (editType == "multicombo" && cellinfo._getAttrValue(cellinfo._p_multicombotype, this._selectinfo.curdsrow) == "dropdown"))
                        {
                            this._is_editor_keyaction = false;
                            if (this._env._p_enableaccessibility)
                                ret = this._moveToAccessibilityCell("prev", false, undefined, areamove);
                            else
                                this._moveToCell("prev", false, areamove, undefined, undefined, true);
                        }
                    }
                }

                if (this._isEditorKeyAction(this._keydown_elem, refer_comp, keyCode, altKey, ctrlKey, shiftKey, metaKey) == false)
                {
                    if (this._env._p_enableaccessibility)
                        ret = this._moveToAccessibilityCell("prev", false, undefined, areamove);
                    else
                        this._moveToCell("prev", false, areamove, undefined, undefined, true);
                }
            }
        }
        else if (keyCode == nexacro.Event.KEY_RIGHT)
        {
            if (format)
            {
                bodycells = format._bodycells;
                if (bodycells && bodycells.length)
                {
                    cellinfo = this._getBodyCellInfo(this._selectinfo.curcell);
                    if (cellinfo)
                    {
                        editType = cellinfo._getEdittype(this._selectinfo.curdsrow);
                        if (this._hasTree && (editType == "tree" || editType == "rowgroup") && (this._p_treeuseexpandkey || (altKey && ctrlKey)))
                        {
                            this._is_editor_keyaction = false;
                            this._treeStateKeyAction(this._selectinfo.currow, 1);
                        }
                        else if ((editType == "combo" && cellinfo._getAttrValue(cellinfo._p_combotype, this._selectinfo.curdsrow) == "dropdown") ||
                            (editType == "multicombo" && cellinfo._getAttrValue(cellinfo._p_multicombotype, this._selectinfo.curdsrow) == "dropdown"))
                        {
                            this._is_editor_keyaction = false;
                            if (this._env._p_enableaccessibility)
                            {
                                ret = this._moveToAccessibilityCell("next", false, undefined, areamove);
                                this._keydown_elem._event_stop = true;
                            }
                            else
                                this._moveToCell("next", false, areamove, undefined, undefined, true);
                        }
                        else
                        {
                            var expandshow = cellinfo._getAttrValue(cellinfo._p_expandshow, this._selectinfo.curdsrow);
                            if (expandshow == "show" && altKey)
                            {
                                this._is_editor_keyaction = false;
                                this.on_fire_onexpanddown("none", altKey, ctrlKey, shiftKey, -1, -1, -1, -1, -1, -1, obj, refer_comp, metaKey);
                            }
                        }
                    }
                }

                if (this._isEditorKeyAction(this._keydown_elem, refer_comp, keyCode, altKey, ctrlKey, shiftKey, metaKey) == false)
                {
                    if (this._env._p_enableaccessibility)
                        ret = this._moveToAccessibilityCell("next", false, undefined, areamove);
                    else
                        this._moveToCell("next", false, areamove, undefined, undefined, true);
                    if (this._env._p_enableaccessibility)
                        this._keydown_elem._event_stop = true;
                }
            }
        }
        else if (keyCode == nexacro.Event.KEY_PAGE_UP)
        {
            if (this._vscrollmng)
            {
                newpos = this._vscrollmng._pos - this._vscrollmng.page;

                if (this._scrollpixel != "all")
                    newpos = this._vscrollmng._scroll_reverse_convert(newpos)[0];

                if (newpos < 0)
                    newpos = 0;

                this._vscrollmng.setPos(newpos, "page_v");
            }
        }
        else if (keyCode == nexacro.Event.KEY_PAGE_DOWN)
        {
            if (this._vscrollmng)
            {
                newpos = this._vscrollmng._pos + this._vscrollmng.page;

                if (this._scrollpixel != "all")
                    newpos = this._vscrollmng._scroll_reverse_convert(newpos)[0];

                if (newpos > this._vscrollmng.max)
                    newpos = this._vscrollmng.max;

                this._vscrollmng.setPos(newpos, "page_v");
            }
        }
        else if (keyCode == nexacro.Event.KEY_TAB)
        {
            var tempselect = this._multiselect;
            if (this._env._p_enableaccessibility)
            {
                if (shiftKey)
                {
                    this._multiselect = "none";
                    this._acceptstab = this._moveToAccessibilityCell("prev", true);
                    this._multiselect = tempselect;
                }
                else
                    this._acceptstab = this._moveToAccessibilityCell("next", true);
            }
            else
            {
                if (shiftKey == true)
                {
                    this._multiselect = "none";
                    this._acceptstab = this._moveToCell("prev", true, false, undefined, undefined, true);
                    this._multiselect = tempselect;
                }
                else
                    this._acceptstab = this._moveToCell("next", true, false, undefined, undefined, true);
            }
            if (this._acceptstab && this._iskey_movetocell) // cell에서 발생된 tab일 때 grid keyup까지 올라가지 않음
            {
                this._moveCellAfterFocus();
                this._iskey_movetocell = false;
            }
            this._keydown_elem._event_stop = true;

            return this._acceptstab;
        }
        else
        {
            if (this._p_autoenter == "key")
            {
                if (ctrlKey == false && altKey == false)
                {
                    if (this._isChar(keyCode) || keyCode == 25 || (keyCode == 229 && nexacro._Browser == "Runtime" && nexacro._OS == "Windows")) // 오른쪽 alt, ctrl, 한/영키 처리 필요? keycode 229
                    {
                        if (!this._showEditing)
                        {
                            this._showEditor();
                        }
                    }
                }
            }
        }

        if (bEnterDown)
            this.on_fire_onenterdown(keyCode, altKey, ctrlKey, shiftKey, obj, firecomp, postvalue, metaKey);

        return ret;
    };

    _pGrid.on_fire_allclick = function (obj, eventid, clickitem, beforeCell, beforeCol, beforeRow, beforeSubrow, beforePvt, afterCell, afterCol, afterRow, afterSubrow, afterPvt, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        if ((this.onlbuttondown && this.onlbuttondown.defaultprevented == true) || (this.onlbuttonup && this.onlbuttonup.defaultprevented == true))
            return;
        if (this._isDownUpScroll())
            return;

        var click = this[eventid];
        if (click && click._has_handlers && this.enableevent)
        {
            var evt = new nexacro.GridClickEventInfo(obj, eventid, beforeCell, beforeCol, beforeRow, beforeSubrow, beforePvt, afterCell, afterCol, afterRow, afterSubrow, afterPvt, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
            evt.clickitem = clickitem;
            return click._fireEvent(this, evt);
        }
        return true;
    };

    _pGrid._getByteLength_UTF8 = function (s, b, i, c)
    {
        for (b = i = 0; c = s.charCodeAt(i++); b += c >> 11 ? 3 : c >> 7 ? 2 : 1);
        return b;
    };

    _pGrid.on_fire_cellclick = function (cellobj, clickitem, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        if (!this._is_alive) return;

        if (!this._p_enable) return true;

        var newPos = this._getDataRow(cellobj._rowidx);

        if (this._isFakeCell(newPos))
            return true;

        var subcellobj;
        if (cellobj.parentcell)
        {
            subcellobj = cellobj;
            cellobj = cellobj.parentcell;
        }

        var posobj = this._recalcXY(cellobj, canvasX, canvasY, true, from_refer_comp);
        canvasX = posobj.canvasX;
        canvasY = posobj.canvasY;
        clientX = posobj.clientX;
        clientY = posobj.clientY;

        if (nexacro._isTouchInteraction || (button == "touch"))		
        {
            if (cellobj._band.id == "body")
            {
                if (!(this._selectscrollmode == "select" && this._isAreaSelect()))
                {
                    this._mouseSelection(cellobj, ctrl_key, shift_key, canvasX, canvasY, from_comp, from_refer_comp, meta_key);
                }
            }

            if (((subcellobj && subcellobj._editor) || (cellobj._editor)) && !clickitem)
                clickitem = "control";
        }

        var beforeCell = this._beforebodycellpos;
        var beforeCol = this._beforebodycolpos;
        var beforeRow = this._beforebodyrowpos;
        var beforeSubrow = this._beforebodysubrowpos;
        var beforePvt = this._beforepvt;

        // current
        var afterCell = cellobj._cellidx;
        var afterCol = cellobj._refinfo._col;
        var afterRow = newPos;
        var afterSubrow = cellobj._refinfo._row;
        var afterPvt = -9;

        if (button == "none")
        {
            beforeCell = afterCell;
            beforeCol = afterCol;
            beforeRow = afterRow;
            beforeSubrow = afterSubrow;
            beforePvt = -9;
        }

        if (subcellobj)
            afterCol += subcellobj._refinfo._col;


        var obj = from_refer_comp;
        var showEditclick = false;

        while (obj && !(obj instanceof nexacro.Grid))
        {
            if (obj._displaymode == false && !obj._clickevt_able)
            {
                showEditclick = true;
            }

            obj = obj.parent;
        }

        if (!showEditclick)
            this.on_fire_allclick(this, "oncellclick", clickitem, beforeCell, beforeCol, beforeRow, beforeSubrow, beforePvt, afterCell, afterCol, afterRow, afterSubrow, afterPvt, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
    };

    _pGrid.on_fire_headclick = function (cellobj, clickitem, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        if (!this._p_enable || !this._is_alive)
            return true;

        var subcellobj;
        if (cellobj.parentcell)
        {
            subcellobj = cellobj;
            cellobj = cellobj.parentcell;
        }

        var posobj = this._recalcXY(cellobj, canvasX, canvasY, true, from_refer_comp);
        canvasX = posobj.canvasX;
        canvasY = posobj.canvasY;
        clientX = posobj.clientX;
        clientY = posobj.clientY;

        if (nexacro._isTouchInteraction || (button == "touch"))		
        {
            if (cellobj._band.id == "head")
            {
                if (!(this._selectscrollmode == "select" && this._isAreaSelect()))
                {
                    this._mouseSelection(cellobj, ctrl_key, shift_key, canvasX, canvasY, from_comp, from_refer_comp, meta_key);
                }
            }

            if (((subcellobj && subcellobj._editor) || (cellobj._editor)) && !clickitem)
                clickitem = "control";
        }

        var beforeCell = this._beforeheadcellpos;
        var beforeCol = this._beforeheadcolpos;
        var beforeRow = this._beforeheadrowpos;
        var beforeSubrow = this._beforeheadsubrowpos;
        var beforePvt = this._beforepvt;

        var afterCell = this._beforeheadcellpos = cellobj._cellidx;
        var afterCol = this._beforeheadcolpos = cellobj._refinfo._col;
        var afterRow = this._beforeheadrowpos = this._getDataRow(cellobj._rowidx);
        var afterSubrow = this._beforeheadsubrowpos = cellobj._refinfo._row;
        var afterPvt = -9;

        if (subcellobj)
            afterCol += subcellobj._refinfo._col;

        this.on_fire_allclick(this, "onheadclick", clickitem, beforeCell, beforeCol, beforeRow, beforeSubrow, beforePvt, afterCell, afterCol, afterRow, afterSubrow, afterPvt, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
    };

    _pGrid.on_fire_summaryclick = function (cellobj, clickitem, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        if (!this._p_enable || !this._is_alive)
            return true;

        var subcellobj;
        if (cellobj.parentcell)
        {
            subcellobj = cellobj;
            cellobj = cellobj.parentcell;
        }

        var posobj = this._recalcXY(cellobj, canvasX, canvasY, true, from_refer_comp);
        canvasX = posobj.canvasX;
        canvasY = posobj.canvasY;
        clientX = posobj.clientX;
        clientY = posobj.clientY;

        var beforeCell = this._beforesummcellpos;
        var beforeCol = this._beforesummcolpos;
        var beforeRow = this._beforesummrowpos;
        var beforeSubrow = this._beforesummsubrowpos;
        var beforePvt = this._beforepvt;

        var afterCell = this._beforesummcellpos = cellobj._cellidx;
        var afterCol = this._beforesummcolpos = cellobj._refinfo._col;
        var afterRow = this._beforesummrowpos = this._getDataRow(cellobj._rowidx);
        var afterSubrow = this._beforesummsubrowpos = cellobj._refinfo._row;
        var afterPvt = -9;

        if (subcellobj)
            afterCol += subcellobj._refinfo._col;

        this.on_fire_allclick(this, "onsummaryclick", clickitem, beforeCell, beforeCol, beforeRow, beforeSubrow, beforePvt, afterCell, afterCol, afterRow, afterSubrow, afterPvt, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
    };

    _pGrid.on_fire_celldblclick = function (cellobj, clickitem, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        if (!this._p_enable || !this._is_alive) return true;

        var newPos = this._getDataRow(cellobj._rowidx);

        if (this._isFakeCell(newPos))
            return true;

        var subcellobj;
        if (cellobj.parentcell)
        {
            subcellobj = cellobj;
            cellobj = cellobj.parentcell;
        }

        var posobj = this._recalcXY(cellobj, canvasX, canvasY, true, from_refer_comp);
        canvasX = posobj.canvasX;
        canvasY = posobj.canvasY;
        clientX = posobj.clientX;
        clientY = posobj.clientY;

        var beforeCell = this._dbclickPreCell;
        var beforeCol = this._dbclickPreCol;
        var beforeRow = this._dbclickPreRow;
        var beforeSubrow = this._dbclickPreSubrow;
        var beforePvt = this._dbclickPrePvt;

        var afterCell = cellobj._cellidx;
        var afterCol = cellobj._refinfo._col;
        var afterRow = newPos;
        var afterSubrow = cellobj._refinfo._row;
        var afterPvt = -9;

        if (subcellobj)
            afterCol += subcellobj._refinfo._col;

        this._dbclickPreCell = afterCell;
        this._dbclickPreCol = afterCol;
        this._dbclickPreRow = afterRow;
        this._dbclickPreSubrow = afterSubrow;
        this._dbclickPrePvt = afterPvt;

        this.on_fire_allclick(this, "oncelldblclick", clickitem, beforeCell, beforeCol, beforeRow, beforeSubrow, beforePvt, afterCell, afterCol, afterRow, afterSubrow, afterPvt, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
    };

    _pGrid.on_fire_headdblclick = function (cellobj, clickitem, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        if (!this._p_enable || !this._is_alive) return true;

        var subcellobj;
        if (cellobj.parentcell)
        {
            subcellobj = cellobj;
            cellobj = cellobj.parentcell;
        }

        var posobj = this._recalcXY(cellobj, canvasX, canvasY, true, from_refer_comp);
        canvasX = posobj.canvasX;
        canvasY = posobj.canvasY;
        clientX = posobj.clientX;
        clientY = posobj.clientY;

        var beforeCell = this._dbclickPreCell;
        var beforeCol = this._dbclickPreCol;
        var beforeRow = this._dbclickPreRow;
        var beforeSubrow = this._dbclickPreSubrow;
        var beforePvt = this._dbclickPrePvt;

        var afterCell = cellobj._cellidx;
        var afterCol = cellobj._refinfo._col;
        var afterRow = this._getDataRow(cellobj._rowidx);
        var afterSubrow = cellobj._refinfo._row;
        var afterPvt = -9;

        if (subcellobj)
            afterCol += subcellobj._refinfo._col;

        this._dbclickPreCell = afterCell;
        this._dbclickPreCol = afterCol;
        this._dbclickPreRow = afterRow;
        this._dbclickPreSubrow = afterSubrow;
        this._dbclickPrePvt = afterPvt;

        this.on_fire_allclick(this, "onheaddblclick", clickitem, beforeCell, beforeCol, beforeRow, beforeSubrow, beforePvt, afterCell, afterCol, afterRow, afterSubrow, afterPvt, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
    };

    _pGrid.on_fire_summarydblclick = function (cellobj, clickitem, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        if (!this._p_enable || !this._is_alive) return true;

        var subcellobj;
        if (cellobj.parentcell)
        {
            subcellobj = cellobj;
            cellobj = cellobj.parentcell;
        }

        var posobj = this._recalcXY(cellobj, canvasX, canvasY, true, from_refer_comp);
        canvasX = posobj.canvasX;
        canvasY = posobj.canvasY;
        clientX = posobj.clientX;
        clientY = posobj.clientY;

        var beforeCell = this._dbclickPreCell;
        var beforeCol = this._dbclickPreCol;
        var beforeRow = this._dbclickPreRow;
        var beforeSubrow = this._dbclickPreSubrow;
        var beforePvt = this._dbclickPrePvt;

        var afterCell = cellobj._cellidx;
        var afterCol = cellobj._refinfo._col;
        var afterRow = this._getDataRow(cellobj._rowidx);
        var afterSubrow = cellobj._refinfo._row;
        var afterPvt = -9;

        if (subcellobj)
            afterCol += subcellobj._refinfo._col;

        this._dbclickPreCell = afterCell;
        this._dbclickPreCol = afterCol;
        this._dbclickPreRow = afterRow;
        this._dbclickPreSubrow = afterSubrow;
        this._dbclickPrePvt = afterPvt;

        this.on_fire_allclick(this, "onsummarydblclick", clickitem, beforeCell, beforeCol, beforeRow, beforeSubrow, beforePvt, afterCell, afterCol, afterRow, afterSubrow, afterPvt, button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
    };

    _pGrid.on_dsnotify_onrowposchanged = function (obj, e)
    {
        var oldPos = this._rowposition;
        var newPos = parseInt(obj.rowposition, 10);

        this._rowposition = newPos;

        if (this.getElement() && this._userRowposChange == false)
        {
            var cellOldPos = -1;
            var cellNewPos = -1;
            var pthis = this;

            if (this._hasTree)
            {
                cellOldPos = this._getTreeRowPosition(oldPos);
                cellNewPos = this._getTreeRowPosition(newPos);
            }
            else
            {
                cellOldPos = oldPos;
                cellNewPos = newPos;
            }

            // previous
            var beforeCell;
            var beforeCol;
            var beforeRow;
            var beforeSubrow;
            var beforePvt;

            // current
            var afterCell;
            var afterCol;
            var afterRow;
            var afterSubrow;
            var afterPvt = -9;

            if (cellNewPos < 0)
            {
                afterCell = (this._selectinfo.curcell < 0) ? 0 : this._selectinfo.curcell;
                afterCol = (this._selectinfo.curcol < 0) ? 0 : this._selectinfo.curcol;
                afterRow = newPos;
                afterSubrow = (this._selectinfo.cursubrow < 0) ? 0 : this._selectinfo.cursubrow;

                function proc1()
                {
                    pthis._hideEditor();

                    beforeCell = pthis._beforebodycellpos = pthis._selectinfo.curcell;
                    beforeCol = pthis._beforebodycolpos = pthis._selectinfo.curcol;
                    beforeRow = pthis._beforebodyrowpos = pthis._selectinfo.curdsrow;
                    beforeSubrow = pthis._beforebodysubrowpos = pthis._selectinfo.cursubrow;
                    beforePvt = pthis._beforepvt = pthis._selectinfo.curpvt;

                    pthis._setSelectedInfo(afterCell, afterCol, afterRow, afterSubrow, afterPvt);
                    pthis._ChangeSelect(afterCell, afterCol, afterRow, afterSubrow, afterPvt, true, beforeCell, beforeCol, beforeRow, beforeSubrow, beforePvt, "body");
                    pthis._moveCellAfterFocus();
                }

                if (this._is_async_recreate)
                    nexacro._OnceCallbackTimer.callonce(this, proc1, 100);
                else
                    proc1();
            }
            else if (cellOldPos == cellNewPos)
            {
                // nothing
            }
            else
            {
                afterCell = (this._selectinfo.curcell < 0) ? 0 : this._selectinfo.curcell;
                afterCol = (this._selectinfo.curcol < 0) ? 0 : this._selectinfo.curcol;
                afterRow = newPos;
                afterSubrow = (this._selectinfo.cursubrow < 0) ? 0 : this._selectinfo.cursubrow;

                if (afterRow >= 0 && (this._isMultiSelect() || this._isAreaSelect()))
                {
                    if (obj._bWorkingstatus == true)    // 멀티로우 일때는 최초 로드시 셀렉션 처리를 하지 않음.
                    {
                        this._hideEditor();

                        beforeCell = this._beforebodycellpos = this._selectinfo.curcell;
                        beforeCol = this._beforebodycolpos = this._selectinfo.curcol;
                        beforeRow = this._beforebodyrowpos = this._selectinfo.curdsrow;
                        beforeSubrow = this._beforebodysubrowpos = this._selectinfo.cursubrow;
                        beforePvt = this._beforepvt = this._selectinfo.curpvt;

                        this._beforebodycellpos = -1;
                        this._beforebodycolpos = -1;
                        this._beforebodyrowpos = -1;
                        this._beforebodysubrowpos = -1;

                        this._setSelectedInfo(-1, -1, -1, -1, null);

                        this._ChangeSelect(-1, -1, -1, -1, afterPvt, true, beforeCell, beforeCol, beforeRow, beforeSubrow, beforePvt, "body");
                        this._moveCellAfterFocus();
                    }
                    else
                    {
                        // expr 일시 rowposition에 따라 달라질 대상이 존재할 수 있음.
                        if (this._getUseBindExprProp("body") || this._isUseBindExprStyle("body"))
                            this._refreshBody(true);
                        if (this._isUseBindExprStyle("head") || this._getUseBindExprProp("head"))
                            this._refreshHead(true);
                        if (this._isUseBindExprStyle("summ") || this._getUseBindExprProp("summ"))
                            this._refreshSumm(true);

                        var disprow = this._dsRowToDispRow(afterRow);   // 멀티로우에서는 스크롤 이동만..

                        function proc2()
                        {
                            pthis._jumpCurrentRow(disprow);
                            pthis._moveCellAfterFocus();
                        }

                        if (this._is_async_recreate)
                            nexacro._OnceCallbackTimer.callonce(this, proc2, 100);
                        else
                            proc2();
                    }
                }
                else
                {
                    function proc3()
                    {
                        pthis._hideEditor(); // _ChangeSelect 시 editor의 cellobj._rowidx가 변경되어 editor의 row값이 변경되므로 select변경전에 hide

                        beforeCell = pthis._beforebodycellpos = pthis._selectinfo.curcell;
                        beforeCol = pthis._beforebodycolpos = pthis._selectinfo.curcol;
                        beforeRow = pthis._beforebodyrowpos = pthis._selectinfo.curdsrow;
                        beforeSubrow = pthis._beforebodysubrowpos = pthis._selectinfo.cursubrow;
                        beforePvt = pthis._beforepvt = pthis._selectinfo.curpvt;

                        pthis._setSelectedInfo(afterCell, afterCol, afterRow, afterSubrow, afterPvt);

                        pthis._ChangeSelect(afterCell, afterCol, afterRow, afterSubrow, afterPvt, true, beforeCell, beforeCol, beforeRow, beforeSubrow, beforePvt, "body");
                        pthis._moveCellAfterFocus();
                    }

                    if (this._is_async_recreate)
                        nexacro._OnceCallbackTimer.callonce(this, proc3, 100);
                    else
                        proc3();
                }
            }
        }
    };

    _pGrid.on_dsnotify_oncolumnchanged = function (obj, e, async_call)
    {
        if (this._is_async_recreate)
        {
            if (!async_call)
            {
                var win = this._getWindow();
                win._postMessage(this, "oncolumnchanged", this._callbackPostmsg, [obj, e]);
            }
            return;
        }

        if (obj._bWorkingstatus == true)
        {
            this._recreate_contents_all(true, false);
            return;
        }

        var cols = [];
        var ds;

        this._clearCellStyleCache(this._curFormat);

        var bindcells = this._getBindTextCellInfo(e.columnid);

        if (bindcells)
        {
            var bind_cells = bindcells[0];
            for (var i = 0; i < bind_cells.length; i++)
            {
                if (bind_cells[i].parent.id == "body")
                {
                    if (bind_cells[i]._getEdittype(e.row) == "checkbox")
                    {
                        if (this._act_checkall_col != bind_cells[i]._col)
                        {
                            var v = this._getCheck(bind_cells[i]._col, e.row, bind_cells[i]._row);
                            var false_val = bind_cells[i]._getAttrValue(bind_cells[i]._p_checkboxfalsevalue, e.row);

                            if (nexacro._toBoolean(v) == false || v == false_val)
                            {
                                var vv = bind_cells[i]._convCheckValueToBoolean(v, e.row);
                                this._setCheckGroupHead(bind_cells[i]._col, e.row, bind_cells[i]._row, false_val, vv, true);

                                var subrow = this._getCheckSubrow(bind_cells[i]._col, e.row, bind_cells[i]._row);
                                v = bind_cells[i]._convCheckValueToBoolean(v, e.row);

                                this._setCheckHeadSumm(bind_cells[i]._col, -1, subrow, v, true, true);   // remove head check
                            }
                        }
                    }
                }
            }
        }

        if (this._isTreeStateChanged(e, this._dsEventOccured) == true)
        {
            this._updateTreeStates();

            var rowidx = this._getTreeRowPosition(e.row); //dsrow -> treerow
            var state = this._treeStates[e.row];

            if (this._bodyBand)
            {
                if (rowidx == -1) // dsrow가 tree에 diplay되지 않을때 bodyband 갱신
                {
                    this._recreate_contents_all(true, false, true);
                }
                else
                {
                    if (this._treeCellinfo.treelevel._bindexpr == e.columnid)   // level 변경
                    {
                        this._refreshBody();
                    }
                    else
                    {
                        if (state == 0)
                            this._bodyBand._matrix._adjustTreeDisplay(rowidx, true);
                        else
                            this._bodyBand._matrix._adjustTreeDisplay(rowidx, false);

                        var parentrow = this.getTreeParentRow(rowidx, true);
                        parentrow = this._dsRowToDispRow(parentrow, true);

                        this._refreshBodyRow(parentrow);
                    }
                }
            }
        }
        else if ((this._p_autosizingtype == "row" || this._p_autosizingtype == "both") && this._isChangeBodyRowSizeList(e.row) == true)
        {
            this._recreate_contents_all(true, false);
        }
        else if ((this._p_autosizingtype == "col" || this._p_autosizingtype == "both") && this._isChangeBodyColSizeList(e.columnid, cols, e.row) == true)
        {
            this._autofitcol_rate = [];

            if (cols.length > 1)
            {
                if (this._p_autosizingtype == "both")
                    this._recreate_contents_all(true, false);
                else
                    this._recreate_contents_all(false, false);
            }
            else if (cols.length == 1)
            {
                if (this._p_enableredraw)
                {
                    this._updateColSize(cols[0]);
                }
                else
                {
                    if (!this._enable_redraw_history.updatecolsize)
                        this._enable_redraw_history.updatecolsize = [];

                    this._enable_redraw_history.updatecolsize.push(cols[0]);
                }
            }
        }
        else
        {
            if (e.row >= 0)
            {
                if (this._hasTree && this._treeCellinfo.treecheck._bindexpr == e.columnid)
                    this._treeChecked = this._createTreeChecked();

                var displayrow = this._dsRowToDispRow(e.row, true);
                if (displayrow >= 0)
                {
                    var bhead = false;
                    var bsumm = false;

                    if (bindcells)
                    {
                        var cells = bindcells[0];
                        var bind = bindcells[1];

                        var cellsLen = cells.length, csupp;
                        var i;

                        if (this._is_use_suppress)
                        {
                            for (i = 0; i < cellsLen; i++)
                            {
                                csupp = cells[i]._getSuppress(e.row);
                                if (csupp != 0)
                                {
                                    this._suppressUpdate();
                                    break;
                                }
                            }
                        }

                        var b_continue = false;

                        for (i = 0; i < cellsLen; i++)
                        {
                            if (cells[i]._type == "head")
                                bhead = true;
                            else if (cells[i]._type == "summary")
                                bsumm = true;
                            else
                            {
                                if (e.col == -1 && e.colidx == -1)
                                {
                                    if (e.newvalue != undefined)
                                    {
                                        if (!b_continue)
                                        {
                                            if (this._hasTree)
                                            {
                                                this._initTreeStates(true, true);   // copyrow
                                                this._recreate_contents_all(false, false, true);
                                            }
                                            else
                                            {
                                                this._refreshBodyRow(displayrow);
                                            }
                                            b_continue = true;
                                        }

                                        if (this._currentCellEditor && cells[i]._col == this._currentCellEditor._cellinfo._col && cells[i]._row == this._currentCellEditor._cellinfo._row && e.row == this._currentCellRow)
                                        {
                                            this._currentCellEditor._setProperty();
                                        }
                                    }
                                }
                                else
                                {
                                    /* if (0) // this._hasTree)    소나큐브무시
                                    {
                                        if (!b_continue)
                                        {
                                            this._refreshBody();
                                            b_continue = true;
                                        }
                                    }
                                    else */
                                    {
                                        var isrefreshexprcell = false;
                                        csupp = cells[i]._getSuppress(e.row);
                                        if (csupp > 0)
                                        {
                                            var bodycells = this._curFormat._bodycells;
                                            isrefreshexprcell = true;

                                            for (var j = 0, n = bodycells.length; j < n; j++)
                                            {
                                                if (bodycells[j]._getSuppress(e.row) >= csupp)
                                                {
                                                    this._refreshCell("body", j);
                                                }
                                            }
                                        }
                                        else if (csupp < 0)
                                        {
                                            if (!b_continue)
                                            {
                                                this._refreshBodyRow(displayrow);
                                                b_continue = true;
                                                isrefreshexprcell = true;
                                            }
                                        }
                                        else
                                        {
                                            if (!b_continue)
                                            {
                                                ds = this._binddataset;
                                                if (ds.keystring && ds._keycols.length > 0) // case by Dataset use Group
                                                {
                                                    this._refreshBody();
                                                }
                                                else
                                                {
                                                    this._refreshBodyRow(displayrow);
                                                    isrefreshexprcell = true;
                                                }
                                                b_continue = true;
                                            }
                                        }

                                        if (isrefreshexprcell)
                                        {
                                            var exprbindcells = null;

                                            if ((exprbindcells = this._getUseBindExprProp("body")))
                                            {
                                                if (this._expr_allrow_update_prop || this._expr_allrow_update_style)
                                                {
                                                    for (var jj = 0; jj < exprbindcells.length; jj++)
                                                    {
                                                        this._refreshCell("body", exprbindcells[jj], undefined);
                                                    }
                                                }
                                            }
                                        }

                                        if (bind && this._currentCellEditor && cells[i]._col == this._currentCellEditor._cellinfo._col && cells[i]._row == this._currentCellEditor._cellinfo._row && e.row == this._currentCellRow)
                                        {
                                            this._currentCellEditor._setProperty();
                                        }
                                    }
                                }
                                bsumm = true;
                            }
                        }
                    }
                    if (bhead || this._getUseBindExprProp("head"))
                        this._refreshHead();
                    if (bsumm || this._getUseBindExprProp("summ"))
                        this._refreshSumm();
                }
                else
                {
                    if (this._hasTree)  
                    {
                        if (e.columnid == "") // column 전체가 변경
                        {
                            this._initTreeStates(true);
                            this._recreate_contents_all(false, false, true);
                        }
                        else
                        {
                            ds = this._binddataset;
                            if (ds.keystring && ds._keycols.length > 0) // case by Dataset use Group
                            {
                                this._refreshBody();
                            }

                        }
                    }
                }
            }
            else
            {
                this._refreshHead();
                this._refreshSumm();

                if (obj._isConstColumn(e.col) == true)
                    this._refreshBody();
            }
        }
    };

    _pGrid.on_dsnotify_onload = function (obj, e)
    {
        if (!this._is_created && this._rowcount == obj._p_rowcount)
            return;

        var prevrowcnt = this._rowcount;
        var _reason = e.reason;

        this._rowcount = obj._p_rowcount;
        this._applyPageRowCount();
        this._rowposition = obj.rowposition;

        if (_reason != 91) //unbind 시에는 미참조 
        {
            this._initSelect(this._rowposition);
        }

        if (this._is_down_act && !this._isDownActionKeyMouse())
            this._is_down_act = false;

        // clear exprcache
        this._exprcache = {};
        this._initChecked();
        this._initTreeStates();
        this._clearFilterSortInfo();

        var _errorcode = e.errorcode;
        if (_errorcode < 0)
            return;

        if (_reason == 0 || _reason == 1 || _reason == 2 || _reason == 3)
        {
            if (_reason == 1 || (_reason == 0 && e.progressload)) // progressload
            {
                if (this._p_autosizingtype != "none")  // 여기로 탈 경우 성능저하가 일어남.
                {
                    if (this._async_create == true)
                        this._recreate_contents_all_async(true, false, false, undefined, prevrowcnt);
                    else
                        this._recreate_contents_all(true, false, false, undefined, prevrowcnt);
                }
                else
                {
                    this._updateBodyClient("progressload", undefined, prevrowcnt);
                }
            }
            else
            {
                if (this._p_autosizingtype != "none")
                {
                    this._recreate_contents_all(true, true, false);
                }
                else
                {
                    this._updateBodyClient("load");
                }
            }
        }
        else if (_reason == 91) // dataset destroy
        {
            this._recreate_contents_all(true, true);
            this._binddataset = null;
        }
        else if (_reason == 12) // dataset append
        {
            var body = this._bodyBand;
            if (!body)
                return;

            var lastrow = prevrowcnt - 1;
            var toppos = body._matrix._getBodyRowTopPos(lastrow + 1) - this._getScrollTop();
            var rect = this._getAvailableRect(body);
            var chk_srow = prevrowcnt;

            var disp_rows_len = body._matrix._rows.length;
            var row = lastrow + 1; //append 니까..

            // 보이지 않는 영역은 정보만 갱신
            if (toppos >= rect.height && lastrow < row && (disp_rows_len % 2 != 1))
            {
                if (this._is_user_change_head_rowsize || this._is_user_change_body_rowsize || this._is_user_change_summ_rowsize)
                {
                    this._recreate_contents_all(true, false, true);
                }
                else
                {
                    this._resetRowSizeList(chk_srow);
                    this._resetColSizeList(chk_srow);
                    this._resetScrollMax();
                }
            }
            else
            {
                if (this._hasTree)
                {
                    this._initTreeStates(true);
                    this._recreate_contents_all(true, false, true);
                }
                else if (this._p_autosizingtype == "col" || this._p_autosizingtype == "both")
                {
                    this._recreate_contents_all(true, false);
                }
                else
                {
                    this._updateBodyClient("appenddata");
                }
            }
        }
    };

    _pGrid.on_dsnotify_onrowsetchanged = function (obj, e)
    {
        var dataset = this._binddataset;
        var bchange_rowcnt = (this._rowcount != dataset._p_rowcount);
        var prev_rowcnt = this._rowcount;
        this._rowcount = dataset._p_rowcount;

        this._initChecked();
        this._applyPageRowCount();

        var updaterow_pos = false;
        if (this._rowposition != dataset.rowposition)
            updaterow_pos = true;

        if (this._is_down_act && !this._isDownActionKeyMouse())
            this._is_down_act = false;

        this._rowposition = dataset.rowposition;
        if (this._curFormat)
        {
            var lastrow = this._rowcount - 1;
            var kind;

            switch (e.reason)
            {
                case 10:
                    kind = "assign";
                    break;
                case 11:
                    kind = "copydata";
                    break;
                case 12:
                    if (e.row == -1) kind = "appenddata";
                    else if (e.row == lastrow) kind = "addrow";
                    else if (e.row < lastrow) kind = "insertrow";
                    break;
                case 20:
                    if (e.row == -1) kind = "deletemultirows";
                    else kind = "deleterow";
                    break;
                case 22:
                    kind = "deleteall";
                    break;
                case 23:
                    kind = "cleardata";
                    break;
                case 24:
                    kind = "clear";
                    break;
                case 30:
                    kind = "keystring";
                    break;
                case 31:
                    if (e.row == -1) kind = "filter";
                    else kind = "filterrow";
                    break;
                case 32:
                    kind = "moverow";
                    break;
                case 33:
                    kind = "exchangerow";
                    break;
                case 34:
                    kind = "addcolumn";
                    break;
                case 41:
                    kind = "enableevent";
                    break;
                case 40:
                    kind = "rowtype";
                    break;
                default:
                    break;
            }

            if (kind == "copydata" || kind == "addcolumn" || kind == "assign" || kind == "filter")
            {
                this._exprcache = {};
                this._resetSelect(this._rowposition);

                if (kind == "filter" && !this._is_grid_filtering)
                    this._clearFilterInfo();
            }
            else if (kind == "enableevent" || kind == "appenddata")
            {
                this._exprcache = {};
            }
            else if (kind == "deleterow" || kind == "filterrow")
            {
                this._updateTreeStates(e.row, false); //refresh states
                this._delOverSelectInfo();
            }
            else if (kind == "deletemultirows")
            {
                var rows = obj._deleteRows;

                for (var i = rows.length - 1; i >= 0; i--)
                {
                    this._updateTreeStates(rows[i], false);
                }
                this._delOverSelectInfo();
            }
            else if (kind == "deleteall" || kind == "cleardata" || kind == "clear")
            {
                this._clrMultiSelect();
                this._setSelectedInfo(-1, -1, -1, -1, null);
                this._destroyOverlayControls();
                this._destroySelectionControls();
                this._destroyCellSelectionControl();
            }
            else if (kind == "copydata")
            {
                this._setSelectedInfo(null, null, this._rowposition, 0, null);
            }
            else if (kind == "addrow" || kind == "insertrow" || kind == "appendrow")
            {
                this._updateTreeStates(e.row, true);
            }
            else if (kind == "keystring")
            {
                if (!this._is_grid_sort_grouping)
                    this._clearGroup(true);
            }

            if (kind != "addrow")
            {
                this._clearCellStyleCache(this._curFormat);
            }

            if (this._is_async_recreate)
            {
                var win = this._getWindow();
                win._postMessage(this, "afterrowset", this._callbackPostmsg, [kind, updaterow_pos, e.row, bchange_rowcnt, prev_rowcnt]);
            }
            else
            {
                this._afterRowsetChanged(kind, updaterow_pos, e.row, bchange_rowcnt, prev_rowcnt);
            }
        }
    };

    _pGrid._clearCellStyleCache = function (format, fontcache)
    {
        if (!format)
            return;

        var cellinfos, cellcount;

        for (var j = -2; j < 1; j++)        
        {
            if (j == -2)
            {
                cellinfos = format._summcells;
            }
            else if (j == -1)
            {
                cellinfos = format._headcells;
            }
            else if (j >= 0)
            {
                cellinfos = format._bodycells;
            }

            if (cellinfos)
            {
                cellcount = cellinfos.length;
                for (var i = 0; i < cellcount; i++)
                {
                    cellinfos[i]._clearStyle();
                    cellinfos[i]._clearCurCache(fontcache);
                }
            }
        }
    };

    _pGrid._callbackPostmsg = function (e)
    {
        var args = e.data;
        if (e.id == "afterrowset")
        {
            this._afterRowsetChanged(args[0], args[1], args[2], args[3], args[4]);
        }
        else if (e.id == "oncolumnchanged")
        {
            this.on_dsnotify_oncolumnchanged(args[0], args[1], true);
        }
    };

    _pGrid._afterRowsetChanged = function (kind, updaterow_pos, row, bchange_rowcnt, prev_rowcnt)
    {
        if (this.getElement())
        {
            var bodyBand = this._bodyBand;

            //            if (kind == "moverow" || kind == "enableevent")
            //                this._hideEditor(true);
            //            else
            this._hideEditor(true);

            if (kind == "copydata" || kind == "assign")
            {
                this._initTreeStates();

                if (!this._p_enableredraw)
                {
                    this._enable_redraw_history.recreate = true;
                    return;
                }

                this._recreate_contents_all(true, true);
            }
            else if (kind == "addcolumn")
            {
                this._initTreeStates(true);

                if (!this._p_enableredraw)
                {
                    this._enable_redraw_history.recreate = true;
                    return;
                }

                this._recreate_contents_all(true, false);
            }
            else if (kind == "keystring")
            {
                this._initTreeStates();

                if (!this._p_enableredraw)
                {
                    this._enable_redraw_history.recreate_body = true;
                    return;
                }

                if (this._p_autosizingtype == "col" || this._p_autosizingtype == "both")
                    this._recreate_contents_all(true, false);
                else
                    this._recreate_contents_all(true, false, false);

                this._resetSelect(this._rowposition, this._selectinfo.curcell, this._selectinfo.curcol, this._selectinfo.cursubrow, this._selectinfo.curpvt);
            }
            else if (kind == "enableevent")
            {
                this._initTreeStates(true);

                if (!this._p_enableredraw)
                {
                    this._enable_redraw_history.recreate = true;
                    return;
                }

                if (bchange_rowcnt || this._p_autosizingtype != "none")
                {
                    this._recreate_contents_all(true, false);
                }
                else
                {
                    if (this._hasTree)
                    {
                        if (bodyBand)
                        {
                            bodyBand._matrix._adjustRowsDisplay(true);
                            bodyBand._matrix._adjustColsDisplay();
                            bodyBand._on_refresh_rows();
                        }

                    }
                    this._refreshAll();
                }

                if (updaterow_pos == false)
                {
                    this._select_noscroll = true;
                }

                if (!this._isMultiSelect() && !this._isAreaSelect())
                    this._resetSelect(this._rowposition, this._selectinfo.curcell, this._selectinfo.curcol, this._selectinfo.cursubrow, this._selectinfo.curpvt);

                this._select_noscroll = false;

                if (!this._is_created)
                {
                    this._create_selection = {
                        cell: this._selectinfo.curcell,
                        col: this._selectinfo.curcol,
                        row: this._selectinfo.curdsrow,
                        subrow: this._selectinfo.cursubrow,
                        pvt: this._selectinfo.curpvt
                    };
                }
            }
            else if (kind == "addrow" || kind == "appenddata" || kind == "deleterow" || kind == "filterrow" || kind == "insertrow" || kind == "deletemultirows" || kind == "filter")              
            {
                if (bodyBand)
                {
                    var chk_srow;

                    if (kind == "addrow" || kind == "appenddata") // || kind == "insertrow") 는 따로 개선 필요
                        chk_srow = prev_rowcnt;

                    if (row <= this._fixed_endrow)
                    {
                        if (!this._p_enableredraw)
                        {
                            this._enable_redraw_history.recreate = true;
                            return;
                        }

                        this._resetRowSizeList(chk_srow);
                        this._resetColSizeList(chk_srow);
                        this._setFixedRow(-1);
                    }
                    else
                    {
                        var lastrow = this._getDataRow(this._endrowpos);
                        var toppos = bodyBand._matrix._getBodyRowTopPos(lastrow + 1) - this._getScrollTop();
                        var rect = this._getAvailableRect(bodyBand);
                        var disp_rows_len = bodyBand._matrix._rows.length;

                        // 보이지 않는 영역은 정보만 갱신
                        if (toppos >= rect.height && lastrow < row && (disp_rows_len % 2 != 1) && this._vscrollmng.max > 0)
                        {
                            if (!this._p_enableredraw)
                            {
                                this._enable_redraw_history.recreate = true;
                                return;
                            }

                            if (this._is_user_change_head_rowsize || this._is_user_change_body_rowsize || this._is_user_change_summ_rowsize)
                            {
                                this._recreate_contents_all(true, false, true, undefined, chk_srow);
                            }
                            else
                            {
                                this._resetRowSizeList(chk_srow);
                                this._resetColSizeList(chk_srow);
                                this._resetScrollMax();
                            }
                            if (kind == "deleterow")
                            {
                                var disprow = this._dsRowToDispRow(row);
                                this._jumpCurrentRow(disprow);      // 스크롤을 여기서.. rowpos가 동일하여 rowposchanged가 발생하지않음.
                            }
                            else
                            {
                                // scroll 이동은 rowposchanged에서..
                            }
                        }
                        else
                        {
                            if (kind == "insertrow")
                            {
                                // this._initTreeStates 필요한 경우?
                            }
                            else
                            {
                                if (this._hasTree)
                                    this._initTreeStates((kind == "addrow" || kind == "appenddata" || kind == "deleterow"));    // kind == "deletemultirows" 도 해당될지?
                            }

                            if (!this._p_enableredraw)
                            {
                                this._enable_redraw_history.recreate = true;
                                return;
                            }

                            if (this._p_autosizingtype == "col" || this._p_autosizingtype == "both")
                            {
                                this._recreate_contents_all(true, false, false, undefined, chk_srow);
                            }
                            else if (this._p_autosizingtype == "row")
                            {
                                this._recreate_contents_all(true, false, false, undefined, chk_srow);
                            }
                            else
                            {
                                if (this._hasTree)
                                    this._recreate_contents_all(true, false, false, undefined, chk_srow);
                                else
                                    this._updateBodyClient(kind, row, chk_srow);
                            }
                        }
                    }
                }
                else
                {
                    if (!this._p_enableredraw)
                    {
                        this._enable_redraw_history.recreate = true;
                        return;
                    }

                    this._recreate_contents_all(true, false);
                }
            }
            else if (kind == "exchangerow" || kind == "moverow")
            {
                if (this._p_autosizingtype != "none" || this._hasTree)
                {
                    this._initTreeStates(true);

                    if (!this._p_enableredraw)
                    {
                        this._enable_redraw_history.recreate = true;
                        return;
                    }

                    this._recreate_contents_all(false, false, true);
                }
                else
                    this._refreshBody();
            }
            else if (kind == "rowtype")
            {
                if (!this._p_enableredraw)
                {
                    this._enable_redraw_history.refreshall = true;
                    return;
                }

                this._refreshAll();
            }
            else
            {
                this._initTreeStates();

                if (!this._p_enableredraw)
                {
                    this._enable_redraw_history.recreate = true;
                    return;
                }

                this._recreate_contents_all(true, false);
            }
            this._moveCellAfterFocus();
        }
    };

    _pGrid._getDisplayRowCount = function ()
    {
        var band = this._bodyBand;
        if (band)
            return band._get_rows().length;

        return 0;
    };

    _pGrid._needUpdateExtinner = function (b_size)
    {
        var _vpos = (this.vscrollbar) ? this.vscrollbar._pos : 0;
        var band = this._bodyBand;
        var ext_cnt = band._control_element._getExtendContainerCount();

        if (ext_cnt > 0 && (b_size || _vpos > (this._div_max_height - (this._getClientWidth() * 2))))
            return true;

        return false;
    };

    _pGrid._updateBodyClient = function (kind, row, chk_srow)
    {
        var band = this._bodyBand;
        if (!band)
            return;

        var oldfixed = this._fixed_height;

        this._resetRowSizeList(chk_srow);
        this._resetColSizeList(chk_srow);

        if ((oldfixed != this._fixed_height) && this._bodyBand)
            this._bodyBand._control_element._setFixArea(this._fixed_height);

        var beforerowcnt = this._getDisplayRowCount();

        this._resetScrollMax();
        this._applyAutofittype(true);

        var rows;
        var rows_len;
        var disprow;
        var datarow;
        var i;
        var lastPosition;
        var _vpos;

        if (kind == "insertrow")
        {
            if (this._needUpdateExtinner())
            {
                this._recreate_contents_all(false, false, true);
            }
            else
            {
                band._matrix._adjustRowsDisplay();
                band._matrix._adjustColsDisplay();

                rows = band._get_rows();
                rows_len = rows.length;

                for (i = 0; i < rows_len; i++)
                {
                    datarow = this._getDataRow(rows[i]._rowidx);
                    if (row > datarow)
                        continue;

                    band._update_rows.push(rows[i]);
                }

                band._on_refresh_rows();
            }

            disprow = this._dsRowToDispRow(row);
            this._jumpCurrentRow(disprow);      // 스크롤을 여기서.. 갱신 여러번 할시 rowpos가 동일하여 rowposchanged가 발생하지않음.
        }
        else if (kind == "deleterow")
        {
            _vpos = (this._vscrollmng) ? this._vscrollmng._pos : 0;
            _vpos -= this._is_over_scroll;

            if (_vpos < 0)
                _vpos = 0;

            if (this._needUpdateExtinner())
            {
                this._recreate_contents_all(false, false, true);
            }
            else
            {
                this._toprowpos = this._getScreenTopRowPos(_vpos);
                this._bottomrowpos = this._getScreenBottomRowPos(_vpos);

                band._matrix._adjustRowsDisplay();
                band._matrix._adjustColsDisplay();

                rows = band._get_rows();
                rows_len = rows.length;

                for (i = 0; i < rows_len; i++)
                {
                    datarow = this._getDataRow(rows[i]._rowidx);
                    if (row > datarow)
                        continue;

                    band._update_rows.push(rows[i]);
                }

                band._on_refresh_rows();
            }

            row = this._binddataset.rowposition; // delete후 row가 사라질 수 있으므로..

            disprow = this._dsRowToDispRow(row);
            this._jumpCurrentRow(disprow);      // 스크롤을 여기서.. 갱신 여러번 할시 rowpos가 동일하여 rowposchanged가 발생하지않음.

            lastPosition = this._last_scroll_top;

            if (lastPosition != _vpos)
                band._update_rows = band._matrix._adjustScrollRows(_vpos);

            band._on_refresh_rows();

            if (this._is_over_scroll > 0)
                this._vscrollmng.setPos(this._vscrollmng.pos - 1);
        }
        else if (kind == "load")
        {
            if (this._needUpdateExtinner())
            {
                this._recreate_contents_all(false, true, true);
            }
            else
            {
                this._toprowpos = this._getScreenTopRowPos(0);
                this._bottomrowpos = this._getScreenBottomRowPos(0);

                band._update_rows = band._matrix._adjustScrollRows(0, true);
                band._matrix._adjustRowsDisplay();
                band._matrix._adjustColsDisplay();
                band._on_refresh_rows();

                this._vscrollmng.setPos(0);
            }
        }
        else if (kind == "progressload")
        {
            if (this._needUpdateExtinner())
            {
                this._recreate_contents_all(false, false, true);
            }
            else
            {
                band._matrix._adjustRowsDisplay();
                band._matrix._adjustColsDisplay();
                band._on_refresh_rows();
            }
        }
        else
        {
            _vpos = (this._vscrollmng) ? this._vscrollmng._pos : 0;
            _vpos -= this._is_over_scroll;

            if (_vpos < 0)
                _vpos = 0;

            this._toprowpos = this._getScreenTopRowPos(_vpos);
            this._bottomrowpos = this._getScreenBottomRowPos(_vpos);

            if (this._needUpdateExtinner())
            {
                this._recreate_contents_all(false, false, true);
            }
            else
            {
                if (kind == "filterrow" || kind == "deletemultirows" || kind == "filter")
                    band._matrix._init();

                band._matrix._adjustRowsDisplay();
                band._matrix._adjustColsDisplay();
            }

            lastPosition = this._last_scroll_top;

            if (lastPosition != _vpos)
                band._update_rows = band._matrix._adjustScrollRows(_vpos);

            band._on_refresh_rows();

            if (this._is_over_scroll > 0)
                this._vscrollmng.setPos(this._vscrollmng.pos - 1);
        }

        var afterrowcnt = this._getDisplayRowCount();

        if (this._isFillAreatype() || kind == "load")
            this._refreshBody();

        this._updateNodata(beforerowcnt, afterrowcnt);

        if (this._isUseBindExprStyle("head") || this._getUseBindExprProp("head"))
            this._refreshHead(true);
        if (this._isUseBindExprStyle("summ") || this._getUseBindExprProp("summ"))
            this._refreshSumm(true);
    };

    _pGrid.set_enableredraw = function (v)
    {
        if (v != null && this._p_enableredraw != v)
        {
            v = nexacro._toBoolean(v);
            this._p_enableredraw = v;

            if (v)
            {
                if (this._curFormat)
                    this._curFormat._updateFormatStr();

                this.on_apply_enableredraw();
            }
        }
        return v;
    };

    _pGrid.on_apply_enableredraw = function ()
    {
        this._apply_enableredraw = true;
        nexacro.Component.prototype.on_apply_enableredraw.call(this);
        this._apply_enableredraw = undefined;

        if (this._enable_redraw_history.recreate)
        {
            this.redraw();
            this._enable_redraw_history = {};
            return;
        }

        var ds = this._binddataset;
        if (ds && ds.oncolumnchanged && ds.oncolumnchanged._firestat)
        {
            this._recreate_contents_all(true, false);
            this._enable_redraw_history = {};
            return;
        }

        if (this._enable_redraw_history.recreate_body)
        {
            this._resetRowSizeList();
            this._resetColSizeList();

            if (this._bodyBand)
                this._bodyBand._recreate_contents();
        }
        else if (this._enable_redraw_history.refresh_body && !this._enable_redraw_history.refreshall)
        {
            this._refreshBody(true);
        }

        if (this._enable_redraw_history.recreate_head)
        {
            this._resetRowSizeList();
            this._resetColSizeList();

            if (this._headBand)
                this._headBand._recreate_contents();
        }
        else if (this._enable_redraw_history.refresh_head && !this._enable_redraw_history.refreshall)
        {
            this._refreshHead(true);
        }

        if (this._enable_redraw_history.recreate_summ)
        {
            this._resetRowSizeList();
            this._resetColSizeList();

            if (this._summBand)
                this._summBand._recreate_contents();
        }
        else if (this._enable_redraw_history.refresh_summ && !this._enable_redraw_history.refreshall)
        {
            this._refreshSumm(true);
        }

        if (this._enable_redraw_history.refreshall)
        {
            this._refreshAll(true);
        }

        if (this._enable_redraw_history.resize_band)
        {
            this._resizeBand();
        }

        var props;
        var props_len;
        var i;

        if (this._enable_redraw_history.updatecolsize)
        {
            props = this._enable_redraw_history.updatecolsize;
            props_len = props.length;
            var min = props[0];

            for (i = 1; i < props_len; i++)
            {
                min = Math.min(props[i], min);
            }
            this._updateColSize(min);
        }

        if (this._enable_redraw_history.updaterowsize)
        {
            props = this._enable_redraw_history.updaterowsize;
            props_len = props.length;

            for (i = 0; i < props_len; i++)
            {
                this._updateRowSize(props[i][0], props[i][1], (i < props_len - 1));
            }
        }

        if (this._enable_redraw_history.autofit)
        {
            var prop = this._enable_redraw_history.autofit;
            this._applyAutofittype(prop[0], prop[1]);
        }

        if (this._enable_redraw_history.scroll)
        {
            this._adjustGridScrollRows_callback_end();
            this._adjustGridScrollCols_callback_end();
        }

        this._enable_redraw_history = {};
    };

    _pGrid._isSelectedCell = function (cell, datarow)
    {
        var selects = this._selectinfo.getSelectCells(datarow);

        if (!this._isSelectRowType())
        {
            if (selects && selects[cell])
                return true;
        }
        else
        {
            if (selects)
                return true;
        }
        return false;
    };

    _pGrid.isSelectedCell = function (nCell, strBand, nRowIdx, nPivotIdx)
    {
        if (arguments.length == 0)
        {
            return false;
        }
        else if (arguments.length == 1)
        {
            strBand = "body";
            nRowIdx = 0;
            //            nPivotIdx = 0;
        }
        else if (arguments.length == 2)
        {
            if (strBand)
                strBand = strBand.toLowerCase();

            if (strBand == "body")
                nRowIdx = 0;
            else if ((strBand == "summ" || strBand == "summary"))
                nRowIdx = -2;
            else
                nRowIdx = -1;

            //           nPivotIdx = 0;
        }
        else if (arguments.length == 3)
        {
            if (strBand)
                strBand = strBand.toLowerCase();
            if ((strBand == "summ" || strBand == "summary"))
                nRowIdx = -2;
            else if (strBand == "head")
                nRowIdx = -1;

            //            nPivotIdx = 0;
        }

        return this._isSelectedCell(nCell, nRowIdx);
    };

    _pGrid.getCheckedRows = function (col, subrow)
    {
        var retn = [];
        var dataset = this._binddataset;

        if (!subrow)
            subrow = 0;

        for (var row = 0; row < dataset.rowcount; row++)
        {
            if (this._getCheck(col, row, subrow))
                retn.push(row);
        }

        return retn;
    };

    _pGrid.getSelectedRows = function ()
    {
        var selects = [].concat(this._selectinfo.rows);
        var retn = [];

        for (var i = 0, n = selects.length; i < n; i++)
            retn[i] = this._getTreeRowPosition(selects[i]);

        return retn;
    };

    _pGrid.getSelectedDatasetRows = function ()
    {
        var retn = [].concat(this._selectinfo.rows);

        for (var i = 0; i < retn.length; i++)
        {
            if (retn[i] < 0)
            {
                retn.splice(i, 1);
                i--;
            }
        }

        if (retn.length == 0)
            retn = -9;

        return retn;
    };

    _pGrid.clearSelect = function ()
    {
        this._selectinfo.area = [];
        this._resetSelect(-1, -1, -1, -1, -9);
        return true;
    };

    _pGrid.selectRow = function (nRow, bSelect)
    {
        if (!this._isSelectRowType())
            return false;

        if (bSelect == undefined)
            bSelect = true;

        nRow = this._getDataRow(nRow);
        return this._selectRow(nRow, bSelect);
    };

    _pGrid.selectCell = function (nRow, nCellidx, bSelect)
    {
        if (this._p_selecttype != "multicell" && this._p_selecttype != "cell")
            return false;

        if (bSelect == undefined)
            bSelect = true;

        return this._selectRow(nRow, bSelect, false, nCellidx);
    };

    _pGrid.selectMultiRow = function (nStartRowIdx, nEndRowIdx)
    {
        if (this._p_selecttype != "multirow")
            return false;

        nStartRowIdx = parseInt(nStartRowIdx);
        nEndRowIdx = parseInt(nEndRowIdx);

        var srow = this._getDataRow(nStartRowIdx);
        var erow = this._getDataRow(nEndRowIdx);

        return this._selectRow(srow, true, undefined, undefined, undefined, erow);
    };

    _pGrid.selectArea = function (nStartRowIdx, nStartCellIdx, nEndRowIdx, nEndCellIdx)
    {
        if (!this._isAreaSelect())
        {
            return false;
        }

        var i, j, n, m;
        var ret, tmp, trigger;
        var strBand, objCell, nCellIdx, nColIdx, nSubRowIdx;

        var beforeCellIdx = this._selectinfo.curcell;
        var beforeColIdx = this._selectinfo.curcol;
        var beforeRowIdx = this._selectinfo.curdsrow;
        var beforeSubRowIdx = this._selectinfo.cursubrow;
        var beforePvtIdx = this._selectinfo.curpvt;

        var format = this._curFormat;

        var getCell = function (cells, idx)
        {
            for (j = 0, m = cells.length; j < m; j++)
            {
                if (cells[j]._cellidx == idx)
                {
                    ret = cells[j];
                    break;
                }
            }
            return ret;
        };

        if (nStartRowIdx > nEndRowIdx)
        {
            tmp = nStartRowIdx;
            nStartRowIdx = nEndRowIdx;
            nEndRowIdx = tmp;
        }

        if (nStartCellIdx > nEndCellIdx)
        {
            tmp = nStartCellIdx;
            nStartCellIdx = nEndCellIdx;
            nEndCellIdx = tmp;
        }

        var arrRowIdx = [nStartRowIdx, nEndRowIdx];
        var arrCellIdx = [nStartCellIdx, nEndCellIdx];
        for (i = 0, n = arrRowIdx.length; i < n; i++)
        {
            switch (arrRowIdx[i])
            {
                case -1:
                    strBand = "head";
                    objCell = getCell(format._headcells, arrCellIdx[i]);
                    break;
                case -2:
                    strBand = "summ";
                    objCell = getCell(format._summcells, arrCellIdx[i]);
                    break;
                default:
                    strBand = "body";
                    objCell = getCell(format._bodycells, arrCellIdx[i]);
                    break;
            }

            if (objCell)
            {
                nCellIdx = objCell._cellidx;
                nColIdx = objCell._col;
                nSubRowIdx = objCell._row;

                this._setSelectedInfo(nCellIdx, nColIdx, arrRowIdx[i], nSubRowIdx, null);

                if (i == 0)
                {
                    trigger = "func_area1";
                    if (this._isMultiSelect())
                    {
                        this._multiselect = "ctrl";
                    }
                    else
                    {
                        this._clrMultiSelect();
                        this._multiselect = "none";
                    }

                }
                else if (i == 1)
                {
                    trigger = "func_area2";
                    this._multiselect = "shift";
                }

                ret = this._ChangeSelect(nCellIdx, nColIdx, arrRowIdx[i], nSubRowIdx, this._selectinfo.curpvt, false, beforeCellIdx, beforeColIdx, beforeRowIdx, beforeSubRowIdx, beforePvtIdx, strBand, trigger);
            }
        }

        return ret;
    };

    _pGrid._selectRow = function (row, bSelect, noDraw, cell, bDataset, endrow)
    {
        var beforeCell = this._selectinfo.curcell;
        var beforeCol = this._selectinfo.curcol;
        var beforeRow = this._selectinfo.curdsrow;
        var beforeSubrow = this._selectinfo.cursubrow;
        var beforePvt = this._selectinfo.curpvt;
        var band = "body";

        if (row == -1)
            band = "head";
        else if (row == -2)
            band = "summ";

        this._setSelectedInfo(null, null, row, 0, null);

        if (band != "body" && cell == undefined)
            cell = 0;

        if (cell != undefined) 
        {
            var cells;
            if (band == "head")
                cells = this._curFormat._headcells;
            else if (band == "summ")
                cells = this._curFormat._summcells;
            else
                cells = this._curFormat._bodycells;

            if (!cells || !cells.length)
                return false;

            var col = cells[cell]._col;
            var subrow = cells[cell]._row;

            this._setSelectedInfo(cell, col, null, subrow, null);
        }

        var retn = false;

        if (!bDataset)
            bDataset = false;

        var afterCell = (cell != undefined) ? cell : ((this._selectinfo.curcell < 0) ? 0 : this._selectinfo.curcell);
        var afterCol = (this._selectinfo.curcol < 0) ? 0 : this._selectinfo.curcol;
        var afterRow = row;
        var afterSubrow = (this._selectinfo.cursubrow < 0) ? 0 : this._selectinfo.cursubrow;
        var afterPvt = this._selectinfo.curpvt;
        var curselect = this.isSelectedCell((cell == undefined ? 0 : cell), band, row);
        var b_multi = false;
        var func_name = "func_selectrow";

        if (endrow != undefined && Math.abs(endrow - row) > 0)
        {
            b_multi = true;
            func_name = "func_selectmultirow";
        }

        if (bSelect != curselect || b_multi)
        {
            if (this._isMultiSelect())
            {
                this._multiselect = "ctrl";
                retn = this._ChangeSelect(afterCell, afterCol, afterRow, afterSubrow, afterPvt, bDataset, beforeCell, beforeCol, beforeRow, beforeSubrow, beforePvt, band, func_name);

                if (b_multi)
                {
                    this._multiselect = "shift";
                    retn = this._ChangeSelect(afterCell, afterCol, endrow, afterSubrow, afterPvt, bDataset, beforeCell, beforeCol, afterRow, beforeSubrow, beforePvt, band, func_name);
                }
            }
            else
            {
                this._clrMultiSelect();
                retn = true;

                if (bSelect)
                    retn = this._ChangeSelect(afterCell, afterCol, afterRow, afterSubrow, afterPvt, false, beforeCell, beforeCol, beforeRow, beforeSubrow, beforePvt, band, "func_selectrow");
            }
            this._moveCellAfterFocus();
        }
        else
        {
            this._setSelectedInfo(null, null, beforeRow, 0, null);

            if (cell != undefined)
                this._setSelectedInfo(beforeCell, null, null, null, null);
        }

        if (!noDraw)
        {
            this._refreshBody();

            if (band == "head")
                this._refreshHead();
            else if (band == "summ")
                this._refreshSumm();
        }

        return retn;
    };

    _pGrid._on_accessibility_killfocus = nexacro._emptyFn;

    _pGrid._on_killfocus = function (new_focus, new_ref_focus)
    {
        if (!this._is_alive)
            return;
        if (this._firstEditableCell)
            this._firstEditableCell = null;
        this._focused = undefined;
        this._firstEditableCell = null;
        this._destroyCellSelectionControl();

        if (this._hide_applydata)
        {
            nexacro._OnceCallbackTimer.callonce(this, function ()
            {
                if (this._binddataset && this._binddataset.cancolumnchange && this._binddataset.cancolumnchange._firestat)
                    this._hideEditor(true, true);
                else
                    this._hideEditor(false, true);
            });
        }
        else
        {
            if (this._binddataset && this._binddataset.cancolumnchange && this._binddataset.cancolumnchange._firestat)
                this._hideEditor(true, true);
            else
                this._hideEditor(false, true);
        }

        this._focusSelectorPoint(false);
        this._on_accessibility_killfocus();

        this._focused_row = undefined;
        this._focused_cell = undefined;
        this._is_async_recreate = false; //killfocus 될때 async_recreate 초기화        
    };

    _pGrid._focusSelectorPoint = function (v)
    {
        if (this._isAreaSelect())
        {
            if (this._select_ctrl)
            {
                this._select_ctrl._trackbar[0].set_visible(v);
                this._select_ctrl._trackbar[1].set_visible(v);
                this._select_ctrl._trackbar[2].set_visible(v);
                this._select_ctrl._trackbar[3].set_visible(v);
            }
        }
    };

    _pGrid._on_focus = function (self_flag, evt_name, lose_focus, refer_lose_focus, new_focus, refer_new_focus)
    {
        if (this._showEditorFocus)
            return;

        this._focused = undefined;
        this._applyCellSelection();

        var retn = false;
        //var focusdir = this._focus_direction;

        //if (self_flag == false)
        //    this._focus_direction = -1;

        // tabkey 사용시 focus 방향을 evt_name으로 구분
        //if (focusdir >= 0)

        if (!self_flag)
            this._focusSelectorPoint(true);

        retn = nexacro.Component.prototype._on_focus.call(this, self_flag, evt_name, lose_focus, refer_lose_focus, new_focus, refer_new_focus);

        var cellobj;
        if (evt_name == "tabkey" || evt_name == "shifttabkey")
        {
            //if (this._bodyBand && (self_flag == false || this._env._p_enableaccessibility))
            if (this._bodyBand && (self_flag == false || this._acceptstab == false))
            {
                var rows = this._bodyBand._get_rows();

                if (rows.length > 0)
                {
                    if (rows[0]._cells && rows[0]._cells.length > 0)
                    {
                        var editcell = null;
                        this._showEditorFocus = true;
                        this._currentBand = "body"; // only accessibility

                        //if (focusdir == 1)    // shift + tab
                        if (evt_name == "shifttabkey")
                        {
                            editcell = this._getLastEditableCell();
                            if (editcell.row !== null)
                            {
                                if (this._vscrollmng)
                                    this._vscrollmng.setPos(this._vscrollmng.max);

                                retn = this._moveToPosCell(editcell.row, editcell.cell);
                            }
                        }
                        else
                        {
                            editcell = this._getFirstEditableCell();
                            if (editcell.row !== null)
                            {
                                if (this._vscrollmng)
                                    this._vscrollmng.setPos(0);

                                retn = this._moveToPosCell(editcell.row, editcell.cell);
                            }
                        }

                        // 탭키 동작시 중복 동작 수정
                        if (this._env._p_enableaccessibility && editcell.row !== null)
                        {
                            if (evt_name == "tabkey")
                            {
                                this._is_first_focus = true;
                                this._is_first_bodycell = true;
                            }

                            cellobj = this._getAccessibilityCurrentCell(editcell.row, editcell.cell);
                            if (cellobj)
                            {
                                cellobj._on_focus(true, evt_name);
                            }
                        }

                        this._showEditorFocus = false;
                    }

                    this._acceptstab = true;
                }
            }

        } //if (evt_name == "tabkey" || evt_name == "shifttabkey")
        else
        {
            if (this._env._p_enableaccessibility)
            {
                this._accept_arrow = true;
                this._acceptstab = true;
                retn = false;

                if ((this._env._a11ytype > 3) && evt_name === undefined)
                {
                    //IOS, Android 웹접근성 사용시 Grid,Band는 가상초점을 받지 않으므로 가상초점을 첫번째 cell로 이동.
                    this._moveToPosAccessibilityCell(this._p_currentrow, this._p_currentcell);
                    //this._currentBand = "grid";
                    //this._moveToAccessibilityCell("next");
                }
            }
            else
            {
                if (self_flag == false)
                {
                    if (evt_name == "lbuttondown" && refer_new_focus && refer_new_focus._type_name == "GridCellControl")
                    {
                        //
                    }
                    else if (this._p_autoenter == "select" && (!this._lbuttondown_proc && !this._tryShowEditorCell))
                    {
                        if (nexacro._Browser == "Opera")
                        {
                            this._onceTime_focus = true;
                        }

                        cellobj = this._findCellObj(refer_new_focus);
                        if (cellobj && cellobj._type_name != "GridCellControl")
                            cellobj = null;

                        this._showEditorFocus = true;
                        this._showEditor(cellobj);
                        this._showEditorFocus = false;
                        this._onceTime_focus = false;
                    }
                }
                this._acceptstab = true;
            }
        }

        if (this._env._p_enableaccessibility)
        {
            this._is_first_focus = false;
        }
        return retn;
    };

    _pGrid.on_fire_oninput = function ()
    {
        var cell = this._selectinfo.curcell;
        var col = this._selectinfo.curcol;
        var pivotindex = this._selectinfo.curpvt;
        var row = this._selectinfo.curdsrow;
        var subrow = this._selectinfo.cursubrow;

        if (this.oninput && this.oninput._has_handlers)
        {
            var evt = new nexacro.GridInputEventInfo(this, cell, col, row, subrow, pivotindex, "oninput");
            return this.oninput._fireEvent(this, evt);
        }
        return true;
    };

    _pGrid.on_fire_cantreestatuschange = function (row, realrow, reason)
    {
        var cell = this._selectinfo.curcell;

        if (this.cantreestatuschange && this.cantreestatuschange._has_handlers)
        {
            var evt = new nexacro.GridTreeStatusEventInfo(this, "cantreestatuschange", cell, realrow, row, reason);
            return this.cantreestatuschange._fireEvent(this, evt);
        }
        return true;
    };

    _pGrid.on_fire_ontreestatuschanged = function (row, realrow, reason)
    {
        var cell = this._selectinfo.curcell;

        if (this.ontreestatuschanged && this.ontreestatuschanged._has_handlers)
        {
            var evt = new nexacro.GridTreeStatusEventInfo(this, "ontreestatuschanged", cell, realrow, row, reason);
            return this.ontreestatuschanged._fireEvent(this, evt);
        }
        return true;
    };

    _pGrid.on_fire_oncloseup = function (obj, pretext, posttext, prevalue, postvalue, cell, col, pivotindex, row, subrow)
    {
        if (this.oncloseup && this.oncloseup._has_handlers)
        {
            var value = this._evtvalue(obj, postvalue);
            var evt = new nexacro.GridEditEventInfo(this, "oncloseup", cell, col, pivotindex, row, subrow, value);
            this._is_up_act = true;
            var ret = this.oncloseup._fireEvent(this, evt);
            this._is_up_act = false;
            return ret;
        }
        return true;
    };

    _pGrid.on_fire_ondropdown = function (obj)
    {
        if (this.ondropdown && this.ondropdown._has_handlers)
        {
            var cell = this._selectinfo.curcell;
            var col = this._selectinfo.curcol;
            var pivotindex = this._selectinfo.curpvt;
            var row = this._selectinfo.curdsrow;
            var subrow = this._selectinfo.cursubrow;
            var value = this._evtvalue(obj);

            var evt = new nexacro.GridEditEventInfo(this, "ondropdown", cell, col, pivotindex, row, subrow, value);
            return this.ondropdown._fireCheckEvent(this, evt);
        }
        return true;
    };

    _pGrid.on_fire_onenterdown = function (keyCode, altKey, ctrlKey, shiftKey, obj, refer_comp, postvalue, metaKey)
    {
        if (this._p_readonly)
            return;

        if (this.onenterdown && this.onenterdown._has_handlers)
        {
            var cell = this._selectinfo.curcell;
            var col = this._selectinfo.curcol;
            var pivotindex = this._selectinfo.curpvt;
            var row = this._selectinfo.curdsrow;
            var subrow = this._selectinfo.cursubrow;
            var value = this._evtvalue(refer_comp, postvalue, true);

            var evt = new nexacro.GridEditEventInfo(this, "onenterdown", cell, col, pivotindex, row, subrow, value);
            return this.onenterdown._fireEvent(this, evt);
        }
        return true;
    };

    _pGrid.on_fire_onexpanddown = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        if (this._p_readonly)
            return;

        var cellobj = from_comp;
        cellobj = this._findCellObj(cellobj);

        var subcellobj;
        if (cellobj)
        {
            if (cellobj.parentcell)
            {
                subcellobj = cellobj;
                cellobj = cellobj.parentcell;
            }
        }

        var posobj = this._recalcXY(cellobj, canvasX, canvasY, false, from_refer_comp);
        canvasX = posobj.canvasX;
        canvasY = posobj.canvasY;
        clientX = posobj.clientX;
        clientY = posobj.clientY;
        if (this.onexpanddown && this.onexpanddown._has_handlers)
        {
            var evtinfo = this._makeEventInfo(cellobj, subcellobj, from_refer_comp);
            //from_comp = this._getRootComponent(from_comp);

            var obj = this._getRootComponent(from_refer_comp);
            var cell = evtinfo.cell;
            var col = evtinfo.col;
            var mergecell = evtinfo.mergecell;
            var mergecol = evtinfo.mergecol;
            var mergerow = evtinfo.mergerow;
            var pivotindex = evtinfo.pivotindex;
            var row = evtinfo.row;
            var subrow = evtinfo.subrow;

            var evt = new nexacro.GridMouseEventInfo(obj, "onexpanddown", cell, col, mergecell, mergecol, mergerow, pivotindex, row, subrow,
                button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);
            return this.onexpanddown._fireEvent(this, evt);
        }
        return false;
    };

    _pGrid.on_fire_onexpandup = function (button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key)
    {
        if (this._p_readonly)
            return;

        var cellobj = from_comp;
        cellobj = this._findCellObj(cellobj);

        var subcellobj;
        if (cellobj)
        {
            if (cellobj.parentcell)
            {
                subcellobj = cellobj;
                cellobj = cellobj.parentcell;
            }
        }

        var posobj = this._recalcXY(cellobj, canvasX, canvasY, false, from_refer_comp);
        canvasX = posobj.canvasX;
        canvasY = posobj.canvasY;
        clientX = posobj.clientX;
        clientY = posobj.clientY;

        if (this.onexpandup && this.onexpandup._has_handlers)
        {
            var evtinfo = this._makeEventInfo(cellobj, subcellobj, from_refer_comp);
            //from_comp = this._getRootComponent(from_comp);

            var obj = this._getRootComponent(from_comp);
            var cell = evtinfo.cell;
            var col = evtinfo.col;
            var mergecell = evtinfo.mergecell;
            var mergecol = evtinfo.mergecol;
            var mergerow = evtinfo.mergerow;
            var pivotindex = evtinfo.pivotindex;
            var row = evtinfo.row;
            var subrow = evtinfo.subrow;
            var evt = new nexacro.GridMouseEventInfo(obj, "onexpandup", cell, col, mergecell, mergecol, mergerow, pivotindex, row, subrow,
                button, alt_key, ctrl_key, shift_key, screenX, screenY, canvasX, canvasY, clientX, clientY, from_comp, from_refer_comp, meta_key);

            this._is_up_act = true;
            var retn = this.onexpandup._fireEvent(this, evt);
            this._is_up_act = false;

            return retn;
        }
        return false;
    };

    _pGrid.on_fire_oncolresized = function (args)
    {
        if (this.oncolresized && this.oncolresized._has_handlers)
        {
            var formatindex = args[0];
            var index = args[1];
            var newvalue = args[2];
            var oldvalue = args[3];
            var subindex = args[4];
            var evt = new nexacro.GridSizeChangedEventInfo(this, "oncolresized", formatindex, index, newvalue, oldvalue, 1, subindex);
            return this.oncolresized._fireEvent(this, evt);
        }
        return false;
    };

    _pGrid.on_fire_onrowresized = function (args)
    {
        if (this.onrowresized && this.onrowresized._has_handlers)
        {
            var formatindex = args[0];
            var index = args[1];
            var newvalue = args[2];
            var oldvalue = args[3];
            var subindex = args[4];
            var evt = new nexacro.GridSizeChangedEventInfo(this, "onrowresized", formatindex, index, newvalue, oldvalue, 2, subindex);
            return this.onrowresized._fireEvent(this, evt);
        }
        return false;
    };

    _pGrid.on_fire_onimeaction = function (obj, key_code, alt_key, ctrl_key, shift_key, from_comp, from_refer_comp)
    {
        if (!this._is_alive) return;

        if (!this._p_enable) return true;

        if (this.oncellimeaction && this.oncellimeaction._has_handlers)
        {
            var cell = this._selectinfo.curcell;
            var col = this._selectinfo.curcol;
            var pivotindex = this._selectinfo.curpvt;
            var row = this._selectinfo.curdsrow;
            var subrow = this._selectinfo.cursubrow;

            var evt = new nexacro.GridKeyEventInfo(this, "oncellimeaction", cell, col, pivotindex, row, subrow, alt_key, ctrl_key, shift_key, key_code);
            return this.oncellimeaction._fireEvent(this, evt);
        }
        return false;
    };
    /*
    _pGrid.on_fire_oncellcustomcontrolevent = function (obj, e)
    {
        if (this.oncellcustomcontrolevent && this.oncellcustomcontrolevent._has_handlers)
        {
            var cell = this._selectinfo.curcell;
            var col = this._selectinfo.curcol;
            var pivotindex = this._selectinfo.curpvt;
            var row = this._selectinfo.curdsrow;
            var subrow = this._selectinfo.cursubrow;

            var evt = new nexacro.GridCellCustomControlEventInfo(this, "oncellcustomcontrolevent", cell, col, pivotindex, row, subrow, e);
            return this.oncellcustomcontrolevent._fireEvent(this, evt);
        }
    };
    */
    //==============================================================================
    //nexacro.Grid : Logical Part
    //==============================================================================
    _pGrid._is_recreating = false;
    _pGrid._recreate = function ()
    {
        if (!this._p_enableredraw)
        {
            this._resetRowSizeList();
            this._resetColSizeList();
            this._resetScrollMax();
            this._enable_redraw_history.recreate = true;
            return true;
        }

        if (!this.getElement())
            return false;

        var kind_act = { "act": "" };
        var down_act = this._isDownActionKeyMouse(kind_act) || this._is_down_act;
        if (down_act && !this._userRowposChange && !this._is_after_recreate)
        {
            this._after_recreate = true;

            this._startAfterRecreateTimer(kind_act.act);
            return;
        }

        this._is_recreating = true;
        var toprowpos = this._toprowpos[0];
        var vpos = (this._vscrollmng) ? this._vscrollmng._pos : 0;
        var hpos = (this._hscrollmng) ? this._hscrollmng._pos : 0;
        if (this._firstEditableCell)
            this._firstEditableCell = null;
        this._firstEditableCell = null;
        this._destroyBands();
        this._createBandsAndAreas();
        this._autosizeMergeCell();
        this._refreshBody();
        this._onResetScrollBar();
        this._recreate_contents_proc = [];

        if (this._vscrollmng)
        {
            this._vscrollmng.setPixelPos(0);

            if (this._scrollpixel == "all")
                this._vscrollmng.setPixelPos(vpos);
            else
                this._vscrollmng.setRowPos(toprowpos);
        }

        if (this._hscrollmng)
        {
            this._hscrollmng.setPos(0);
            this._hscrollmng.setPos(hpos);
        }

        this._destroyHighlightRow();
        this._createHighlightRow();

        this._is_recreating = false;

        if (this._p_autoenter == "select")
            this._showEditor();

        return true;
    };

    _pGrid.on_change_groupbarHeight = function ()
    {
        this._calcGroupBarHeight();
        this._resizeBand();
    };

    _pGrid.set_createcellasync = function (v)
    {
        if (v != null)
        {
            v = nexacro._toBoolean(v);
            this._p_createcellasync = v;
        }
    };

    _pGrid.set_cellcombobuttonsize = function (v)
    {
        if (v != this._p_cellcombobuttonsize)
        {
            this._p_cellcombobuttonsize = v;
            this.on_apply_cellcombobuttonsize();
        }
    };

    _pGrid.on_apply_cellcombobuttonsize = function ()
    {
        this._refreshAll();
    };

    _pGrid.set_cellmulticombobuttonsize = function (v)
    {
        if (v != this._p_cellmulticombobuttonsize)
        {
            this._p_cellmulticombobuttonsize = v;
            this.on_apply_cellmulticombobuttonsize();
        }
    };

    _pGrid.on_apply_cellmulticombobuttonsize = function ()
    {
        this._refreshAll();
    };

    _pGrid.set_cellcalendarbuttonsize = function (v)
    {
        if (v != this._p_cellcalendarbuttonsize)
        {
            this._p_cellcalendarbuttonsize = v;
            this.on_apply_cellcalendarbuttonsize();
        }
    };

    _pGrid.on_apply_cellcalendarbuttonsize = function ()
    {
        this._refreshAll();
    };

    _pGrid.set_cellcomboscrollbarsize = function (v)
    {
        if (v != this._p_cellcomboscrollbarsize)
        {
            this._p_cellcomboscrollbarsize = v;
            this.on_apply_cellcomboscrollbarsize();
        }
    };

    _pGrid.on_apply_cellcomboscrollbarsize = function ()
    {
        this._refreshAll();
    };

    _pGrid.set_cellmulticomboscrollbarsize = function (v)
    {
        if (v != this.multicellcomboscrollbarsize)
        {
            this._p_cellmulticomboscrollbarsize = v;
            this.on_apply_cellmulticomboscrollbarsize();
        }
    };

    _pGrid.on_apply_cellmulticomboscrollbarsize = function ()
    {
        this._refreshAll();
    };

    _pGrid.set_celltextareascrollbarsize = function (v)
    {
        if (v != this._p_celltextareascrollbarsize)
        {
            this._p_celltextareascrollbarsize = v;
            this.on_apply_celltextareascrollbarsize();
        }
    };

    _pGrid.on_apply_celltextareascrollbarsize = function ()
    {
        this._refreshAll();
    };

    _pGrid.set_cellcalendarpopuptype = function (v)
    {
        if (v != this._p_cellcalendarpopuptype)
        {
            this._p_cellcalendarpopuptype = v;
            this.on_apply_cellcalendarpopuptype();
        }
    };

    _pGrid.on_apply_cellcalendarpopuptype = function ()
    {
        this._refreshAll();
    };

    _pGrid.set_cellcombopopuptype = function (v)
    {
        if (v != this._p_cellcombopopuptype)
        {
            this._p_cellcombopopuptype = v;
            this.on_apply_cellcombopopuptype();
        }
    };

    _pGrid.on_apply_cellcombopopuptype = function ()
    {
        this._refreshAll();
    };

    _pGrid.set_cellmulticombopopuptype = function (v)
    {
        if (v != this._p_cellmulticombopopuptype)
        {
            this._p_cellmulticombopopuptype = v;
            this.on_apply_cellmulticombopopuptype();
        }
    };

    _pGrid.on_apply_cellmulticombopopuptype = function ()
    {
        this._refreshAll();
    };

    _pGrid.set_cellcalendarpopupsize = function (v)
    {
        if (v != this._p_cellcalendarpopupsize)
        {
            this._p_cellcalendarpopupsize = v;
            this.on_apply_cellcalendarpopupsize();
        }
    };

    _pGrid.on_apply_cellcalendarpopupsize = function ()
    {
        this._refreshAll();
    };

    _pGrid.set_cellcombopopupsize = function (v)
    {
        if (v != this._p_cellcombopopupsize)
        {
            this._p_cellcombopopupsize = v;
            this.on_apply_cellcombopopupsize();
        }
    };

    _pGrid.on_apply_cellcombopopupsize = function ()
    {
        this._refreshAll();
    };

    _pGrid.set_cellmulticombopopupsize = function (v)
    {
        if (v != this._p_cellmulticombopopupsize)
        {
            this._p_cellmulticombopopupsize = v;
            this.on_apply_cellmulticombopopupsize();
        }
    };

    _pGrid.on_apply_cellmulticombopopupsize = function ()
    {
        this._refreshAll();
    };

    _pGrid.set_cellcheckboxsize = function (v)
    {
        if (v != this._p_cellcheckboxsize)
        {
            this._p_cellcheckboxsize = v;
            this.on_apply_cellcheckboxsize();
        }
    };

    _pGrid.on_apply_cellcheckboxsize = function ()
    {
        this._refreshAll();
    };

    _pGrid.set_cellradioitemsize = function (v)
    {
        if (v != this._p_cellradioitemsize)
        {
            this._p_cellradioitemsize = v;
            this.on_apply_cellradioitemsize();
        }
    };

    _pGrid.on_apply_cellradioitemsize = function ()
    {
        this._refreshAll();
    };

    _pGrid.set_cellexprupdatecondition = function (v)
    {
        switch (v)
        {
            case "all":
            case "celltext":
            case "none":
                if (v != this._p_cellexprupdatecondition)
                {
                    this._p_cellexprupdatecondition = v;
                    this.on_apply_cellexprupdatecondition();
                }
                break;
        }
    };

    _pGrid.on_apply_cellexprupdatecondition = function ()
    {
        this._clearBindTypeFlag();
        this._refreshAll();
    };

    _pGrid._isDownActionKeyMouse = function (kind)
    {
        if (this._is_up_act)
            return false;

        var window = this._getWindow();

        if (window && (window._cur_ldown_elem || window._keydown_element || window._cur_touch_elem))
        {
            var elem = window._cur_ldown_elem || window._keydown_element || window._cur_touch_elem,
                comp = window.findComponent(elem, 0, 0)[0],
                isgrid = false;

            if (kind)
            {
                if (window._cur_ldown_elem || window._cur_touch_elem)
                    kind["act"] = "L";
                else if (window._keydown_element)
                    kind["act"] = "K";
            }

            while (comp)
            {
                if (comp instanceof nexacro.ScrollBarControl)
                    break;

                if (comp instanceof nexacro.Grid && comp == this && comp.id == this.id)
                {
                    isgrid = true;
                    break;
                }
                comp = comp.parent;
            }
            return isgrid;
        }
        return false;
    };

    _pGrid._startAfterRecreateTimer = function (kind)
    {
        var pthis = this;

        if (this._afterrecreatetask)
        {
            this._afterrecreatetask.destroy();
            this._afterrecreatetask = null;
        }

        var delay = Math.abs(this._buttonuptime - this._buttondowntime);
        delay = delay > 0 ? delay : 50; // 최소 지연 시간을 50ms로 설정

        this._afterrecreatetask = new nexacro._CallbackTimer(this, function (id) { return pthis._callbackAfterRecreateTimer(kind); }, delay);
        this._afterrecreatetask.start();
    };

    _pGrid._callbackAfterRecreateTimer = function (kind)
    {
        if (kind == "K")
        {
            this._on_last_keyup();
        }
        else if (kind == "L")
        {
            this._on_last_lbuttonup();
        }

        if (this._afterrecreatetask)
        {
            this._afterrecreatetask.destroy();
            this._afterrecreatetask = null;
        }
    };

    _pGrid._recreate_contents_all = function (reset_size, init_scroll, only_body, no_hide_edit, chk_srow)
    {
        if (!this._p_enableredraw)
        {
            this._resetRowSizeList();
            this._resetColSizeList();
            this._resetScrollMax();
            this._enable_redraw_history.recreate = true;
            return;
        }

        if (this._firstEditableCell)
            this._firstEditableCell = null;

        var kind_act = { "act": "" };
        var down_act = this._isDownActionKeyMouse(kind_act) || this._is_down_act;
        if (down_act && !this._userRowposChange && !this._is_after_recreate)
        {
            var args = [reset_size, init_scroll, only_body, no_hide_edit];
            if (this._after_recreate_contents_all)
            {
                args[0] = args[0] || this._after_recreate_contents_all[0];
                args[1] = args[1] || this._after_recreate_contents_all[1];
                args[2] = args[2] || this._after_recreate_contents_all[2];
                args[3] = args[3] && this._after_recreate_contents_all[3];
                args[2] = args[4] || this._after_recreate_contents_all[4];
            }
            this._after_recreate_contents_all = args;

            if (reset_size)
            {
                this._resetRowSizeList(chk_srow);
                this._resetColSizeList(chk_srow);
            }

            this._startAfterRecreateTimer(kind_act.act);
            return;
        }

        var beforerowcnt = this._getDisplayRowCount();

        if (reset_size)
        {
            this._resetRowSizeList(chk_srow);
            this._resetColSizeList(chk_srow);
            this._is_contents_recreating = true;
            this._resizeBand();
            this._is_contents_recreating = false;

            if (this._bodyBand)
            {
                this._bodyBand._recreate_contents(init_scroll, false, no_hide_edit);
                this._bodyBand._matrix._adjustColsDisplay(true);
            }

            if (!only_body)
            {
                if (this._headBand)
                {
                    this._headBand._recreate_contents();
                    this._headBand._matrix._adjustColsDisplay(true);
                }

                if (this._summBand)
                {
                    this._summBand._recreate_contents();
                    this._summBand._matrix._adjustColsDisplay(true);
                }
            }
            else
            {
                if (this._isUseBindExprStyle("head") || this._getUseBindExprProp("head"))
                    this._refreshHead(true);
                if (this._isUseBindExprStyle("summ") || this._getUseBindExprProp("summ"))
                    this._refreshSumm(true);
            }
            this._autosizeMergeCell();
        }
        else
        {
            if (this._bodyBand)
                this._bodyBand._recreate_contents(init_scroll, false, no_hide_edit);

            if (!only_body)
            {
                if (this._headBand)
                    this._headBand._recreate_contents();

                if (this._summBand)
                    this._summBand._recreate_contents();
            }
            else
            {
                if (this._isUseBindExprStyle("head") || this._getUseBindExprProp("head"))
                    this._refreshHead(true);
                if (this._isUseBindExprStyle("summ") || this._getUseBindExprProp("summ"))
                    this._refreshSumm(true);
            }
        }

        var afterrowcnt = this._getDisplayRowCount();

        this._updateNodata(beforerowcnt, afterrowcnt);

        this._updateSelector();
        this._adjustOverlayControls(true);
    };

    _pGrid._updateNodata = function (beforerowcnt, afterrowcnt)
    {
        if ((beforerowcnt == 0 && afterrowcnt > 0) ||
            (beforerowcnt > 0 && afterrowcnt == 0))
        {
            var band = this._bodyBand;

            if (band)   // nodata image,text 갱신
            {
                band._updateAll(true);
            }
            else
            {
                //this._stat_change();
            }
        }
    };

    _pGrid._getBodyRowsSize = function (s_datarow, e_datarow, s_subrow, e_subrow)
    {
        if (this._rowSizeList.length)
        {
            if (s_datarow >= 0 && e_datarow >= 0)
            {
                var rows = this._curFormat._bodyrows;
                var rows_len = rows.length;
                var size = 0;
                var i, j;

                for (i = s_datarow; i <= e_datarow; i++)
                {
                    if (s_subrow && i == s_datarow)
                    {
                        for (j = s_subrow; j < rows_len; j++)
                        {
                            size += this._rowSizeListSub[(i * rows_len) + j];
                        }
                    }
                    else if (e_subrow && i == e_datarow)
                    {
                        for (j = 0; j <= e_subrow; j++)
                        {
                            size += this._rowSizeListSub[(i * rows_len) + j];
                        }
                    }
                    else
                    {
                        size += this._rowSizeList[i];
                    }
                }
                return size;
            }
        }
        return 0;
    };

    _pGrid._getRowSize = function (rowidx)
    {
        var format = this._curFormat;

        if (rowidx == -1)
        {
            if (this._rowHeadList.length > 0)
                return this._rowHeadList[0];
            else
                return format.headHeight;
        }
        else if (rowidx == -2)
        {
            if (this._rowSummList.length > 0)
                return this._rowSummList[0];
            else
                return format.summHeight;
        }
        else
        {
            var datarow = this._getDataRow(rowidx);

            if (datarow >= 0)
            {
                if (this._rowSizeList.length > 0)
                    return this._rowSizeList[datarow];
                else
                    return format._body_height;
            }
        }
        return -1;
    };

    _pGrid._getHeadHeight = function ()
    {
        var format = this._curFormat;
        if (format == null || format._headband == null)
            return 0;

        var height = this._rowHeadList[0];

        if (height == undefined)
            height = format.headHeight;

        return height;
    };

    _pGrid._getSummHeight = function ()
    {
        var format = this._curFormat;
        if (format == null || format._summband == null)
            return 0;

        var height = this._rowSummList[0];

        if (height == undefined)
            height = format.summHeight;

        return height;
    };

    _pGrid._createBandsAndAreas = function (grid_create)
    {
        if (!this._p_enableredraw)
        {
            this._enable_redraw_history.recreate = true;
            return;
        }

        var format = this._curFormat;
        if (format == null)
            return;

        this._applyAutofittype(false);

        var cells = this._curFormat._bodycells;
        var cellcnt = cells ? cells.length : 0;
        var cellinfo;

        for (var j = 0; j < cellcnt; j++)
        {
            cellinfo = cells[j];
            if (cellinfo._p_suppress != 0)
                this._is_use_suppress = true;

            if (cellinfo.wordwrap != "none")
                this._is_body_wordwrap = true;

            if (this._is_use_suppress && this._is_body_wordwrap)
                break;
        }

        cells = this._curFormat._headcells;
        cellcnt = cells ? cells.length : 0;

        for (j = 0; j < cellcnt; j++)
        {
            cellinfo = cells[j];
            if (cellinfo.wordwrap != "none")
            {
                this._is_head_wordwrap = true;
                break;
            }
        }

        cells = this._curFormat._summcells;
        cellcnt = cells ? cells.length : 0;

        for (j = 0; j < cellcnt; j++)
        {
            cellinfo = cells[j];
            if (cellinfo.wordwrap != "none")
            {
                this._is_summ_wordwrap = true;
                break;
            }
        }

        var rect = this._getAvailableRect(this);
        var clientwidth = rect.width;
        var clientheight = rect.height;
        var control_elem = this.getElement();
        var top, bottom;
        var headHeight = format.headHeight;
        var summHeight = format.summHeight;

        if (this._p_summarytype == "top" || this._p_summarytype == "lefttop")
        {
            top = headHeight + summHeight;
            bottom = clientheight;
        }
        else
        {
            top = headHeight;
            bottom = clientheight - summHeight;
        }
        if (bottom < top)
            bottom = top;

        var bodyband, summband, headband, groupbar;

        if (format._bodyband)
        {
            this._bodyBand = bodyband = new nexacro._GridBandControl("body", 0, top, clientwidth, bottom - top, null, null, this, format._bodyband);
            this._p_body = format._bodyband;
        }

        if (summHeight > 0)
        {
            rect = this._getAvailableRect(this);
            clientwidth = rect.width;
            clientheight = rect.height;

            if (this._p_summarytype == "top" || this._p_summarytype == "lefttop")
            {
                top = headHeight;
                bottom = headHeight + summHeight;
            }
            else
            {
                bottom = clientheight;
                top = bottom - summHeight;
            }
            this._summBand = summband = new nexacro._GridBandControl("summary", 0, top, clientwidth, bottom - top, null, null, this, format._summband);
            this._p_summ = this._p_summary = format._summband;
        }
        else
        {
            this._summBand = null;
        }

        if (this._p_showgroupbar)
        {
            var curborder = this._border || this._getCSSStyleValue("border", this._status);
            var border_w = (curborder) ? (curborder.left._width + curborder.right._width) : 0;
            var gr_width = this._adjust_width - border_w;

            this._groupBar = groupbar = new nexacro._GridGroupControl("groupbar", 0, 0, gr_width, 0, parseInt(this._p_groupbarminheight), this);
            groupbar.set_edittype("multitag");
            groupbar.set_codecolumn("codecolumn");
            groupbar.set_datacolumn("datacolumn");
            groupbar.set_displaynulltext("Drag here to set row groups");
            groupbar._updateInnerDataset();
            groupbar._updateValue();

            this._callControlApplyProp("_groupBar");
            this._control_element._setAttachClientTop(this._groupbarheight);
        }
        else
        {
            this._groupBar = null;
            this._control_element._setAttachClientTop(0);
        }

        if (headHeight > 0)
        {
            top = 0;
            rect = this._getAvailableRect(this);
            clientwidth = rect.width;
            //            clientheight = rect.height;

            bottom = headHeight;
            this._headBand = headband = new nexacro._GridBandControl("head", 0, top, clientwidth, bottom - top, null, null, this, format._headband);
            this._headBand._is_scrollable = false;
            this._p_head = format._headband;
        }
        else
        {
            this._headBand = null;
        }


        this._resetRowSizeList();  // band 스타일 때문에 여기서 초기화
        this._resetColSizeList();

        this._is_createbandarea = true;
        if (headband)
            this._headBand.createComponent();

        if (groupbar)
            groupbar.createComponent();

        if (bodyband)
        {
            this._initChecked();
            this._bodyBand.createComponent();
            control_elem.setVertScrollElements(this._bodyBand._control_element);
            this.on_apply_fastvscrolltype();
            this.on_apply_scrolldisplaymode();
        }

        if (summband)
            this._summBand.createComponent();

        this._is_createbandarea = false;
        this._grid_creating = grid_create;
        this._resizeBand(false);
        this._grid_creating = false;
    };

    _pGrid._band_scroll_tops = null;
    _pGrid._setScrollMaxSize = function (scroll_width, scroll_height, band_scroll_tops)
    {
        if (band_scroll_tops)
            this._band_scroll_tops = band_scroll_tops;

        if (this._control_element)
        {
            this._control_element._setInnerElementScrollMaxTops(this._band_scroll_tops);

            if (scroll_height == undefined)
            {
                if (this._bodyBand)
                    scroll_height = this._bodyBand._scrollHeight;
                else
                    scroll_height = 0;
            }
            this._control_element.setElementScrollMaxSize(scroll_width, scroll_height);
            this._onResetScrollBar();
        }
    };

    _pGrid._resizing_band = 0;
    _pGrid._after_resizeband = false;
    _pGrid._resizeBand = function (no_autofit)
    {
        if (!this._band_resizing_no_autofit)
            this._band_resizing_no_autofit = [];

        if (this._band_resizing_no_autofit.length > 0)
            no_autofit = this._band_resizing_no_autofit[0];

        this._band_resizing_no_autofit.push(no_autofit);

        if (!this._grid_creating && !this._is_created)  // created가 false인 경우 생성 중인 상황에만 허용
        {
            this._after_resizeband = true;
            this._band_resizing_no_autofit.pop();
            return;
        }
        if (this._is_createbandarea)
        {
            this._band_resizing_no_autofit.pop();
            return;
        }
        this._after_resizeband = false;

        var clientleft = this._getClientLeft();
        var clienttop = this._getClientTop();
        var clientwidth = this._getClientWidth();
        var clientheight = this._getClientHeight();
        var headHeight = this._getHeadHeight();
        var summHeight = this._getSummHeight();
        var l, t, w, h;

        l = clientleft;
        w = clientwidth;

        this._resizing_band++;

        if (this._bodyBand)
        {
            if (this._p_summarytype == "top" || this._p_summarytype == "lefttop")
            {
                t = headHeight + summHeight;
                h = clientheight - t;
            }
            else
            {
                t = headHeight;
                h = clientheight - summHeight - t;
            }
            if (h < 0)
                h = 0;

            this._bodyBand._update_size_contents = true;
            this._bodyBand.move(l, t, w, h);
            this._bodyBand._update_size_contents = false;
        }

        clientwidth = this._getClientWidth();
        clientheight = this._getClientHeight();

        if (this._summBand)
        {
            if (this._p_summarytype == "top" || this._p_summarytype == "lefttop")
            {
                t = headHeight;
                h = headHeight + summHeight - t;
            }
            else
            {
                w = clientwidth;
                t = clientheight - summHeight;
                h = clientheight - t;
            }
            this._summBand._update_size_contents = true;
            this._summBand.move(l, t, w, h);
            this._summBand._update_size_contents = true;
        }

        clientwidth = this._getClientWidth();
        //        clientheight = this._getClientHeight();

        if (this._groupBar)
        {
            var curborder = this._border || this._getCSSStyleValue("border", this._status);
            var border_w = (curborder) ? (curborder.left._width + curborder.right._width) : 0;
            var gr_width = this._adjust_width - border_w;
            this._groupBar.move(0, 0, gr_width, this._groupbarheight);
            this._control_element._setAttachClientTop(this._groupbarheight);
        }

        if (this._headBand)
        {
            w = clientwidth;
            t = clienttop;
            h = headHeight;
            this._headBand._update_size_contents = true;
            this._headBand.move(l, t, w, h);
            this._headBand._update_size_contents = true;
        }

        if (!no_autofit && (this._colautofit || this._rowautofit))
            this._applyAutofittype(true);

        this._updateSelector();
        this._updateScrollInfo();
        this._resizing_band--;
        this._resetScrollMax();
        this._band_resizing_no_autofit.pop();
    };

    _pGrid._onResetScrollBar = function ()
    {/*
        if (this._scrollbars == 1 || this._scrollbars == 4) // autovert, fixedvert
        {
            if (this._rowautofit)
                this._scrollbars = 0;
        }
        else if (this._scrollbars == 2 || this._scrollbars == 8) // autohorz, fixedhorz
        {
            if (this._colautofit)
                this._scrollbars = 0;
        }
        else if (this._scrollbars == 3) // autohorz
        {
            if (this._colautofit && this._rowautofit)
                this._scrollbars = 0;
            if (this._colautofit)
                this._scrollbars = 1;
            if (this._rowautofit)
                this._scrollbars = 2;
        }
        else if (this._scrollbars == 16) // alwaysvert
        {
            if (this._rowautofit)
                this._scrollbars = 2;
        }
        else if (this._scrollbars == 32) // alwayshorz
        {
            if (this._colautofit)
                this._scrollbars = 1;
        }
        */
        var control_elem = this._control_element;
        if (control_elem)
        {
            var hscrollbar_size = this._getHScrollBarSize();
            var vscrollbar_size = this._getVScrollBarSize();

            var bcreatevscroll = false;
            var bcreatehscroll = false;

            var hscrollbartype = this._getHScrollBarType();
            var vscrollbartype = this._getVScrollBarType();

            var scrolltype = this._p_scrolltype;

            var vscroll_enable = false;
            var hscroll_enable = false;

            if (hscrollbartype != "none")
                bcreatehscroll = true;

            if (vscrollbartype != "none")
                bcreatevscroll = true;

            if (this._is_form && this.getStepCount() > 0)
                bcreatehscroll = false;

            var client_left = control_elem.client_left;
            var client_top = control_elem.client_top;
            var client_width = control_elem.client_width;
            var client_height = control_elem.client_height;
            var zoomfactor = control_elem.zoom / 100;

            if (this._p_showgroupbar)
                client_height += this._groupbarheight;

            var v_elements = control_elem._target_vscroll_elements, v_element = v_elements, h_elements = control_elem._target_hscroll_elements, h_element = h_elements;
            if (nexacro._isArray(v_elements)) v_element = v_elements[0];
            if (nexacro._isArray(h_elements)) h_element = h_elements[0];

            var v_client_height = (v_element) ? v_element._calculateClientHeight(0) : client_height;
            var h_client_width = (h_element) ? h_element._calculateClientWidth(client_width) : client_width;
            var scroll_left = (h_element) ? h_element.scroll_left : 0;
            var scroll_top = (v_element) ? v_element._getScrollTop() : 0;

            if (this._isFastVscrolling())   // fastvscroll 중..
            {
                scroll_top = this._p_vscrollbar._pos;

                if (scroll_top > Math.ceil(control_elem.vscroll_limit))
                    scroll_top = Math.ceil(control_elem.vscroll_limit);
            }

            var zclient_width = h_client_width / zoomfactor;
            var zclient_height = v_client_height / zoomfactor;

            var paddingleft, paddingtop, paddingright, paddingbottom;
            paddingleft = paddingtop = paddingright = paddingbottom = 0;

            var padding = control_elem.padding ? control_elem.padding : control_elem._padding_info;

            if (control_elem._apply_client_padding && padding)
            {
                paddingleft = padding.left;
                paddingtop = padding.top;
                paddingright = padding.right;
                paddingbottom = padding.bottom;
            }

            var hscroll_left = client_left - paddingleft;
            var hscroll_top = client_height + paddingtop + paddingbottom;
            var hscroll_width = client_width + paddingleft + paddingright;

            var vscroll_left = client_width + paddingleft + paddingright;
            var vscroll_top = client_top - paddingtop;
            var vscroll_height = client_height + paddingtop + paddingbottom;

            if (this._p_showgroupbar)
                vscroll_height -= this._groupbarheight;

            if (bcreatehscroll)
            {
                this._createHScrollBar(hscrollbar_size);

                if (hscrollbar_size > 0)
                {
                    if (control_elem.hscroll_limit <= 0 && hscrollbartype != "fixed")
                        hscrollbar_size = 0;

                    if (hscrollbartype == "autoindicator")
                    {
                        hscroll_top -= hscrollbar_size;
                        this._p_hscrollbar.set_visible(false);
                    }
                    else
                        this._p_hscrollbar.set_visible(true);
                }


                if (this._isEnable() && hscrollbar_size > 0 && (scrolltype != "none" && scrolltype != "vertical") && control_elem.hscroll_limit > 0)
                    hscroll_enable = true;

            }
            else
            {
                if (this._p_hscrollbar)
                {
                    this._p_hscrollbar.destroy();
                    this._p_hscrollbar = null;
                }
            }

            if (bcreatevscroll)
            {
                this._createVScrollBar(vscrollbar_size);

                if (vscrollbar_size > 0)
                {
                    if (control_elem.vscroll_limit <= 0 && vscrollbartype != "fixed")
                    {
                        vscrollbar_size = 0;
                    }

                    if (vscrollbartype == "autoindicator")
                    {
                        vscroll_left -= vscrollbar_size;
                        this._p_vscrollbar.set_visible(false);
                    }
                    else
                        this._p_vscrollbar.set_visible(true);

                    if (this._isEnable() && vscrollbar_size > 0 && (scrolltype != "none" && scrolltype != "horizontal") && control_elem.vscroll_limit > 0)
                        vscroll_enable = true;
                }
            }
            else
            {
                if (this._p_vscrollbar)
                {
                    this._p_vscrollbar.destroy();
                    this._p_vscrollbar = null;
                }
            }

            var vscroll_value = this._vscrollmng._scroll_convert_pixel(1, true);
            this._hscrollmng._setInfo(hscroll_left, hscroll_top, hscroll_width, hscrollbar_size, 0, control_elem.hscroll_limit, this._scroll_default_value, zclient_width, zclient_width, scroll_left);
            this._vscrollmng._setInfo(vscroll_left, vscroll_top, vscrollbar_size, vscroll_height, 0, Math.ceil(control_elem.vscroll_limit), vscroll_value, zclient_height, zclient_height, scroll_top);

            if (this._hscroll_pos > control_elem.hscroll_limit)
                this._hscroll_pos = control_elem.hscroll_limit;

            if (this._vscroll_pos > Math.ceil(control_elem.vscroll_limit))
                this._vscroll_pos = Math.ceil(control_elem.vscroll_limit);

            // ScrollBar Visible시 생성
            if (this._p_hscrollbar)
            {
                this._p_hscrollbar._setScrollInfo(hscroll_left, hscroll_top, hscroll_width, hscrollbar_size, 0, control_elem.hscroll_limit, this._scroll_default_value, zclient_width, zclient_width, hscroll_enable, scroll_left);

                if (!this._p_hscrollbar._is_created)
                    this._p_hscrollbar.on_created(this._getWindow());
            }

            if (this._p_vscrollbar)
            {
                this._p_vscrollbar._setScrollInfo(vscroll_left, vscroll_top, vscrollbar_size, vscroll_height, 0, Math.ceil(control_elem.vscroll_limit), vscroll_value, zclient_height, zclient_height, vscroll_enable, scroll_top);
                if (!this._p_vscrollbar._is_created)
                    this._p_vscrollbar.on_created(this._getWindow());
            }
        }
    };

    _pGrid._setHscrollElement = function ()
    {
        if (!this._control_element)
            return;

        var horz_control_elems = [];

        // _createBandsAndAreas  의 생성 순서와 동일하게.. element js 쪽에서 horz_control_elems[0]으로 체크하기 때문..

        var rows;
        var i, n;

        if (this._bodyBand)
        {
            rows = this._bodyBand._get_rows();

            for (i = 0, n = rows.length; i < n; i++)
                horz_control_elems.push(rows[i]._control_element);
        }
        if (this._headBand)
        {
            rows = this._headBand._matrix._rows;

            for (i = 0, n = rows.length; i < n; i++)
                horz_control_elems.push(rows[i]._control_element);
        }
        if (this._summBand)
        {
            rows = this._summBand._matrix._rows;

            for (i = 0, n = rows.length; i < n; i++)
                horz_control_elems.push(rows[i]._control_element);
        }

        if (horz_control_elems.length == 0)
            horz_control_elems = null;

        this._control_element.setHorzScrollElements(horz_control_elems);
    };

    // div max height
    nexacro._bigdata_innertest = 0;// test

    if (nexacro._bigdata_innertest)
        _pGrid._div_max_height = 1000;
    else if (nexacro._Browser == "Gecko")       // 17895696
        _pGrid._div_max_height = 17890000;
    else
        _pGrid._div_max_height = 5000000;      // 33550000 - > 5000000 (크롬 브라우저 확대문제)

    _pGrid._resetScrollMax = function (chk_vmax)
    {
        if (this._resizing_band > 0)
            return;

        var body = this._bodyBand;

        if (!body)
            return;

        var format = this._curFormat;
        var rowcnt = this._getGridRowCount();
        var scrollwidth = format.bodyWidth;
        var rowSizes = this._rowSizeList;
        var datarow;
        var band_scroll_tops = [];
        var band_sizes_cnt = 1;
        var band_scroll_max = this._div_max_height;
        var scrollheight = 0;

        for (var i = 0; i < rowcnt; i++)
        {
            datarow = this._getDataRow(this._rowToPageRow(i));
            scrollheight += rowSizes[datarow];

            if (scrollheight - this._fixedrow_height >= band_scroll_max * band_sizes_cnt)
            {
                band_scroll_tops.push(scrollheight - rowSizes[datarow]);
                band_sizes_cnt++;
            }
        }

        scrollheight -= this._fixedrow_height;
        band_scroll_tops.push(scrollheight);

        var refresh = true;

        if (chk_vmax && body._scrollHeight == scrollheight)
            refresh = false;

        body._scrollHeight = scrollheight;
        body._scrollWidth = scrollwidth;

        if (refresh)
            this._setScrollMaxSize(body._scrollWidth, body._scrollHeight, band_scroll_tops);
    };

    _pGrid._setContents = function (str)
    {
        var contentsElem = nexacro._parseXMLDocument(str);
        var formatElems = contentsElem.getElementsByTagName("Format");
        var len = formatElems ? formatElems.length : 0;
        var firstformat = "";

        this._format_str = [];
        this._autofitcol_rate = [];

        for (var i = 0; i < len; i++)
        {
            var formatElem = formatElems[i];
            var idstr = formatElem.getAttribute("id");
            if (idstr == null || idstr == "")
                idstr = "default";

            if (firstformat == "" || idstr == "default")
                this._default_formatid = firstformat = idstr;

            var format = new nexacro.GridFormat(idstr, this);
            format._loadFromDOM(formatElem);
            this._formats[idstr] = format;
            this._format_str.push(idstr);
        }
        this._p_formats = str;

        if (this._p_formatid == "" || (this._is_created && this._p_formatid != firstformat))
            this._p_formatid = firstformat;

        this._curFormat = this._formats[this._p_formatid];
        this._clearTempBand();

        return true;
    };

    _pGrid._destroyBands = function (parent_destroy)
    {
        if (!this._p_enableredraw)
        {
            this._enable_redraw_history.recreate = true;
            return;
        }

        if (!parent_destroy)
            this._hideEditor(true);

        if (this._bodyBand)
        {
            if (this._control_element)
                this._control_element.setVertScrollElements(null);

            this._bodyBand.destroy();
            this._bodyBand = null;
            this._p_body = null;
        }
        if (this._summBand)
        {
            this._summBand.destroy();
            this._summBand = null;
            this._p_summary = null;
            this._p_summ = null;
        }
        if (this._headBand)
        {
            this._headBand.destroy();
            this._headBand = null;
            this._p_head = null;
        }
        if (this._groupBar)
        {
            this._groupBar.destroy();
            this._groupBar = null;
        }
        if (this._select_ctrl)
        {
            this._select_ctrl.destroy();
            this._select_ctrl = null;
        }
        if (this.controlbutton)
        {
            this.controlbutton = null;
        }
        if (this.controlcalendar)
        {
            this.controlcalendar = null;
        }
        if (this.controlcheckbox)
        {
            this.controlcheckbox = null;
        }
        if (this.controlcombo)
        {
            this.controlcombo = null;
        }
        if (this.controlmulticombo)
        {
            this.controlmulticombo = null;
        }
        if (this.controledit)
        {
            this.controledit = null;
        }
        if (this.controlmaskedit)
        {
            this.controlmaskedit = null;
        }
        if (this.controltextarea)
        {
            this.controltextarea = null;
        }
        if (this.controlprogressbar)
        {
            this.controlprogressbar = null;
        }
        if (this.controlexpand)
        {
            this.controlexpand = null;
        }
        this.on_apply_nodatatext();

        this._destroyOverlayControls();
        this._destroySelectionControls();
        this._destroyCellSelectionControl();
    };

    _pGrid._refreshAll = function (clearCurstyle)
    {
        this._refreshHead(clearCurstyle);
        this._refreshSumm(clearCurstyle);
        this._refreshBody(clearCurstyle);
    };

    _pGrid._getBodyCellInfo = function (nCellIdx)
    {
        if (this._curFormat && this._curFormat._bodycells)
        {
            var cellinfo = this._curFormat._bodycells[nCellIdx];
            if (cellinfo)
                return cellinfo;
        }

        return null;
    };

    _pGrid._isFastVscrolling = function () 
    {
        return (this._covercontrol && this._covercontrol._p_visible);
    };

    _pGrid._getBodyCellItem = function (nRowIdx, nCellIdx)
    {
        return (this._bodyBand._get_rows()[nRowIdx]._cells[nCellIdx]);
    };

    _pGrid._refreshBodyCell = function (cell, displayrow, for_select, styleprop, subcellidx)
    {
        if (!this._p_enableredraw)
        {
            this._enable_redraw_history.refresh_body = true;
            return;
        }

        if (this._after_recreate)
            return;

        if (displayrow < 0)
            return;

        var band = this._bodyBand;
        if (band)
        {
            var rows = band._get_rows();

            if (rows.length <= displayrow)
                return;

            var rowidx = rows[displayrow]._rowidx;
            var dsrowidx = (this._hasTree) ? this._treeIndexes[rowidx] : rowidx;
            var selected = this._isSelectedCell(cell, dsrowidx);

            if (rows[displayrow])
            {
                var cellobj = rows[displayrow]._cells[cell];
                var datarow = cellobj._getDataRow();

                if (subcellidx >= 0)
                {
                    var subcellinfo = cellobj._refinfo._subcells[subcellidx];
                    if (styleprop && subcellinfo && cellobj.subcells[subcellidx]["set_" + styleprop])
                        cellobj.subcells[subcellidx]["set_" + styleprop](subcellinfo._getAttrValue(subcellinfo["_p_" + styleprop], datarow));
                }
                else
                {
                    var cellinfo = cellobj._refinfo;
                    if (styleprop && cellobj["set_" + styleprop])
                        cellobj["set_" + styleprop](cellinfo._getAttrValue(cellinfo["_p_" + styleprop], datarow));
                }

                band._refreshRowCell(rows, displayrow, cell, selected, undefined, undefined, for_select);
            }
        }
    };

    _pGrid._refreshHead = function (clearCurstyle)
    {
        if (!this._p_enableredraw)
        {
            this._enable_redraw_history.refresh_head = true;
            return;
        }

        if (this._after_recreate)
            return;

        var band = this._headBand;
        if (band)
        {
            var rowcnt = band._get_rows().length;

            band._updateAll(clearCurstyle);

            for (var i = 0; i < rowcnt; i++)
            {
                band._refreshRow(i);
            }
        }
        this._applyResizer();
        this._adjustOverlayControls(false, "head");
    };

    _pGrid._refreshSumm = function (clearCurstyle)
    {
        if (!this._p_enableredraw)
        {
            this._enable_redraw_history.refresh_summ = true;
            return;
        }

        if (this._after_recreate)
            return;

        var band = this._summBand;
        if (band)
        {
            var rowcnt = band._get_rows().length;

            band._updateAll(clearCurstyle);

            for (var i = 0; i < rowcnt; i++)
            {
                band._refreshRow(i);
            }
            band._updateAll(clearCurstyle);
        }
        this._adjustOverlayControls(false, "summ");
    };

    _pGrid._refreshBody = function (clearCurstyle, for_select, no_overlay, no_update_supp)
    {
        if (!this._p_enableredraw)
        {
            this._enable_redraw_history.refresh_body = true;
            return;
        }

        if (this._after_recreate)
            return;

        var band = this._bodyBand;
        if (band)
        {
            if (!no_update_supp)
                this._suppressUpdate();

            var rowcnt = this._getDispRowCnt();

            band._updateAll(clearCurstyle);

            for (var i = 0; i < rowcnt; i++)
            {
                band._refreshRow(i, undefined, for_select);
            }

            if (!no_overlay)
                this._adjustOverlayControls(this._is_recreating);
        }
    };

    _pGrid._isSuppressSameRow = function (displaytype, pdatarow, cdatarow, cellinfo)
    {
        var text1, text2;

        if (displaytype == "treeitemcontrol")
            return false;

        if (this._groupcount > 0)
        {
            if ((displaytype == "rowgroupcontrol"))
            {
                if (cellinfo._groupcol >= 0)
                {
                    var level = cellinfo._getGroupRowLevel(cdatarow);

                    if (level > cellinfo._groupcol)
                    {
                        if (cellinfo._isGroupColumnFirstSubSumCell(cdatarow))
                            return false;
                        else
                            return true;
                    }
                    else
                        return false;
                }
                else
                {
                    return false;
                }
            }
            else if (this._binddataset.getRowType(pdatarow) >= 16 || this._binddataset.getRowType(cdatarow) >= 16)
            {
                return false;
            }
        }
        text1 = cellinfo._getDisplayText(pdatarow);
        text2 = cellinfo._getDisplayText(cdatarow);

        if (text1 == text2)
            return true;

        return false;
    };

    _pGrid._isSuppressSameCol = function (displaytype, pcellinfo, ccellinfo, cdatarow)
    {
        var text1, text2;
        if (displaytype == "treeitemcontrol" || displaytype == "rowgroupcontrol")
            return false;

        text1 = pcellinfo._getDisplayText(cdatarow);
        text2 = ccellinfo._getDisplayText(cdatarow);

        if (text1 == text2)
            return true;

        return false;
    };

    _pGrid._analyzeSuppress = function (exportFlag)
    {
        /*
            allskip     : level을 무시하고 중복된 것을 묶음.
            sameskip    : level이 다른 경우에만 쪼개짐. 같은 것끼리는 무시
            allcompare  : level이 같은 경우도 쪼개져 있으면 같이 쪼갬.
        */

        var supphorztype = this._supphorztype;
        var usesupp = this._is_use_suppress;

        if (!usesupp && !supphorztype)
            return;

        var cells = this._curFormat._bodycells;

        if (!cells) return;

        var total_dispcnt;

        if (exportFlag)
            total_dispcnt = this._getGridRowCount();
        else
            total_dispcnt = this._getSuppRowTotal();

        if (total_dispcnt == 0) return;

        var cellcnt = cells.length;
        var cellinfo;
        var csuppinfo, csupp, rowidx, cdatarow;
        var i, j;
        for (j = 0; j < cellcnt; j++)
        {
            cellinfo = cells[j];

            if (cellinfo._p_suppress == 0 && supphorztype == 0)
                continue;

            cellinfo._clearSuppressInfo();

            var displaytype, psuppinfo, pdatarow;
            var same_cnt = 0, first = true, firstsuppinfo = null;

            for (i = 0; i <= total_dispcnt; i++)
            {
                if (nexacro._Browser == "Runtime" && exportFlag)
                    nexacro._peekWindowHandleMessageQueuePassing(this._getWindow());

                rowidx = (!exportFlag) ? this.__getBodyCellRowIdxFromIdx(i) : i;
                cdatarow = this._getDataRow(rowidx);

                displaytype = cellinfo._getDisplaytype(cdatarow);

                /*
                for (var z = 0; z < cellinfo._subcells.length; z++)
                {
                    if (cellinfo._subcells[z]._getDisplaytype(cdatarow) == "rowgroupcontrol")   // subcell 안에 rowgroup이 있는 경우
                    {
                        displaytype = "rowgroupcontrol";
                        cellinfo._p_suppress._set(cellinfo._groupcol + 1);
                        break;
                    }
                }
                */
                // vert suppress
                if (usesupp)
                {
                    csupp = cellinfo._getSuppress(cdatarow);

                    if (i > 0)
                        psuppinfo = cellinfo._getSuppressInfo(i - 1, true);

                    if (csupp > 0 && i > 0 && psuppinfo)
                    {
                        if (total_dispcnt == i)
                            break;

                        pdatarow = this._getDataRow((!exportFlag) ? this.__getBodyCellRowIdxFromIdx(i - 1) : i - 1);

                        if (this._isFakeCell(cdatarow))
                            continue;

                        if (this._isSuppressSameRow(displaytype, pdatarow, cdatarow, cellinfo))
                        {
                            psuppinfo.last = false;
                            psuppinfo.first = first;

                            if (first)
                                firstsuppinfo = psuppinfo;

                            same_cnt++;
                            first = false;
                        }
                        else
                        {
                            psuppinfo.last = true;
                            psuppinfo.same_rowcnt = same_cnt;

                            if (firstsuppinfo)
                            {
                                firstsuppinfo.same_rowcnt = same_cnt;   // count (first, last info에만 setting)
                                firstsuppinfo = null;
                            }
                            same_cnt = 0;
                            first = true;
                        }

                        if (cdatarow == this._rowcount - 1) 
                        {
                            csuppinfo = cellinfo._getSuppressInfo(i, true);

                            if (firstsuppinfo)
                                firstsuppinfo.same_rowcnt = same_cnt;   // count (first, last info에만 setting)

                            csuppinfo.last = true;
                            csuppinfo.same_rowcnt = same_cnt;
                        }
                    }
                }

                // horz suppress
                if (supphorztype > 0 && j > 0)
                {
                    var p_cellinfo = cells[j - 1];

                    if (this._treeCellinfo != p_cellinfo && this._treeCellinfo != cellinfo)
                    {
                        if (((supphorztype == 1 || supphorztype == 3) && cellinfo._area == "left") ||
                            ((supphorztype == 2 || supphorztype == 3) && p_cellinfo._area == "right"))
                        {
                            csuppinfo = p_cellinfo._getSuppressInfo(i, true);

                            if (this._isSuppressSameCol(displaytype, p_cellinfo, cellinfo, cdatarow))
                            {
                                csuppinfo.horzlast = false;
                                cellinfo._getSuppressInfo(i, true); // vert suppress 사용안할경우를 위해 생성
                            }
                            else
                            {
                                csuppinfo.horzlast = true;
                            }
                        }
                    }
                }
            }
        }

        if (!usesupp)
            return;

        var suppresslevel = this._p_suppresslevel;

        if (suppresslevel == "sameskip" || suppresslevel == "allcompare")
        {
            i = 0;
            function __analyzeSuppress_row_loop2(grid)
            {
                if (nexacro._Browser == "Runtime" && exportFlag)
                    nexacro._peekWindowHandleMessageQueuePassing(grid._getWindow());

                if (i < total_dispcnt)
                {
                    var suppressRow = [];
                    var suppressCol = [];

                    rowidx = (!exportFlag) ? grid.__getBodyCellRowIdxFromIdx(i) : i;
                    cdatarow = grid._getDataRow(rowidx);

                    for (j = 0; j < cellcnt; j++)
                    {
                        cellinfo = cells[j];
                        csupp = cellinfo._getSuppress(cdatarow);

                        if (csupp > 0)
                        {
                            suppressRow.push(cellinfo);
                        }
                        if (csupp < 0)
                        {
                            // todo
                            // suppressCol.push(cellinfo);
                        }
                    }

                    if (suppressRow.length > 0)
                    {
                        suppressRow.sort(function (a, b) { return a._getSuppress(cdatarow) - b._getSuppress(cdatarow); });

                        var suppressRowLen = suppressRow.length;

                        for (var jj = 0; jj < suppressRowLen; jj++)
                        {
                            cellinfo = suppressRow[jj];

                            if (cellinfo)
                            {
                                for (var k = 0; k < cellcnt; k++)
                                {
                                    if (k == cellinfo._col) // 자신을 제외한 모든셀 전부 비교
                                    {
                                        continue;
                                    }
                                    grid._compareSuppressCol(i, k, cellinfo._col, suppresslevel, cdatarow);
                                }
                            }
                        }
                    }

                    if (suppressCol.length > 0)
                    {
                        suppressCol.sort(function (a, b) { return b._getSuppress(cdatarow) - a._getSuppress(cdatarow); });

                        var suppressColLen = suppressCol.length;

                        for (var jjj = 0; jjj < suppressColLen; jjj++)
                        {
                            cellinfo = suppressCol[jjj];

                            if (cellinfo)
                            {
                                for (var kk = 0; kk < cellcnt; kk++)
                                {
                                    if (kk == cellinfo._col)
                                    {
                                        continue;
                                    } // 자신을 제외한 모든셀 전부 비교
                                    // TODO
                                }
                            }
                        }
                    }
                    i++;
                    return false;
                }
                return true;
            }
            while (true)
            {
                if (__analyzeSuppress_row_loop2(this)) break;
                if (__analyzeSuppress_row_loop2(this)) break;
                if (__analyzeSuppress_row_loop2(this)) break;
                if (__analyzeSuppress_row_loop2(this)) break;
                if (__analyzeSuppress_row_loop2(this)) break;
                if (__analyzeSuppress_row_loop2(this)) break;
                if (__analyzeSuppress_row_loop2(this)) break;
                if (__analyzeSuppress_row_loop2(this)) break;
                if (__analyzeSuppress_row_loop2(this)) break;
                if (__analyzeSuppress_row_loop2(this)) break;
            }
        }

        // middle check
        if (total_dispcnt > 0)
        {
            var count = 0;
            var start;
            var csuppinfo2;

            for (j = 0; j < cellcnt; j++)
            {
                start = 0;

                var center;

                for (i = 0; i < total_dispcnt; i++)
                {
                    if (nexacro._Browser == "Runtime" && exportFlag)
                        nexacro._peekWindowHandleMessageQueuePassing(this._getWindow());

                    cellinfo = cells[j];

                    if (cellinfo._p_suppress == 0)
                        continue;

                    rowidx = (!exportFlag) ? this.__getBodyCellRowIdxFromIdx(i) : i;

                    cdatarow = this._getDataRow(rowidx);

                    if (cellinfo._p_suppressalign.indexOf("middle") < 0)
                        break;

                    csuppinfo = cellinfo._getSuppressInfo(i);
                    csuppinfo.middle = false;

                    csupp = cellinfo._getSuppress(cdatarow);

                    if (csupp > 0)
                    {
                        count++;
                        if (csuppinfo.last == true)
                        {
                            if (count == 1)
                            {
                                csuppinfo.middle = true;
                            }
                            else
                            {
                                center = Math.round(count / 2);
                                csuppinfo2 = cellinfo._getSuppressInfo(start + center - 1);
                                csuppinfo2.middle = true;
                            }
                            start = i + 1;	// +1 = next부터
                            count = 0;
                        }
                    }/*
                    if (csupp < 0)
                    {
                        //TODO
                        ;
                    }*/
                }
            }
        }
    };


    _pGrid._compareSuppressCol = function (row, cell, curcol, supplvl, cdatarow)
    {
        var cells = this._curFormat._bodycells;
        var pinfo = cells[cell];
        var cinfo = cells[curcol];
        var psuppinfo, csuppinfo;

        if (!cinfo)
            return false;

        var csupp = cinfo._getSuppress(cdatarow);
        var psupp = pinfo._getSuppress(cdatarow);

        if (csupp <= 0 || psupp <= 0)
            return false;

        if (psupp < csupp)   // sameskip, allcompare
        {
            psuppinfo = pinfo._getSuppressInfo(row);
            csuppinfo = cinfo._getSuppressInfo(row);

            if (psuppinfo.last == true)
            {				// suppress값이 작은 셀이 쪼개어져있으면 같이 쪼갠다.
                csuppinfo.last = true;
            }
            return true;
        }
        else if (supplvl == "allcompare" && psupp == csupp)
        {
            psuppinfo = pinfo._getSuppressInfo(row);
            csuppinfo = cinfo._getSuppressInfo(row);

            if (psuppinfo.last == true)
            {				// suppress값이 작은 셀이 쪼개어져있으면 같이 쪼갠다.
                csuppinfo.last = true;
            }
            if (csuppinfo.last == true)
            {				// suppress값이 작은 셀이 쪼개어져있으면 같이 쪼갠다.
                psuppinfo.last = true;
            }
            return true;
        }
        return false;
    };

    _pGrid.__getBodyCellRowIdxFromIdx = function (idx)
    {
        var toprowpos;
        if (this._fixed_rowcnt)
        {
            if (idx + this._fixed_startrow <= this._fixed_endrow)
                toprowpos = this._fixed_startrow;
            else
            {
                idx -= this._fixed_rowcnt - this._fixed_startrow;
                toprowpos = this._toprowpos[0];
            }
        }
        else
        {
            toprowpos = this._toprowpos[0];
        }
        return idx + toprowpos;
    };

    _pGrid._getSuppRowTotal = function ()
    {
        var total_dispcnt;
        var disprowcnt = this._disprowcnt;

        if (this._fixed_rowcnt > 0)
            total_dispcnt = this._fixed_rowcnt - this._fixed_startrow + disprowcnt;
        else
            total_dispcnt = disprowcnt;

        return total_dispcnt;
    };

    _pGrid._suppressUpdate = function ()
    {
        this._analyzeSuppress();

        var supphorztype = this._supphorztype;
        var usesupp = this._is_use_suppress;

        if (!usesupp && !supphorztype)
            return;

        if (!this._curFormat || !this._curFormat._bodycells)
            return;

        var total_dispcnt = this._getSuppRowTotal();

        for (var i = 0; i <= total_dispcnt; i++)
        {
            this._suppressUpdateRow(i, 0, total_dispcnt - 1);
        }
    };

    _pGrid._suppressUpdateRow = function (row, start_rowpos, end_rowpos, exportFlag)
    {
        var band = this._bodyBand;

        if (band == null)
            return;

        var cells = this._curFormat._bodycells;
        var cellcnt = cells.length;
        var rowidx = (!exportFlag) ? this.__getBodyCellRowIdxFromIdx(row) : row;
        var cellinfo, prelast, curlast;
        var psuppinfo, csuppinfo, csupp;
        var cdatarow = this._getDataRow(rowidx);
        var supphorztype = this._supphorztype;

        if (cdatarow < 0)
            return;

        for (var col = 0; col < cellcnt; col++)
        {
            cellinfo = cells[col];
            csuppinfo = cellinfo._getSuppressInfo(row);
            csupp = cellinfo._getSuppress(cdatarow);

            if (!csuppinfo)
                continue;

            if (csupp > 0)
            {
                if (csupp > 0 && (row - start_rowpos) > 0)
                {			// row suppress
                    psuppinfo = cellinfo._getSuppressInfo(row - 1);
                }
                /* todo?
                                else if (cellinfo.csupp < 0 && col > 0)
                                {			// col suppress
                                    var prevcellinfo = cells[col - 1];
                                    psuppinfo = prevcellinfo._getSuppressInfo(row);
                                }
                */
                prelast = (psuppinfo ? psuppinfo.last : true);
                curlast = (row == end_rowpos ? true : csuppinfo.last);

                if (cellinfo._p_suppressalign.indexOf("first") >= 0)
                {
                    if (prelast == false)
                    {
                        csuppinfo.text_proc = csupp;
                    }
                    else
                    {
                        csuppinfo.text_proc = 0;
                    }
                }
                else if (cellinfo._p_suppressalign.indexOf("last") >= 0)
                {
                    if (curlast == false)
                    {
                        csuppinfo.text_proc = csupp;
                    }
                    else
                    {
                        csuppinfo.text_proc = 0;
                    }
                }
                else if (cellinfo._p_suppressalign.indexOf("middle") >= 0)
                {
                    if (csuppinfo.middle == true)
                    {
                        csuppinfo.text_proc = 0;
                    }
                    else
                    {
                        csuppinfo.text_proc = csupp;
                    }
                }

                if (psuppinfo)
                {
                    if (prelast == false)
                    {
                        psuppinfo.border_proc = csupp;
                    }
                    else
                    {
                        psuppinfo.border_proc = 0;
                    }
                }
            }
            else if (csupp == undefined)
            {
                if (cellinfo._p_suppressalign.indexOf("first") >= 0 || cellinfo._p_suppressalign.indexOf("middle") >= 0)
                {
                    csuppinfo.text_proc = 1;
                }
            }

            if (supphorztype > 0)
            {
                if (col > 0)
                {
                    var p_cellinfo = cells[col - 1];
                    var p_suppinfo = p_cellinfo._getSuppressInfo(row);

                    if (!p_suppinfo)
                        continue;

                    var start = false;
                    if ((p_suppinfo.first || p_suppinfo.last) && (csuppinfo.first || csuppinfo.last))
                    {
                        if (p_cellinfo._area == "left")
                        {
                            if (!csuppinfo.same_rowcnt)
                            {
                                if (p_suppinfo.horzlast == false)
                                {
                                    start = true;
                                    p_suppinfo.horz_border_proc = 1;
                                }

                                if (start)
                                    csuppinfo.horz_text_proc = 1;

                                //if (start && csuppinfo.horzlast == true)
                                //  start = false;
                            }
                        }
                        else if (p_cellinfo._area == "right")
                        {
                            if (!p_suppinfo.same_rowcnt)
                            {
                                if (p_suppinfo.horzlast == false)
                                {
                                    start = true;
                                    csuppinfo.horz_border_proc = 1;
                                }

                                if (start)
                                    p_suppinfo.horz_text_proc = 1;

                                if (start && csuppinfo.horzlast == true)
                                {
                                    csuppinfo.horz_border_proc = 1;
                                    //  start = false;
                                }
                            }
                        }
                    }
                }
            }
        }
    };

    _pGrid._refreshBodyRow = function (displayrow, status, removecell, for_select)
    {
        if (!this._p_enableredraw)
        {
            this._enable_redraw_history.refresh_body = true;
            return;
        }

        if (this._after_recreate)
            return;

        var band = this._bodyBand;
        if (band)
        {
            var rows = band._get_rows();
            if (rows.length <= displayrow)
                return;

            var rowcnt = this._getDispRowCnt();
            if (displayrow >= 0 && displayrow < rowcnt)
            {
                var rowidx = rows[displayrow]._rowidx;
                var dsrowidx = (this._hasTree) ? this._treeIndexes[rowidx] : rowidx;

                if (dsrowidx == undefined)
                    return;

                band._refreshRow(displayrow, status, for_select, removecell);
            }
            this._adjustOverlayControls(false);
        }
    };

    _pGrid._global_cursor = undefined;
    _pGrid._setGlobalCursor = function (cursor, obj, to_obj)
    {
        if (nexacro._cur_track_info || nexacro._cur_extra_track_info)
            return;

        if (this._global_cursor !== cursor)
        {
            if (!to_obj)
                this._global_cursor = cursor;

            if (cursor)
                this._global_cursor_obj = obj;
            else if (!obj)
                obj = this._global_cursor_obj;

            while (obj)
            {
                obj._updateCursor(cursor);

                if (obj instanceof nexacro.Grid)
                    return;

                if (obj == to_obj) return;
                obj = obj.parent;
            }
        }
    };

    _pGrid._getColMergeInfo = function (band, col_idx)
    {
        var cells;

        if (band == "head")
            cells = this._curFormat._headcells;
        else if (band == "summ" || band == "summary")
            cells = this._curFormat._summcells;
        else
            cells = this._curFormat._bodycells;

        if (!cells)
            return null;

        var cellsLen = cells.length;
        var cell;
        var col = col_idx;
        var colspan = 1;
        var retn = [];

        for (var i = 0; i < cellsLen; i++)
        {
            cell = cells[i];
            if (cell._col <= col_idx && (cell._col + cell._colspan) > col_idx)
            {
                if (colspan < cell._colspan)
                {
                    colspan = cell._colspan;
                    col = cell._col;
                }
            }
        }
        retn[0] = col;
        retn[1] = colspan;

        return retn;
    };

    _pGrid._applySelect = function (arrS, arrE, pos)
    {
        var each = false;

        if (this._p_summarytype == "top" || this._p_summarytype == "lefttop")
            each = true;

        if (arrS.length == 0 || (each && pos < 0))
        {
            arrS.splice(0, 0, pos);
            arrE.splice(0, 0, pos);
        }
        else
        {
            var nobodys, nobodye;
            var mincnt = 0;
            var i;

            if (each)
            {
                for (i = 0; i < arrS.length; i++)
                {
                    if (arrS[i] >= 0)
                        break;

                    mincnt++;
                }

                nobodys = arrS.splice(0, mincnt);
                nobodye = arrE.splice(0, mincnt);
            }

            var cnt = arrS.length;

            if (cnt == 0)
            {
                arrS.splice(0, 0, pos);
                arrE.splice(0, 0, pos);
            }
            else if (cnt == 1 || arrS[0] > pos)
            {
                this._addSelect(arrS, arrE, 0, pos);
            }
            else if (arrE[cnt - 1] < pos)
            {
                this._addSelect(arrS, arrE, cnt - 1, pos);
            }
            else
            {
                for (i = 0; i < cnt; i++)
                {
                    if (arrE[i] < pos && arrS[i + 1] > pos)
                    {
                        if ((arrE[i] + 1) == pos && (arrS[i + 1] - 1) > pos)
                        {
                            this._addSelect(arrS, arrE, i, pos);
                        }
                        else if ((arrE[i] + 1) < pos && (arrS[i + 1] - 1) == pos)
                        {
                            this._addSelect(arrS, arrE, i + 1, pos);
                        }
                        else if ((arrE[i] + 1) == pos && (arrS[i + 1] - 1) == pos)
                        {
                            this._addSelect(arrS, arrE, i, pos);
                            arrE[i] = arrE[i + 1];
                            arrS.splice(i + 1, 1);
                            arrE.splice(i + 1, 1);
                        }
                        else if ((arrE[i] + 1) < pos && (arrS[i + 1] - 1) > pos)
                        {
                            arrS.push(pos);
                            arrE.push(pos);
                            arrS.sort();
                            arrE.sort();
                        }
                        break;
                    }
                }
            }

            if (each)
            {
                for (i = 0; i < nobodys.length; i++)
                {
                    arrS.splice(0, 0, nobodys[i]);
                    arrE.splice(0, 0, nobodye[i]);
                }
            }
        }
    };

    _pGrid._addSelect = function (arrS, arrE, idx, pos)
    {
        if (arrE[idx] < pos)
        {
            if ((arrE[idx] + 1) == pos)
            {
                arrE[idx] = pos;
            }
            else
            {
                arrS.push(pos);
                arrE.push(pos);
            }
        }
        else if (arrS[idx] > pos)
        {
            if ((arrS[idx] - 1) == pos)
            {
                arrS[idx] = pos;
            }
            else
            {
                arrS.push(pos);
                arrE.push(pos);
                arrS.sort();
                arrE.sort();
            }
        }
    };

    _pGrid._findCellObj = function (fromComp)
    {
        var cellobj = fromComp;
        while (cellobj && cellobj._type_name != "GridCellControl" && cellobj._type_name != "GridSubCellControl")
        {
            if (cellobj instanceof nexacro.Grid)
            {
                if (cellobj == this)
                {
                    break;
                }
                else
                {
                    cellobj = fromComp;
                    break;
                }
            }

            if (cellobj._cellobj && cellobj._cellobj._is_alive
                && (cellobj._cellobj._type_name == "GridCellControl" || cellobj._cellobj._type_name == "GridSubCellControl"))
            {
                cellobj = cellobj._cellobj;
                break;
            }
            cellobj = cellobj.parent;
        }
        return cellobj;
    };

    _pGrid._findBandObj = function (fromComp)
    {
        var bandobj = fromComp;
        while (bandobj && bandobj._type_name != "GridBandControl")
        {
            if (bandobj == this)
                break;

            bandobj = bandobj.parent;
        }
        return bandobj;
    };

    _pGrid._isFakeCell = function (rowidx)
    {
        if (this._rowcount <= rowidx || rowidx < -2)
            return true;

        return false;
    };

    _pGrid._moveToPosCell = function (rowidx, cellidx)
    {
        var newPos = rowidx;
        var retn = true;

        if (newPos == undefined) newPos = 0;

        if (this._isFakeCell(newPos))
            return false;

        var cellinfo = this._getBodyCellInfo(cellidx);
        if (!cellinfo)
            return false;

        var beforeCell = this._beforebodycellpos = this._selectinfo.curcell;
        var beforeCol = this._beforebodycolpos = this._selectinfo.curcol;
        var beforeRow = this._beforebodyrowpos = this._selectinfo.curdsrow;
        var beforeSubrow = this._beforebodysubrowpos = this._selectinfo.cursubrow;
        var beforePvt = this._beforepvt = this._selectinfo.curpvt;

        var afterCell = cellidx;
        var afterCol = cellinfo._col;
        var afterRow = newPos;
        var afterSubrow = cellinfo._row;
        var afterPvt = -9;

        this._setSelectedInfo(afterCell, afterCol, afterRow, afterSubrow, afterPvt);

        while (true)
        {
            if (afterCell != beforeCell)
                break;
            if (afterCol != beforeCol)
                break;
            if (afterRow != beforeRow)
                break;
            if (afterSubrow != beforeSubrow)
                break;
            if (afterPvt != beforePvt)
                break;

            retn = false;
            break;  // 소나큐브무시
        }

        if (retn)
            retn = this._ChangeSelect(afterCell, afterCol, afterRow, afterSubrow, afterPvt, false, beforeCell, beforeCol, beforeRow, beforeSubrow, beforePvt, "body");

        if (retn && this._isSelectRowType())
        {
            var disprow = this._dsRowToDispRow(afterRow);
            this._jumpCurrentRow(disprow);

            var cellobj = this._getCurrentBodyCell(afterRow, afterCell);
            if (cellobj)
                cellobj._showfull();
        }

        this._moveCellAfterFocus();

        return retn;
    };

    _pGrid._getColFixCnt = function (area)
    {
        if (this._curFormat)
        {
            return this._curFormat._getColFixCnt(area);
        }
        return -1;
    };

    _pGrid._getGridBand = function (nCell)
    {
        if (!this._curFormat || !this._curFormat._bodycells)
            return -1;

        var cell = this._curFormat._bodycells[nCell];
        if (cell)
        {
            if (this._bPivotGrid)
            {
                var leftcnt = this._getColFixCnt("left");
                var rightcnt = this._getColFixCnt("right");

                if (cell._col < leftcnt)
                    return -1;
                else if (cell._col >= (this._curFormat._bodycells.length - rightcnt))
                    return -2;
                else
                    return 0;
            }
            else
            {
                return 0;
            }
        }
        return -9;
    };

    _pGrid._clrMultiSelect = function ()
    {
        this._selectinfo.rows = [];
        this._selectinfo.selects = [];

        this._selectstartrow = [];
        this._selectstartcol = [];
        this._selectstartsubrow = [];
        this._selectstartpvt = [];

        this._selectendrow = [];
        this._selectendcol = [];
        this._selectendsubrow = [];
        this._selectendpvt = [];

        this._defaultSelect();
    };

    _pGrid._isIncludeSelectpos = function (cell, row)
    {
        var selects = this._selectinfo.getSelectCells(row);

        if (selects && selects[cell])
            return true;

        return false;
    };

    _pGrid._addSelectpos = function (cell, row, no_sort)
    {
        var select = this._selectinfo.selects;
        var rows = this._selectinfo.rows;

        if (!select[row + 2])
            select[row + 2] = [];

        select[row + 2][cell] = true;

        for (var i = 0, n = rows.length; i < n; i++)
        {
            if (rows[i] == row)
                return;
        }
        rows.push(row);

        if (!no_sort)
            rows.sort(function (a, b) { return a - b; });
    };

    _pGrid._delSelectpos = function (cell, row, adjust)
    {
        var select = this._selectinfo.selects;
        var rows = this._selectinfo.rows;
        var i, j, n;
        var rowLen;
        var cells;
        var exist;

        if (cell < 0)
        {
            if (nexacro._isArray(row))
            {
                rowLen = row.length;
                for (i = rowLen - 1; i >= 0; i--)
                {
                    if (adjust)
                    {
                        if (select.length > row[i] + 2)
                            select.splice(row[i] + 2, 1);
                    }
                    else
                    {
                        select[row[i] + 2] = undefined;
                    }

                    for (j = 0; j < rows.length; j++)
                    {
                        if (rows[j] == row[i])
                        {
                            rows.splice(j, 1);
                            break;
                        }
                    }
                }
            }
            else
            {
                if (adjust)
                {
                    if (select.length > row + 2)
                        select.splice(row + 2, 1);
                }
                else
                {
                    select[row + 2] = undefined;
                }

                for (j = 0; j < rows.length; j++)
                {
                    if (rows[j] == row)
                    {
                        rows.splice(j, 1);
                        break;
                    }
                }
            }
        }
        else
        {
            if (nexacro._isArray(row))
            {
                rowLen = row.length;

                for (i = rowLen - 1; i >= 0; i--)
                {
                    cells = select[row[i] + 2];

                    if (cells)
                        cells[cell] = false;

                    exist = false;
                    for (j = 0, n = cells.length; j < n; j++)
                    {
                        if (cells[j])
                        {
                            exist = true;
                            break;
                        }
                    }

                    if (!exist)
                    {
                        select[row + 2] = undefined;

                        for (j = 0; j < rows.length; j++)
                        {
                            if (rows[j] == row[i])
                            {
                                rows.splice(j, 1);
                                break;
                            }
                        }
                    }
                }
            }
            else
            {
                cells = select[row + 2];

                if (cells)
                    cells[cell] = false;

                exist = false;
                for (j = 0, n = cells.length; j < n; j++)
                {
                    if (cells[j])
                    {
                        exist = true;
                        break;
                    }
                }

                if (!exist)
                {
                    select[row + 2] = undefined;

                    for (j = 0; j < rows.length; j++)
                    {
                        if (rows[j] == row)
                        {
                            rows.splice(j, 1);
                            break;
                        }
                    }
                }
            }
        }
    };

    _pGrid._resetSelectStartEndRow = function ()
    {
        var select = this._selectinfo.selects;
        this._selectstartrow = [];
        this._selectendrow = [];

        for (var i = 0, n = select.length; i < n; i++)
        {
            if (select[i])
                this._applySelect(this._selectstartrow, this._selectendrow, i - 2);
        }

        this._p_selectstartrow = this._selectstartrow;
        this._p_selectendrow = this._selectendrow;

        if (!this._p_selectstartrow.length)
            this._p_selectstartrow = -9;
        if (!this._p_selectendrow.length)
            this._p_selectendrow = -9;
    };

    _pGrid._isMultiSelected = function ()
    {
        if (!this._curFormat || !this._curFormat._bodycells)
            return false;

        if (this._isSelectRowType())
        {
            if (this._selectinfo.rows.length > 1)
                return true;
        }
        else
        {
            if (this._selectinfo.rows.length > 1)
            {
                return true;
            }
            else if (this._selectinfo.rows.length == 1)
            {
                var cells = this._selectinfo.selects[this._selectinfo.rows[0] + 2];
                var cnt = 0;

                for (var i = 0, n = cells.length; i < n; i++)
                {
                    if (cells[i])
                        cnt++;
                    if (cnt > 1)
                        return true;
                }
            }
        }
        return false;
    };

    _pGrid._initSelect = function (row, cell, col, subrow, pvt)
    {
        cell = (cell !== undefined) ? cell : 0;
        col = (col !== undefined) ? col : 0;
        row = (row !== undefined) ? row : 0;
        subrow = (subrow !== undefined) ? subrow : 0;
        pvt = (pvt !== undefined) ? pvt : -9;

        this._resetSelect(row, cell, col, subrow, pvt);
    };

    _pGrid._resetSelect = function (row, cell, col, subrow, pvt)
    {
        var bcell = this._selectinfo.curcell;
        var bcol = this._selectinfo.curcol;
        var brow = this._selectinfo.curdsrow;
        var bsubrow = this._selectinfo.cursubrow;
        var bpvt = this._selectinfo.curpvt;

        cell = (cell !== undefined) ? cell : this._selectinfo.curcell;
        col = (col !== undefined) ? col : this._selectinfo.curcol;
        row = (row !== undefined) ? row : this._selectinfo.curdsrow;
        subrow = (subrow !== undefined) ? subrow : this._selectinfo.cursubrow;
        pvt = (pvt !== undefined) ? pvt : this._selectinfo.curpvt;

        if (this.getElement())
        {
            if (row >= 0 && cell < 0)
            {
                if (this._isSelectRowType())
                {
                    cell = 0;
                }
                else
                {
                    // 전체 인자가 음수가 아닌경우 -1로 selectedinfo 초기화 아님으로 판단
                    cell = col = subrow = 0;
                }
            }

            this._clrMultiSelect();
            this._multiselect = "none";
            this._setSelectedInfo(cell, col, row, subrow, pvt);
            this._ChangeSelect(cell, col, row, subrow, pvt, true, bcell, bcol, brow, bsubrow, bpvt, "body");
            this._refreshHead(true);
            this._refreshSumm(true);
        }
    };

    _pGrid._ChangeSelect = function (cell, col, row, subrow, pvt, bDataset, oldcell, oldcol, oldrow, oldsubrow, oldpvt, bandstr, evt_kind)
    {
        bDataset = bDataset || false;
        var selectmode = this._multiselect;

        var format = this._curFormat;

        if (!format || ((evt_kind == "lbuttondown" || evt_kind == "keydown") && this._setdataobj && this._setdataobj.succ == false))
        {
            this._setdataobj = null;
            this._setSelectedInfo(oldcell, oldcol, oldrow, oldsubrow, oldpvt);
            return false;
        }

        var cells, cellcnt, cellinfo, subrowslen = 0;
        var b_select_changed = false;
        var b_cellpos_changed = false;

        if (bandstr == "head")
        {
            cells = format._headcells;
            b_select_changed = (oldrow != row || oldcell != cell);

            if (format._headrows)
                subrowslen = format._headrows.length;
        }
        else if (bandstr == "summ" || bandstr == "summary")
        {
            cells = format._summcells;
            b_select_changed = (oldrow != row || oldcell != cell);

            if (format._summrows)
                subrowslen = format._summrows.length;
        }
        else
        {
            cells = format._bodycells;
            b_cellpos_changed = (oldrow != row || oldcell != cell);

            if (this._isSelectRowType())
                b_select_changed = (oldrow != row);
            else
                b_select_changed = (oldrow != row || oldcell != cell);

            if (format._bodyrows)
                subrowslen = format._bodyrows.length;
        }

        if (!cells)
        {
            this._setSelectedInfo(oldcell, oldcol, oldrow, oldsubrow, oldpvt);
            return false;
        }

        cellcnt = cells.length;
        cellinfo = cells[cell];

        var clear = false;

        /***** 음수일 경우 selection 해제 처리 부분 *****/
        if ((bandstr == "body" && row < 0) || cell < 0)
        {
            clear = (selectmode != "normal");

            this._clrMultiSelect();
            this._selectDraw(cell, col, row, subrow, pvt, bDataset, oldcell, oldcol, oldrow, oldsubrow, oldpvt, clear, []);
            this._selectinfo.area = [];
            this._defaultSelect();

            if (b_cellpos_changed)
                this.on_fire_oncellposchanged(this, cell, col, row, subrow, pvt, oldcell, oldcol, oldrow, oldsubrow, oldpvt, this._p_selectendcol, this._p_selectendpivot, this._p_selectendrow, this._p_selectendsubrow, this._p_selectstartcol, this._p_selectstartpivot, this._p_selectstartrow, this._p_selectstartsubrow);

            if (b_select_changed)
                this.on_fire_onselectchanged(this, cell, col, row, subrow, pvt, oldcell, oldcol, oldrow, oldsubrow, oldpvt, this._p_selectendcol, this._p_selectendpivot, this._p_selectendrow, this._p_selectendsubrow, this._p_selectstartcol, this._p_selectstartpivot, this._p_selectstartrow, this._p_selectstartsubrow);

            return true;
        }
        else if (!cellinfo)
        {
            this._setSelectedInfo(oldcell, oldcol, oldrow, oldsubrow, oldpvt);
            return false;
        }

        clear = (this._selectClear || clear);
        this._selectClear = false;

        var ctrlkey_change = false;

        if (selectmode == "ctrl")
        {
            if (this._p_selecttype == "multirow")
            {
                if (!this._isIncludeSelectpos(0, row) || (evt_kind == "func_selectmultirow"))   // ffunc_selectrow은 add만..)
                    ctrlkey_change = true;
            }
            if (this._p_selecttype == "multicell")
            {
                if (!this._isIncludeSelectpos(cell, row))
                    ctrlkey_change = true;
            }
        }

        /***** Dataset 반영 부분 *****/
        if (bDataset == false)
        {
            if (this._binddataset && bandstr == "body" && row >= 0 && (ctrlkey_change == true || oldrow != row))
            {
                this._userRowposChange = true;
                var row2 = this._binddataset._setRowPosition(row, 51);
                this._userRowposChange = false;

                if (row != row2)    // dataset에서 변경 취소
                {
                    if (row2 === undefined) // dataset에서 변경 취소
                    {
                        this._setSelectedInfo(oldcell, oldcol, oldrow, oldsubrow, oldpvt);
                        this._selectDraw(oldcell, oldcol, oldrow, oldsubrow, oldpvt, bDataset, cell, col, row, subrow, pvt, true, []);
                        return false;
                    }
                    else // rowposition이 canrowposchange에서 변경된 경우 newrow 변경
                    {
                        row = row2;
                    }
                }
            }
        }

        var _controlpoint_cell = this._selectinfo.ctrlpoint;
        var selectRows = [];
        var b_fire = false;
        var multiidx = 0;

        function makeClearRows(grid)
        {
            var select_rows = grid._selectinfo.rows;
            var j = 0;

            selectRows = [];

            for (var i = 0, n = select_rows.length; i < n; i++)
                selectRows[j++] = grid._dsRowToDispRow(select_rows[i]);

            return select_rows;
        }

        /***** Action 처리 부분 *****/
        if (selectmode == "none")
        {
            if (bandstr == "body")
            {
                if (this._isAreaSelect() || this._isMultiSelect())
                {
                    /***** 선택된 영역에 포함되어 있을 경우 처리 *****/
                    if (this._isIncludeSelectpos(cell, row))
                    {
                        if (evt_kind == "keydown" || evt_kind == "mousemove")
                        {
                            b_fire = true;
                        }
                        else // lbuttondown, undefined
                        {
                            _controlpoint_cell._set(cellinfo, row, subrowslen);
                            if (b_cellpos_changed)
                            {
                                this._applyCellSelection();
                                if (evt_kind == "lbuttondown")
                                    this.on_fire_oncellposchanged(this, cell, col, row, subrow, pvt, oldcell, oldcol, oldrow, oldsubrow, oldpvt, this._p_selectendcol, this._p_selectendpivot, this._p_selectendrow, this._p_selectendsubrow, this._p_selectstartcol, this._p_selectstartpivot, this._p_selectstartrow, this._p_selectstartsubrow);
                            }
                            return false;	// 여기서 return 후 lbuttonup에서 처리함.
                        }
                    }
                    else
                    {
                        if (evt_kind == "lbuttonup")
                            b_fire = true;
                    }

                    if (evt_kind == "mousemove")
                    {
                        this._is_drag_selecting = true;
                    }
                    else
                    {
                        selectRows = makeClearRows(this);
                        this._clrMultiSelect();

                        if (evt_kind != "lbuttonup")
                            _controlpoint_cell._set(cellinfo, row, subrowslen);
                    }
                }
                else
                {
                    this._clrMultiSelect();
                    _controlpoint_cell._set(cellinfo, row, subrowslen);
                }
            }
            else // head, summ
            {
                selectRows = makeClearRows(this);
                this._clrMultiSelect();
                _controlpoint_cell._set(cellinfo, row, subrowslen);
            }
            this._selectinfo.area = [];
        }
        else if (selectmode == "ctrl")
        {
            if (evt_kind != "mousemove")
                _controlpoint_cell._set(cellinfo, row, subrowslen);

            /***** 선택된 영역 toggle 처리(선택해제) *****/
            if (this._p_selecttype == "multirow")
            {
                if (ctrlkey_change == false && (evt_kind == "lbuttondown" || (evt_kind && evt_kind.indexOf("func") >= 0)))
                {
                    this._delMultirowSelectInfo(row);
                    this._delSelectpos(-1, row);
                    this._resetSelectStartEndRow();
                    this._selectDraw(cell, col, row, subrow, pvt, bDataset, oldcell, oldcol, oldrow, oldsubrow, oldpvt, clear, selectRows);
                    this._defaultSelect();

                    this.on_fire_onselectchanged(this, cell, col, row, subrow, pvt, oldcell, oldcol, oldrow, oldsubrow, oldpvt, this._p_selectendcol, this._p_selectendpivot, this._p_selectendrow, this._p_selectendsubrow, this._p_selectstartcol, this._p_selectstartpivot, this._p_selectstartrow, this._p_selectstartsubrow);
                    return true;
                }

                b_fire = true;
                multiidx = this._selectinfo.area.length;

                if (evt_kind == "mousemove")
                {
                    this._is_drag_selecting = true;
                    multiidx--;
                }
            }
            else if (this._p_selecttype == "multiarea")
            {
                multiidx = this._selectinfo.area.length;

                if (evt_kind == "mousemove")
                {
                    this._is_drag_selecting = true;
                    multiidx--;
                }
            }
        }
        else if (selectmode == "shift")
        {
            if (this._p_selecttype == "multiarea" || this._p_selecttype == "multirow")
                multiidx = this._selectinfo.area.length - 1;

            this._clrMultiSelect();
            clear = true;
        }

        /***** select cell type *****/
        if (this._isSelectRowType() == false)
        {
            if (b_select_changed)
                b_fire = true;

            if (this._isAreaSelect())    // area, multiarea select
            {
                this._applyAreaSelectPos(cell, row, multiidx, "area");
            }
            else
            {
                this._addSelectpos(cell, row);
                this._applySelect(this._selectstartrow, this._selectendrow, row);
                this._applySelect(this._selectstartcol, this._selectendcol, col);
                this._applySelect(this._selectstartsubrow, this._selectendsubrow, subrow);
            }
        }

        /***** select row type *****/
        else
        {
            if (b_select_changed)
                b_fire = true;

            if (this._isMultiSelect())
            {
                this._applyAreaSelectPos(cell, row, multiidx, "row");
            }
            else
            {
                for (var i = 0; i < cellcnt; i++)
                    this._addSelectpos(i, row);

                this._applySelect(this._selectstartrow, this._selectendrow, row);
            }
        }

        /***** apply property *****/
        this._defaultSelect();

        /***** apply screen *****/
        var b_draw = false;

        if (bDataset == false)
        {
            if (this._binddataset && bandstr == "body" && row >= 0 && (ctrlkey_change == true || oldrow != row))
            {
                this._rowposition = row;
                b_draw = true;
            }
            else
            {
                if (clear == true)
                    b_draw = true;
                else if (b_fire == true)
                    b_draw = true;
            }
        }
        else
        {
            clear = (this._isMultiSelect() || this._isAreaSelect());
            b_draw = true;
        }

        if (b_draw)
            this._selectDraw(cell, col, row, subrow, pvt, bDataset, oldcell, oldcol, oldrow, oldsubrow, oldpvt, clear, selectRows, evt_kind);
        else if (b_cellpos_changed)
            this._applyCellSelection();

        /***** fire event *****/
        if (b_cellpos_changed && evt_kind != "func_area1")
            this.on_fire_oncellposchanged(this, cell, col, row, subrow, pvt, oldcell, oldcol, oldrow, oldsubrow, oldpvt, this._p_selectendcol, this._p_selectendpivot, this._p_selectendrow, this._p_selectendsubrow, this._p_selectstartcol, this._p_selectstartpivot, this._p_selectstartrow, this._p_selectstartsubrow);

        if (b_fire && evt_kind != "func_area1")
            this.on_fire_onselectchanged(this, cell, col, row, subrow, pvt, oldcell, oldcol, oldrow, oldsubrow, oldpvt, this._p_selectendcol, this._p_selectendpivot, this._p_selectendrow, this._p_selectendsubrow, this._p_selectstartcol, this._p_selectstartpivot, this._p_selectstartrow, this._p_selectstartsubrow);

        return true;
    };

    _pGrid._applyAreaSelectPos = function (cell, row, idx, type)
    {
        var format = this._curFormat;
        var cells, subrowsLen;
        var bodycells = [], bodycellslen = 0, bodyrowslen = 0, headcells = [], headcellslen = 0, headrowslen = 0, summcells = [], summcellslen = 0, summrowslen = 0;

        if (format._bodycells)
        {
            bodycells = format._bodycells;
            bodycellslen = bodycells.length;
            bodyrowslen = format._bodyrows.length;
        }
        if (format._headcells)
        {
            headcells = format._headcells;
            headcellslen = headcells.length;
            headrowslen = format._headrows.length;
        }
        if (format._summcells)
        {
            summcells = format._summcells;
            summcellslen = summcells.length;
            summrowslen = format._summrows.length;
        }

        if (row == -2)
        {
            cells = summcells;
            subrowsLen = summrowslen;
        }
        else if (row == -1)
        {
            cells = headcells;
            subrowsLen = headrowslen;
        }
        else
        {
            cells = bodycells;
            subrowsLen = bodyrowslen;
        }

        var ctrlpoint = this._selectinfo.ctrlpoint;    // 기준이되는 cell
        var cellinfo = cells[cell];                    // 마지막으로 선택된 cell
        var begcol, endcol, begrow, endrow, begsubrow = [], endsubrow = [], last;

        // 선택이 거꾸로 되는경우 시작과 끝을 반전
        //      begrow = Math.min(row, ctrlpoint.row);
        //      endrow = Math.max(row, ctrlpoint.row);
        begcol = Math.min(ctrlpoint.col, cellinfo._col);
        endcol = Math.max((ctrlpoint.col + ctrlpoint.colspan - 1), (cellinfo._col + cellinfo._colspan - 1));

        if (ctrlpoint.row < row)    // 위에서 아래로 선택
        {
            begrow = ctrlpoint.row;
            endrow = row;

            last = endrow - begrow;

            begsubrow[0] = ctrlpoint.subrow;
            endsubrow[0] = ctrlpoint.subrowslen - 1;
            begsubrow[last] = 0;
            endsubrow[last] = cellinfo._row + cellinfo._rowspan - 1;
        }
        else if (ctrlpoint.row > row)   // 아래에서 위로 선택
        {
            begrow = row;
            endrow = ctrlpoint.row;

            last = endrow - begrow;

            begsubrow[0] = cellinfo._row;
            endsubrow[0] = subrowsLen - 1;
            begsubrow[last] = 0;
            endsubrow[last] = ctrlpoint.subrow + ctrlpoint.rowspan - 1;
        }
        else
        {
            begrow = endrow = row;

            begsubrow[0] = Math.min(cellinfo._row, ctrlpoint.subrow);
            endsubrow[0] = Math.max(cellinfo._row + cellinfo._rowspan - 1, ctrlpoint.subrow + ctrlpoint.rowspan - 1);
        }

        // 첫번째 row와 마지막 row 사이의 row들
        var ii;
        for (var i = begrow + 1; i < endrow; i++)
        {
            ii = i - begrow;
            begsubrow[ii] = 0;

            if (i == -1)
                endsubrow[ii] = headrowslen - 1;
            else
                endsubrow[ii] = bodyrowslen - 1;
        }

        var areainfo;

        if (type == "area")
        {
            // merge cell이 존재하는 경우 영역 재계산
            if (begrow >= 0 || begrow == endrow)
            {
                areainfo = this._adjustMergeArea(cells, begcol, endcol, begrow, endrow, begsubrow, endsubrow);
            }
            else
            {
                var bsubrow, esubrow;
                var prevbegcol = begcol, prevendcol = endcol;
                var summbegsubrow;
                var summendsubrow;
                var headbegsubrow;
                var headendsubrow;

                while (true)
                {
                    bsubrow = [].concat(begsubrow);
                    esubrow = [].concat(endsubrow);

                    if (begrow == -2)
                    {
                        summbegsubrow = bsubrow.splice(0, 1);
                        summendsubrow = esubrow.splice(0, 1);
                        headbegsubrow = bsubrow.splice(0, 1);
                        headendsubrow = esubrow.splice(0, 1);

                        areainfo = this._adjustMergeArea(summcells, prevbegcol, prevendcol, -2, -2, summbegsubrow, summendsubrow);

                        prevbegcol = areainfo.begcol;
                        prevendcol = areainfo.endcol;

                        areainfo = this._adjustMergeArea(headcells, prevbegcol, prevendcol, -1, -1, headbegsubrow, headendsubrow);

                        if (prevbegcol != areainfo.begcol || prevendcol != areainfo.endcol)
                        {
                            prevbegcol = areainfo.begcol;
                            prevendcol = areainfo.endcol;
                            continue;
                        }
                    }
                    else if (begrow == -1)
                    {
                        headbegsubrow = bsubrow.splice(0, 1);
                        headendsubrow = esubrow.splice(0, 1);

                        areainfo = this._adjustMergeArea(headcells, prevbegcol, prevendcol, -1, -1, headbegsubrow, headendsubrow);

                        prevbegcol = areainfo.begcol;
                        prevendcol = areainfo.endcol;
                    }

                    if (endrow >= 0)
                        areainfo = this._adjustMergeArea(bodycells, prevbegcol, prevendcol, 0, endrow, bsubrow, esubrow);

                    if (areainfo)
                    {
                        if (prevbegcol != areainfo.begcol || prevendcol != areainfo.endcol)
                        {
                            prevbegcol = areainfo.begcol;
                            prevendcol = areainfo.endcol;
                            continue;
                        }
                    }
                    break;
                }

                if (areainfo)
                {
                    areainfo.begrow = begrow;
                    areainfo.begsubrow = begsubrow;
                    areainfo.endsubrow = endsubrow;
                }
            }
        }
        else
        {
            areainfo = this._adjustRowArea(begrow, endrow);
        }

        this._selectinfo.area[idx] = areainfo;

        var select_area = this._selectinfo.area;
        var select_area_len = select_area.length;

        this._clrMultiSelect();
        var cell_scol, cell_ecol, cell_ssubrow, cell_esubrow;
        var a, j, k;
        var cellsLen;

        if (type == "area")
        {
            for (a = 0; a < select_area_len; a++)
            {
                begcol = select_area[a].begcol;
                endcol = select_area[a].endcol;
                begrow = select_area[a].begrow;
                endrow = select_area[a].endrow;
                begsubrow = select_area[a].begsubrow;
                endsubrow = select_area[a].endsubrow;

                this._selectstartrow[a] = begrow;
                this._selectendrow[a] = endrow;
                this._selectstartcol[a] = begcol;
                this._selectendcol[a] = endcol;
                this._selectstartsubrow[a] = begsubrow[0];
                this._selectendsubrow[a] = endsubrow[endsubrow.length - 1];

                for (i = begrow, j = 0; i <= endrow; i++, j++)
                {
                    if (i == -2)
                    {
                        cells = summcells;
                        cellsLen = summcellslen;
                    }
                    else if (i == -1)
                    {
                        cells = headcells;
                        cellsLen = headcellslen;
                    }
                    else
                    {
                        cells = bodycells;
                        cellsLen = bodycellslen;
                    }

                    for (k = 0; k < cellsLen; k++)
                    {
                        cell_scol = cells[k]._col;
                        cell_ecol = cells[k]._col + cells[k]._colspan - 1;
                        cell_ssubrow = cells[k]._row;
                        cell_esubrow = cells[k]._row + cells[k]._rowspan - 1;

                        if (cell_scol >= begcol && cell_ecol <= endcol && cell_ssubrow >= begsubrow[j] && cell_esubrow <= endsubrow[j])
                            this._addSelectpos(k, i);
                    }
                }
            }
        }
        else // multirow
        {
            for (a = 0; a < select_area_len; a++)
            {
                begrow = select_area[a].begrow;
                endrow = select_area[a].endrow;

                for (i = begrow, j = 0; i <= endrow; i++, j++)
                {
                    if (i == -2)
                        cellsLen = summcellslen;
                    else if (i == -1)
                        cellsLen = headcellslen;
                    else
                        cellsLen = bodycellslen;

                    if (cellsLen == 0)
                        continue;

                    for (k = 0; k < cellsLen; k++)
                        this._addSelectpos(k, i, true);

                    this._applySelect(this._selectstartrow, this._selectendrow, i);
                }
            }

            var rows = this._selectinfo.rows;
            rows.sort(function (a, b) { return a - b; });
        }
    };

    _pGrid._delMultirowSelectInfo = function (row)
    {
        var area = this._selectinfo.area;
        var area_len = area.length;

        for (var i = 0; i < area_len; i++)
        {
            if (area[i].begrow == area[i].endrow && area[i].begrow == row)
            {
                area.splice(i, 1);
                break;
            }
            else if (area[i].begrow == row && area[i].endrow != row)
            {
                area[i].begrow++;
                break;
            }
            else if (area[i].endrow == row && area[i].begrow != row)
            {
                area[i].endrow--;
                break;
            }
            else if (area[i].begrow < row && area[i].endrow > row)
            {
                var endrow = area[i].endrow;
                area[i].endrow = row - 1;
                var newarea = this._adjustRowArea(row + 1, endrow);
                area.splice(i + 1, 0, newarea);
                break;
            }
        }
    };

    _pGrid._delOverSelectInfo = function ()
    {
        // 현재시점의 rowcount를 넘어가는 selectinfo의 rows, area를 제거

        var rows = this._selectinfo.rows;
        var max_rowidx = this._getLastGridRowIdx();

        for (var i = rows.length - 1, row, isDeleted; i >= 0; i--)
        {
            row = rows[i];
            if (row > max_rowidx)
            {
                isDeleted = true;
                this._delMultirowSelectInfo(row);
                this._delSelectpos(-1, row);
            }
            else
            {
                break;
            }
        }

        if (isDeleted)
        {
            this._resetSelectStartEndRow();
            this._defaultSelect();
        }
    };

    _pGrid._adjustRowArea = function (begrow, endrow)
    {
        return { begcol: -1, endcol: -1, begrow: begrow, endrow: endrow, begsubrow: [], endsubrow: [] };
    };

    _pGrid._adjustMergeArea = function (cells, begcol, endcol, begrow, endrow, begsubrow, endsubrow)
    {
        var last = endrow - begrow;
        var cells_len = cells.length;
        var cell_scol, cell_ecol, cell_ssubrow, cell_esubrow;
        var update, rows_len = begsubrow.length;

        for (var i = 0; i < cells_len; i++)
        {
            cell_scol = cells[i]._col;
            cell_ecol = cells[i]._col + cells[i]._colspan - 1;
            cell_ssubrow = cells[i]._row;
            cell_esubrow = cells[i]._row + cells[i]._rowspan - 1;

            update = false;

            for (var j = 0; j < rows_len; j++)
            {
                if (((begcol <= cell_scol && endcol >= cell_scol) || (begcol <= cell_ecol && endcol >= cell_ecol) || (begcol > cell_scol && endcol < cell_ecol)) &&
                    ((begsubrow[j] <= cell_ssubrow && endsubrow[j] >= cell_ssubrow) || (begsubrow[j] <= cell_esubrow && endsubrow[j] >= cell_esubrow) || (begsubrow[j] > cell_ssubrow && endsubrow[j] < cell_esubrow)))
                {
                    if (begcol > cell_scol)
                    {
                        begcol = cell_scol;
                        update = true;
                    }
                    if (endcol < cell_ecol)
                    {
                        endcol = cell_ecol;
                        update = true;
                    }

                    if (j == 0) // 첫번째 row
                    {
                        if (begsubrow[0] > cell_ssubrow)
                        {
                            begsubrow[0] = cell_ssubrow;
                            update = true;
                        }
                    }

                    if (j == last) // 마지막 row
                    {
                        if (endsubrow[last] < cell_esubrow)
                        {
                            endsubrow[last] = cell_esubrow;
                            update = true;
                        }
                    }

                    if (update == true) // area가 변경되면 처음부터 다시 체크
                    {
                        i = 0;
                        break;
                    }
                }
            }
        }

        return { begcol: begcol, endcol: endcol, begrow: begrow, endrow: endrow, begsubrow: begsubrow, endsubrow: endsubrow };
    };

    _pGrid._defaultSelect = function ()
    {
        this._p_selectstartrow = this._selectstartrow;
        this._p_selectstartcol = this._selectstartcol;
        this._p_selectstartsubrow = this._selectstartsubrow;
        this._p_selectstartpivot = this._selectstartpvt;
        this._p_selectendrow = this._selectendrow;
        this._p_selectendcol = this._selectendcol;
        this._p_selectendsubrow = this._selectendsubrow;
        this._p_selectendpivot = this._selectendpvt;

        if (!this._p_selectstartrow.length)
        {
            this._p_selectstartrow = -9;
        }
        if (!this._p_selectstartcol.length)
        {
            this._p_selectstartcol = -1;
        }
        if (!this._p_selectstartsubrow.length)
        {
            this._p_selectstartsubrow = -1;
        }
        if (!this._p_selectstartpivot.length)
        {
            this._p_selectstartpivot = -9;
        }
        if (!this._p_selectendrow.length)
        {
            this._p_selectendrow = -9;
        }
        if (!this._p_selectendcol.length)
        {
            this._p_selectendcol = -1;
        }
        if (!this._p_selectendsubrow.length)
        {
            this._p_selectendsubrow = -1;
        }
        if (!this._p_selectendpivot.length)
        {
            this._p_selectendpivot = -9;
        }
    };

    _pGrid._dsRowToDispRow = function (datasetRowidx, bCalcScroll)
    {
        var row;
        if (this._hasTree)
            row = this._getTreeRowPosition(datasetRowidx);
        else
            row = datasetRowidx;

        if (bCalcScroll)
            row -= this._getBodyBegRowPos(row);

        return row;
    };

    _pGrid._jumpCurrentRow = function (rowidx)
    {
        if (rowidx < 0) // selector scroll
            return this._begrowpos;

        var topPos = this._toprowpos[0];
        var vscroll = this._vscrollmng;
        var page_spos = this._getBodyBegRowPos(rowidx);

        if (this._lbuttondown_proc == false)
        {
            if (rowidx <= topPos)
            {
                if (!this._select_noscroll && vscroll)
                    vscroll.setRowPos(rowidx);

                page_spos = this._getBodyBegRowPos(rowidx);
            }
            else if (rowidx > (topPos + this._p_pagerowcount - 1))
            {
                var gap = (this._p_pagerowcount > 0) ? this._pagerowcnt - this._p_pagerowcount : 1;

                if (!this._select_noscroll && vscroll)
                    vscroll.setRowPos(rowidx - this._pagerowcnt + 1 + gap);

                page_spos = this._getBodyBegRowPos(rowidx);
            }
            else
            {
                if (this._isRemainAreaScroll())
                {
                    if (!this._select_noscroll && vscroll)
                        vscroll.setRowPos(rowidx);

                    page_spos = this._getBodyBegRowPos(rowidx);
                }
            }
        }
        return page_spos;
    };

    _pGrid._getBodyBegRowPos = function (rowidx)    // allrows 기준
    {
        if (this._fixed_rowcnt > 0)
        {
            if (this._fixed_endrow >= rowidx)
                return this._fixed_startrow;

            return this._begrowpos - (this._fixed_rowcnt - this._fixed_startrow);
        }
        return this._begrowpos;
    };

    _pGrid._clearRows = function (oldrows)
    {
        if (oldrows.length > 0)
        {
            for (var i = 0, n = oldrows.length; i < n; i++)
            {
                if (oldrows[i] == -2)
                {
                    this._refreshSumm(true);
                }
                else if (oldrows[i] == -1)
                {
                    this._refreshHead(true);
                }
                else
                    this._refreshBodyRow(oldrows[i] - this._getBodyBegRowPos(oldrows[i]));
            }
            return true;
        }
        return false;
    };

    _pGrid._selectDraw = function (afterCell, afterCol, afterRow, afterSubrow, afterPvt, bDataset, beforeCell, beforeCol, beforeRow, beforeSubrow, beforePvt, bAllRowDraw, oldrows, kind)
    {
        var oldPos = this._dsRowToDispRow(beforeRow);
        var newPos = this._dsRowToDispRow(afterRow);

        this._setSelectedInfo(null, null, afterRow, null, null);

        var bBodyRowDraw = false;
        var bHeadRowDraw = false;
        var bSummRowDraw = false;
        var exprbindcells = this._getUseBindExprProp("body");
        if (!exprbindcells)
            exprbindcells = [];

        if (exprbindcells.length)
        {
            bBodyRowDraw = this._expr_allrow_update_prop || this._expr_allrow_update_style;
        }
        if (this._isUseBindExprStyle("head") || this._getUseBindExprProp("head") || newPos == -1 || oldPos == -1)
        {
            bHeadRowDraw = true;
        }
        if (this._isUseBindExprStyle("summ") || this._getUseBindExprProp("summ") || newPos == -2 || oldPos == -2)
        {
            bSummRowDraw = true;
        }

        var i;

        if (this._isSelectRowType())
        {
            if (newPos < 0 && (kind && kind.indexOf("func") < 0))
            {
                if (bAllRowDraw)
                {
                    if (!this._clearRows(oldrows))
                    {
                        this._refreshBody(true, false);
                    }
                }
                else
                {
                    this._refreshBodyRow(oldPos - this._getBodyBegRowPos(oldPos), undefined, undefined, true);

                    if (bBodyRowDraw)
                    {
                        for (i = 0; i < exprbindcells.length; i++)
                        {
                            this._refreshCell("body", exprbindcells[i], undefined, undefined, undefined, true);
                        }
                    }
                }

                if (bHeadRowDraw)
                    this._refreshHead(true);
                if (bSummRowDraw)
                    this._refreshSumm(true);
            }
            else if (newPos != oldPos)
            {
                this._jumpCurrentRow(newPos);

                if (this._isMultiSelect())
                {
                    this._refreshBody(true, !bAllRowDraw);

                    if (bHeadRowDraw)
                        this._refreshHead(true);
                    if (bSummRowDraw)
                        this._refreshSumm(true);
                }
                else
                {
                    if (bAllRowDraw)
                    {
                        if (!this._clearRows(oldrows))
                        {
                            this._refreshBody(true, true);
                        }
                        else
                        {
                            this._refreshBodyRow(newPos - this._getBodyBegRowPos(newPos), undefined, undefined, true);

                            if (bBodyRowDraw)
                            {
                                for (i = 0; i < exprbindcells.length; i++)
                                {
                                    this._refreshCell("body", exprbindcells[i], undefined, undefined, undefined, true);
                                }
                            }
                        }
                    }
                    else
                    {
                        this._refreshBodyRow(oldPos - this._getBodyBegRowPos(oldPos), undefined, undefined, true);
                        this._refreshBodyRow(newPos - this._getBodyBegRowPos(newPos), undefined, undefined, true);

                        if (bBodyRowDraw)
                        {
                            for (i = 0; i < exprbindcells.length; i++)
                            {
                                this._refreshCell("body", exprbindcells[i], undefined, undefined, undefined, true);
                            }
                        }
                    }

                    if (bHeadRowDraw)
                        this._refreshHead(true);
                    if (bSummRowDraw)
                        this._refreshSumm(true);
                }
            }
            else
            {
                if (this._isMultiSelect())
                {
                    this._refreshBody(true, !bAllRowDraw);

                    if (bHeadRowDraw)
                        this._refreshHead(true);
                    if (bSummRowDraw)
                        this._refreshSumm(true);
                }
            }
        }
        else // cell type
        {
            if (newPos < 0 && (kind && kind.indexOf("func") < 0))
            {
                if (bAllRowDraw)
                {
                    if (!this._clearRows(oldrows))
                    {
                        this._refreshBody(true, false);
                    }
                }
                else
                {
                    this._refreshBodyCell(beforeCell, oldPos - this._getBodyBegRowPos(oldPos), true);

                    if (bBodyRowDraw)
                    {
                        for (i = 0; i < exprbindcells.length; i++)
                        {
                            this._refreshCell("body", exprbindcells[i], undefined, undefined, undefined, true);
                        }
                    }
                }

                if (bHeadRowDraw)
                    this._refreshHead(true);
                if (bSummRowDraw)
                    this._refreshSumm(true);
            }
            else if (newPos != oldPos || afterCell != beforeCell)
            {
                if (kind != "selectorsizing")
                {
                    this._jumpCurrentRow(newPos);
                    var cellobj;

                    if (newPos == -1)
                        cellobj = this._getCurrentHeadCell(-1);
                    else if (newPos == -2)
                        cellobj = this._getCurrentSummCell(-1);
                    else
                        cellobj = this._getCurrentBodyCell(-1, -1);

                    if (cellobj)
                    {
                        var area = cellobj._refinfo._area;
                        var select_ctrl = this._select_ctrl;

                        if (select_ctrl && select_ctrl._is_tracking)
                        {
                            if (area == "body")
                            {
                                cellobj.parent._showfull(cellobj);
                            }
                            else if (area == "left")
                            {
                                if (this._hscrollmng)
                                    this._hscrollmng.setPos(0);
                            }
                            else
                            {
                                var scroll_max = this._getScollMaxLeft();

                                if (this._hscrollmng)
                                    this._hscrollmng.setPos(scroll_max);
                            }
                        }
                        else if (!kind)
                        {
                            cellobj.parent._showfull(cellobj);
                        }
                        else if (kind == "keydown")
                        {
                            cellobj._showfull(true);
                        }
                    }
                }

                if (this._isAreaSelect())
                {
                    if (kind == "selectorsizing")
                    {
                        if (nexacro._OS == "Android" && (nexacro._Browser == "Safari" || nexacro._Browser == "MobileSafari"))  // dragselect중 이벤트가 멈춰 touchend가 나오지않음. 비동기로 처리.
                        {
                            nexacro._OnceCallbackTimer.callonce(this, function ()
                            {
                                this._refreshBody(true, !bAllRowDraw);
                            }, 10);
                        }
                        else
                        {
                            this._refreshBody(true, !bAllRowDraw);
                        }
                    }
                    else
                    {
                        this._refreshBody(true, !bAllRowDraw);

                        if (bHeadRowDraw)
                            this._refreshHead(true);
                        if (bSummRowDraw)
                            this._refreshSumm(true);
                    }
                }
                else
                {
                    if (bAllRowDraw)
                    {
                        this._clearRows(oldrows);
                        this._refreshBody(true, !bAllRowDraw);
                    }
                    else
                    {
                        this._refreshBodyCell(beforeCell, oldPos - this._getBodyBegRowPos(oldPos), true);
                        this._refreshBodyCell(afterCell, newPos - this._getBodyBegRowPos(newPos), true);

                        if (bBodyRowDraw)
                        {
                            for (i = 0; i < exprbindcells.length; i++)
                            {
                                this._refreshCell("body", exprbindcells[i], undefined, undefined, undefined, true);
                            }
                        }
                    }

                    if (bHeadRowDraw)
                        this._refreshHead(true);
                    if (bSummRowDraw)
                        this._refreshSumm(true);
                }
            }
            else
            {
                if (this._isAreaSelect())
                {
                    if (kind == "selectorsizing")
                    {
                        if (nexacro._OS == "Android" && (nexacro._Browser == "Safari" || nexacro._Browser == "MobileSafari"))  // dragselect중 이벤트가 멈춰 touchend가 나오지않음. 비동기로 처리.
                        {
                            nexacro._OnceCallbackTimer.callonce(this, function ()
                            {
                                this._refreshBody(true, !bAllRowDraw);
                            }, 10);
                        }
                        else
                        {
                            this._refreshBody(true, !bAllRowDraw);
                        }
                    }
                    else
                    {
                        this._refreshBody(true, !bAllRowDraw);

                        if (bHeadRowDraw)
                            this._refreshHead(true);
                        if (bSummRowDraw)
                            this._refreshSumm(true);
                    }
                }
                else if (this._isMultiSelect())
                {
                    if (bAllRowDraw)
                    {
                        this._clearRows(oldrows);
                        this._refreshBody(true, !bAllRowDraw);
                    }
                    else
                    {
                        this._refreshBodyCell(afterCell, newPos - this._getBodyBegRowPos(newPos), true);

                        if (bBodyRowDraw)
                        {
                            for (i = 0; i < exprbindcells.length; i++)
                            {
                                this._refreshCell("body", exprbindcells[i], undefined, undefined, undefined, true);
                            }
                        }
                    }

                    if (bHeadRowDraw)
                        this._refreshHead(true);
                    if (bSummRowDraw)
                        this._refreshSumm(true);
                }
            }
        }

        this._adjustOverlayControls(false);
        this._updateSelector();
        this._applySelection();
        this._applyCellSelection();
    };

    _pGrid.redrawExprCell = function (band)
    {
        var exprbindcells;
        var i;

        if (!band)
        {
            if (exprbindcells = this._getUseBindExprFullProp("head"))
            {
                for (i = 0; i < exprbindcells.length; i++)
                    this._refreshCell("head", exprbindcells[i]);
            }
            if (exprbindcells = this._getUseBindExprFullProp("body"))
            {
                for (i = 0; i < exprbindcells.length; i++)
                    this._refreshCell("body", exprbindcells[i]);
            }
            if (exprbindcells = this._getUseBindExprFullProp("summary"))
            {
                for (i = 0; i < exprbindcells.length; i++)
                    this._refreshCell("summary", exprbindcells[i]);
            }
        }
        else
        {
            switch (band)
            {
                case "head":
                case "body":
                case "summary":
                    if (exprbindcells = this._getUseBindExprFullProp(band))
                    {
                        for (i = 0; i < exprbindcells.length; i++)
                            this._refreshCell(band, exprbindcells[i]);
                    }
                    break;
            }
        }
    };

    _pGrid._isUseBindExprStyle = function (bandstr)
    {
        if (this._is_use_bind_expr_style[bandstr] !== null)
            return this._is_use_bind_expr_style[bandstr];

        // 현재 cssclass 만 expr 사용 가능.
        var retn = this._is_use_bind_expr_style[bandstr] = !!this._getUseBindExprProp(bandstr, "cssclass");

        if (bandstr == "body" && retn)
            this._expr_allrow_update_style = true;

        return !!retn;
    };

    _pGrid._getUseBindExprProp = function (bandstr, propname)  // refresh를 위하여 갱신되야하는 cell의 집합.
    {
        var band;
        var cells;
        var format = this._curFormat;

        if (!format)
            return null;

        if (bandstr == "summary")
            bandstr = "summ";

        if (!propname)
        {
            if (this._use_bind_expr_cells[bandstr] !== null)
                return this._use_bind_expr_cells[bandstr];

            this._use_bind_expr_cells[bandstr] = undefined;
        }

        if (bandstr == "body")
        {
            band = this._bodyBand;
            cells = format._bodycells;
        }
        else if (bandstr == "head")
        {
            band = this._headBand;
            cells = format._headcells;
        }
        else
        {
            band = this._summBand;
            cells = format._summcells;
        }

        if (!cells)
            return null;

        var i, j, n, nn;

        if (band)
        {
            var key, property_map;

            if (propname)
            {
                var retn = [];

                for (i = 0, n = cells.length; i < n; i++)
                {
                    if (cells[i][propname] && cells[i][propname]._bindtype > 0)
                    {
                        retn.push(i);
                    }
                }

                if (retn.length > 0)
                    return retn;
                else
                    return undefined;
            }
            else
            {
                if (bandstr == "body")
                {
                    for (i = 0, n = cells.length; i < n; i++)
                    {
                        property_map = cells[i]._property_map;

                        for (j = 0, nn = property_map.length; j < nn; j++)
                        {
                            key = property_map[j][nexacro._CELLINFO_PMAP_PROPNAME];

                            // body일 경우 bind는 rowposition과 고정 매핑되므로 expr만 담음.
                            if (cells[i][key] && (cells[i][key]._bindtype == 2 || (key == "expr" && cells[i][key]._value)))
                            {
                                this._expr_allrow_update_prop = true;

                                if (property_map[j][nexacro._CELLINFO_PMAP_STYLE] == true) // style
                                {
                                    this._is_use_bind_expr_style["body"] = true;
                                    this._expr_allrow_update_style = true;

                                    if (this._p_cellexprupdatecondition != "all")
                                        continue;
                                }
                                else
                                {
                                    if (this._p_cellexprupdatecondition == "none")
                                        continue;
                                    if (this._p_cellexprupdatecondition == "celltext" && key != "text" && key != "expr")
                                        continue;
                                }

                                if (this._use_bind_expr_cells["body"] == undefined)
                                    this._use_bind_expr_cells["body"] = [];

                                this._use_bind_expr_cells["body"].push(i);
                                break;
                            }
                        }
                    }
                }
                else
                {
                    for (i = 0, n = cells.length; i < n; i++)
                    {
                        property_map = cells[i]._property_map;

                        for (j = 0, nn = property_map.length; j < nn; j++)
                        {
                            key = property_map[j][nexacro._CELLINFO_PMAP_PROPNAME];

                            if (cells[i][key] && (cells[i][key]._bindtype > 0 || key == "expr"))
                            {
                                if (property_map[j][nexacro._CELLINFO_PMAP_STYLE] == true)
                                {
                                    this._is_use_bind_expr_style[bandstr] = true;
                                }

                                if (this._use_bind_expr_cells[bandstr] == undefined)
                                    this._use_bind_expr_cells[bandstr] = [];

                                this._use_bind_expr_cells[bandstr].push(i);
                                break;
                            }
                        }
                    }
                }
            }
        }
        return this._use_bind_expr_cells[bandstr];
    };

    _pGrid._getUseBindExprFullProp = function (bandstr)  // refresh를 위하여 갱신되야하는 cell의 집합._p_cellexprupdatecondition 체크안함.
    {
        var band;
        var cells;
        var format = this._curFormat;

        if (!format)
            return null;

        if (bandstr == "summary")
            bandstr = "summ";

        if (bandstr == "body")
        {
            band = this._bodyBand;
            cells = format._bodycells;
        }
        else if (bandstr == "head")
        {
            band = this._headBand;
            cells = format._headcells;
        }
        else
        {
            band = this._summBand;
            cells = format._summcells;
        }

        var _use_bind_expr_cells = [];
        var i, j, n, nn;

        if (band)
        {
            var key, property_map;

            if (bandstr == "body")
            {
                for (i = 0, n = cells.length; i < n; i++)
                {
                    property_map = cells[i]._property_map;

                    for (j = 0, nn = property_map.length; j < nn; j++)
                    {
                        key = property_map[j][nexacro._CELLINFO_PMAP_PROPNAME];

                        // body일 경우 bind는 rowposition과 고정 매핑되므로 expr만 담음.
                        if (cells[i][key] && (cells[i][key]._bindtype == 2 || key == "expr"))
                        {
                            _use_bind_expr_cells.push(i);
                            break;
                        }
                    }
                }
            }
            else
            {
                for (i = 0, n = cells.length; i < n; i++)
                {
                    property_map = cells[i]._property_map;

                    for (j = 0, nn = property_map.length; j < nn; j++)
                    {
                        key = property_map[j][nexacro._CELLINFO_PMAP_PROPNAME];

                        if (cells[i][key] && (cells[i][key]._bindtype > 0 || key == "expr"))
                        {
                            _use_bind_expr_cells.push(i);
                            break;
                        }
                    }
                }
            }
        }

        return _use_bind_expr_cells;
    };

    _pGrid._clearBindTypeFlag = function ()
    {
        this._use_bind_expr_cells.body = null;
        this._use_bind_expr_cells.head = null;
        this._use_bind_expr_cells.summ = null;
        this._is_use_bind_expr_style.body = null;
        this._is_use_bind_expr_style.head = null;
        this._is_use_bind_expr_style.summ = null;
        this._expr_allrow_update_prop = false;
        this._expr_allrow_update_style = false;
        this._flush_cell_oldrow = undefined;
        this._flush_cell_oldcell = undefined;
    };

    _pGrid._toggleVal = function (datarow, cellinfo)
    {
        if (!cellinfo)
            return false;

        var v = this._getCheck(cellinfo._col, datarow, cellinfo._row);
        var truevalue = cellinfo._getAttrValue(cellinfo["_p_checkboxtruevalue"], datarow);
        if (truevalue !== null && truevalue != undefined)
        {
            truevalue = truevalue.toString();
        }
        var falsevalue = cellinfo._getAttrValue(cellinfo["_p_checkboxfalsevalue"], datarow);
        if (falsevalue !== null && falsevalue != undefined)
        {
            falsevalue = falsevalue.toString();
        }
        var ischecked;
        if (truevalue != null)
        {
            if (falsevalue != null)
            {
                if (v === falsevalue || v === undefined)
                {
                    ischecked = false;
                }
                else if (v === truevalue)
                {
                    ischecked = true;
                }
            }
            else
            {
                if (v === truevalue)
                {
                    ischecked = true;
                }
                else
                    ischecked = false;
            }
        }
        else
        {
            if (falsevalue != null) // falsevalue only
            {
                if (v === this.falsevalue)
                {
                    ischecked = false;
                }
                else
                    ischecked = true;

            }
            else // no both
            {
                ischecked = nexacro._toBoolean(v);
            }
        }
        if (ischecked)
            v = nexacro._isNull(falsevalue) ? 0 : falsevalue;
        else
            v = nexacro._isNull(truevalue) ? 1 : truevalue;

        //v = nexacro._toBoolean(v);
        //v = (v) ? 0 : 1;

        //if (cellinfo.text._bindtype == 1)
        {
            this._dsEventOccured = true;
            //var retn = this._binddataset.setColumn(datarow, cellinfo.text._bindexpr, v);
            var retn = this._setCheck(cellinfo._col, datarow, cellinfo._row, v, cellinfo._getAttrValue(cellinfo._p_checkboxfalsevalue, datarow));
            if (this._env._p_enableaccessibility)
            {
                var cellobj = this._getAccessibilityCurrentCell();
                if (cellobj)
                    cellobj._setAccessibilityStatChecked(nexacro._toBoolean(v));
            }
            this._dsEventOccured = false;
            return retn;
        }
        return false;
    };

    _pGrid._selectVal = function (datarow, cellinfo)
    {
        if (!cellinfo)
            return false;

        var v = cellinfo.radioitemcodevalue;

        if (cellinfo.text._bindtype == 1)
        {
            this._dsEventOccured = true;
            var retn = this._binddataset.setColumn(datarow, cellinfo.text._bindexpr, v);
            if (this._env._p_enableaccessibility)
            {
                var cellobj = this._getAccessibilityCurrentCell();
                if (cellobj)
                    cellobj._setAccessibilityStatChecked(nexacro._toBoolean(v));
            }
            this._dsEventOccured = false;
            return retn;
        }
        return false;
    };

    _pGrid._isEditorKeyAction = function (elem, comp, keyCode, altKey, ctrlKey, shiftKey, metaKey)
    {
        if (this._is_editor_keyaction == false)
        {
            this._is_editor_keyaction = true;
            return true;
        }

        if (!this._showEditing)
            return false;

        if (elem.isInputElement())
        {
            var pos;
            var elem_val;
            var v;
            var line;

            if (elem.readonly == true)
                return false;

            if (keyCode == nexacro.Event.KEY_LEFT)
            {
                if (ctrlKey || shiftKey || altKey || metaKey)
                    return true;

                pos = elem.getElementCaretPos();
                elem_val = elem.getElementValue();
                v = elem_val ? elem_val.length : 0;

                if (this._isRtl())
                {
                    if ((pos && pos != -1) && pos.begin != v)
                        return true;
                }
                else
                {
                    if ((pos && pos != -1) && pos.begin != 0)
                    {
                        return true;
                    }
                }
            }
            else if (keyCode == nexacro.Event.KEY_RIGHT)
            {
                if (ctrlKey || shiftKey || altKey || metaKey)
                    return true;

                pos = elem.getElementCaretPos();
                elem_val = elem.getElementValue();
                v = elem_val ? elem_val.length : 0;

                if (this._isRtl())
                {
                    if ((pos && pos != -1) && pos.begin != 0)
                    {
                        return true;
                    }
                }
                else
                {
                    if ((pos && pos != -1) && pos.begin != v)
                        return true;
                }
            }
            else if (keyCode == nexacro.Event.KEY_UP)
            {
                if (ctrlKey || shiftKey || altKey || metaKey)
                    return true;

                if (elem.usemultiline)
                {
                    line = elem.getElementCaretLine();

                    if (line != 1)
                        return true;
                }
            }
            else if (keyCode == nexacro.Event.KEY_DOWN)
            {
                if (ctrlKey || shiftKey || altKey || metaKey)
                    return true;

                if (elem.usemultiline)
                {
                    line = elem.getElementCaretLine();

                    comp = elem.parent.linkedcontrol;
                    var max_line = parseInt(comp._getLineCount());

                    if (line != max_line)
                        return true;
                }
            }
        }
        return false;
    };

    _pGrid._getDlgCode = function (keycode, altKey, ctrlKey, shiftKey, metaKey)
    {
        if (this._env._p_enableaccessibility && this._env._a11ytype == 5)
        {
            this._accept_arrow = true;
        }
        return { want_tab: this._acceptstab, want_return: false, want_escape: false, want_chars: false, want_arrows: this._accept_arrow };
    };

    // 전방향 editable cell index 찾아오기
    _pGrid._getNextEditableCell = function (cellobj, type)
    {
        var row = -1, cell = -1;

        if (this._binddataset && this._curFormat && this._curFormat._bodycells)
        {
            var startrow = cellobj ? cellobj._rowidx : this._p_currentrow;
            var startcell = cellobj ? cellobj._cellidx : this._p_currentcell;

            var rlen = this._getGridRowCount();
            var clen = this._curFormat._bodycells.length;

            var editType = "";
            var _curformat = this._curFormat;

            if (type === "down" || type === "next")
            {
                startrow = (type === "down") ? startrow + 1 : startrow;
                startcell = (type === "next") ? startcell + 1 : startcell;

                for (row = startrow; row < rlen; row++)
                {
                    for (cell = startcell; cell < clen; cell++)
                    {
                        if (this._hasTree)
                            row = this._treeIndexes[row];

                        editType = _curformat._bodycells[cell]._getEdittype(row);

                        if (editType !== "" && editType !== "none")
                            return { row: row, cell: cell };

                        if (type === "down")
                            break;
                    }
                }
            }
            else if (type === "up" || type === "prev")
            {
                startrow = (type === "up") ? startrow - 1 : startrow;
                startcell = (type === "prev") ? startcell - 1 : startcell;

                for (row = startrow; row >= 0; row--)
                {
                    for (cell = startcell; cell >= 0; cell--)
                    {
                        if (this._hasTree)
                            row = this._treeIndexes[row];

                        editType = _curformat._bodycells[cell]._getEdittype(row);

                        if (editType !== "" && editType !== "none")
                            return { row: row, cell: cell };

                        if (type === "up")
                            break;
                    }
                }
            }

            row = -1;
            cell = -1;
        }

        return { row: row, cell: cell };
    };

    _pGrid._getFirstEditableCell = function ()
    {
        var editType;

        if (this._binddataset && this._curFormat && this._curFormat._bodycells)
        {
            var rlen = this._getGridRowCount();
            var clen = this._curFormat._bodycells.length;

            for (var i = 0; i < rlen; i++)
            {
                for (var j = 0; j < clen; j++)
                {
                    var row = i;
                    if (this._hasTree)
                        row = this._treeIndexes[row];

                    editType = this._curFormat._bodycells[j]._getEdittype(row);

                    if (editType !== "" && editType !== "none")
                        return { row: row, cell: j };
                }
            }
        }
        return { row: null, cell: null };
    };

    _pGrid._getLastEditableCell = function ()
    {
        var editType;

        if (this._binddataset)
        {
            var rlen = this._getGridRowCount();
            var clen = this._curFormat._bodycells.length;
            for (var i = rlen - 1; i >= 0; i--)
            {
                for (var j = clen - 1; j >= 0; j--)
                {
                    var row = i;
                    if (this._hasTree)
                        row = this._treeIndexes[row];

                    editType = this._curFormat._bodycells[j]._getEdittype(row);

                    if (editType !== "" && editType !== "none")
                        return { row: row, cell: j };
                }
            }
        }
        return { row: null, cell: null };
    };

    _pGrid._isChar = function (keyCode)
    {
        switch (keyCode)
        {
            case 9:
            case 25:
            case 27:
            case 144:
            case 145:
                return false;
                break;
        }

        if ((keyCode >= 16 && keyCode <= 21) || (keyCode >= 33 && keyCode <= 40) || (keyCode >= 91 && keyCode <= 93) || (keyCode >= 112 && keyCode <= 123))
            return false;

        return true;
    };

    _pGrid._on_apply_cell_status = function (cellobj, status, value, rowstatus)
    {
        if (this._p_enableredraw)
        {
            if (rowstatus == undefined)
            {
                rowstatus = this._isSelectRowType();

                if (status == "mouseover")
                {
                    if (this._p_mouseovertype == "cell")
                        rowstatus = false;
                    else if (this._p_mouseovertype == "row")
                        rowstatus = true;
                }
            }

            if (rowstatus)
            {
                var rowobj = cellobj._getRowControl();
                var cells = rowobj._cells;

                for (var i = 0, n = cells.length; i < n; i++)
                {
                    cells[i]._rowstatuschange = true;
                    cells[i]._changeStatus(status, value);
                    cells[i]._rowstatuschange = null;
                }
            }
            else
            {
                cellobj._rowstatuschange = true;
                cellobj._changeStatus(status, value);
                cellobj._rowstatuschange = null;
            }
        }
    };

    _pGrid._setDSEventHandlers = function (ds)
    {
        ds._setEventHandler("onload", this.on_dsnotify_onload, this);
        ds._setEventHandler("onrowposchanged", this.on_dsnotify_onrowposchanged, this);
        ds._setEventHandler("oncolumnchanged", this.on_dsnotify_oncolumnchanged, this);
        ds._setEventHandler("onrowsetchanged", this.on_dsnotify_onrowsetchanged, this);
    };

    _pGrid._removeDSEventHandlers = function (ds)
    {
        ds._removeEventHandler("onload", this.on_dsnotify_onload, this);
        ds._removeEventHandler("onrowposchanged", this.on_dsnotify_onrowposchanged, this);
        ds._removeEventHandler("oncolumnchanged", this.on_dsnotify_oncolumnchanged, this);
        ds._removeEventHandler("onrowsetchanged", this.on_dsnotify_onrowsetchanged, this);
    };

    _pGrid._getBodyClientSize = function ()
    {
        var format = this._curFormat;
        var height = 0, width = 0, clientrect;
        clientrect = this._getAvailableRect(this);
        width = clientrect.width;
        height = clientrect.height;

        if (format)
        {
            if (!this._bodyBand)
            {
                clientrect = this._getAvailableRect(this);
                width = clientrect.width - format.leftWidth - format.rightWidth;
                height = clientrect.height - this._getHeadHeight() - this._getSummHeight();
            }
            else
            {
                var cwidth, cheight;
                if (this._bodyBand._control_element)
                {
                    clientrect = this._getAvailableRect(this._bodyBand);
                    cwidth = clientrect.width;
                    cheight = clientrect.height;
                }
                else
                {
                    cwidth = this._bodyBand.width;
                    cheight = this._bodyBand.height;
                }
                width = cwidth - format.leftWidth - format.rightWidth;
                height = cheight;
            }
        }
        return [width, height];
    };

    _pGrid._applyAutofittype = function (redraw, property_set)
    {
        if (this._p_enableredraw == false)
        {
            this._enable_redraw_history.autofit = [redraw, property_set];
            return;
        }

        var format = this._curFormat;
        var control_elem = this.getElement();

        if (!format || !control_elem)
            return;

        var width;
        var height;
        var bodysize = this._getBodyClientSize();

        width = bodysize[0];
        height = bodysize[1];

        if (!this._is_created && (width <= 0 || height <= 0))
        {
            width = control_elem.client_width;
            //            height = control_elem.client_height;
        }

        var change = false;

        switch (this._p_autofittype)
        {
            case "col":
                this._colautofit = true;
                this._rowautofit = false;
                break;
            case "row":
                this._colautofit = false;
                this._rowautofit = true;
                break;
            case "both":
                this._colautofit = true;
                this._rowautofit = true;
                break;
            case "allrow":
                this._colautofit = false;
                //				this._rowautofit = true;
                break;
            case "allboth":
                this._colautofit = true;
                //				this._rowautofit = true;
                break;
            case "col,allrow":
                this._colautofit = true;
                //				this._rowautofit = true;
                break;
            case "allpivot":
                this._colautofit = true;
                //				this._rowautofit = true;
                break;
            case "row,allpivot":
                this._colautofit = false;
                //				this._rowautofit = true;
                break;
            case "none":
                this._colautofit = false;
                this._rowautofit = false;
                change = property_set;
                break;
        }

        if (this._colautofit && width >= 0) //width값이 음수이면 format 정보가 깨짐
        {
            change = format._adjustColWidth(width, this._autofitcol_rate);
        }

        if (change)
        {
            if (redraw)
            {
                if (this._p_autosizingtype != "none")
                {
                    this._autofiting = true;
                    this._recreate_contents_all(true, false);
                    this._autofiting = false;
                }
                else
                {
                    this._autofiting = true;

                    if (this._bodyBand)
                    {
                        var scrollheight = this._bodyBand._scrollHeight;
                        var scrollwidth = this._bodyBand._scrollWidth;

                        if (this._colautofit)
                        {
                            if (width != scrollwidth)
                            {
                                this._setScrollMaxSize(width, scrollheight);
                                this._bodyBand._scrollWidth = width;
                            }
                            this._bodyBand._matrix._adjustColsDisplay(true, true);
                        }
                        else
                        {
                            this._setScrollMaxSize(format.bodyWidth, scrollheight);
                            this._bodyBand._scrollWidth = format.bodyWidth;
                            this._bodyBand._matrix._adjustColsDisplay(true);
                        }
                    }
                    if (this._headBand)
                        this._headBand._matrix._adjustColsDisplay(true);
                    if (this._summBand)
                        this._summBand._matrix._adjustColsDisplay(true);

                    this._autofiting = false;
                    this._onResetScrollBar();
                }
            }
            this._applyResizer();
            return true;
        }
        return false;
    };

    _pGrid._resetColSizeList = function (chk_srow)
    {
        var change = false;

        if (this._p_autofittype != "col" && this._p_autofittype != "both" && this._p_autofittype != "allboth" && this._p_autofittype != "col,allrow")
        {
            var format = this._curFormat;

            if (!format)
                return false;

            var i, size, cols = format._cols, colsLen = cols.length;

            if (this._p_autosizingtype == "col" || this._p_autosizingtype == "both")
            {
                for (i = 0; i < colsLen; i++)
                {
                    size = this._getMaxColDataSizeBand(i, chk_srow);

                    if (size >= 0 && this._setColSize(-9, i, size, false, false, true, (i != colsLen - 1)))
                        change = true;
                }

                if (this._p_autofittype == "col" || this._p_autofittype == "both" || this._p_autofittype == "allboth" || this._p_autofittype == "col,allrow")
                    this._applyAutofittype(true);
            }
            else
            {
                for (i = 0; i < colsLen; i++)
                {
                    size = cols[i].size;

                    if (size >= 0 && this._setColSize(-9, i, size, false, false, true, (i != colsLen - 1)))
                        change = true;
                }
            }
        }

        return change;
    };

    _pGrid.redraw = function ()
    {
        this._recreate();

        if (this._select_ctrl)
            this._select_ctrl._updateAll();
    };

    _pGrid._getRowSizeInfo = function (datarow)
    {
        var format = this._curFormat;
        var rowsize, subrowsizes = [];

        if (datarow == -1)
        {
            rowsize = this._rowHeadList[0];
            subrowsizes = this._rowHeadListSub;

            return { row_size: rowsize, subrow_sizes: subrowsizes };
        }
        else if (datarow == -2)
        {
            rowsize = this._rowSummList[0];
            subrowsizes = this._rowSummListSub;

            return { row_size: rowsize, subrow_sizes: subrowsizes };
        }
        else if (datarow >= 0)
        {
            var rows = format._bodyrows;
            var rowsLen = rows.length;
            var list = this._rowSizeListSub = [];
            var listsub = this._rowSizeList = [];

            rowsize = list[datarow];

            for (var i = 0; i < rowsLen; i++)
                subrowsizes[i] = listsub[datarow * rowsLen + i];

            return { row_size: rowsize, subrow_sizes: subrowsizes };
        }
        return null;
    };

    _pGrid._lazy_calculate = true;
    _pGrid._resetRowSizeList = function (chk_srow)
    {
        if (!this._curFormat)
            return;

        var noauto = false;

        if (this._p_autosizingtype != "none" && !this._preloadImage())
            noauto = true;

        var lazy_rowsize = this._isLazyAutoVscroll();

        var format = this._curFormat;
        var keep;
        var i, j;
        var rows;
        var rowsLen;
        var height, h;

        if (format._headrows)
        {
            keep = this._is_user_change_head_rowsize;

            if (!keep)
            {
                this._rowHeadListSub = [];
                this._rowHeadList = [];
            }

            rows = format._headrows;
            rowsLen = rows.length;
            h = 0;

            var _rowHeadListSub = this._rowHeadListSub,
                _rowHeadList = this._rowHeadList;

            if (!(keep && _rowHeadList[0] >= 0))
            {
                if (!noauto && this._headAutoSize && (this._autoSizeRowProc || this._p_autosizingtype == "row" || this._p_autosizingtype == "both"))
                {
                    for (j = 0; j < rowsLen; j++)
                    {
                        height = this._getMaxSubRowSize(-1, j);
                        _rowHeadListSub[j] = height;
                        h += height;
                    }
                }
                else
                {
                    for (j = 0; j < rowsLen; j++)
                    {
                        height = rows[j].size;
                        _rowHeadListSub[j] = height;
                        h += height;
                    }
                }
                this._rowHeadList[0] = h;
            }
        }

        if (format._summrows)
        {
            keep = this._is_user_change_summ_rowsize;

            if (!keep)
            {
                this._rowSummListSub = [];
                this._rowSummList = [];
            }
            rows = format._summrows;
            rowsLen = rows.length;
            h = 0;

            var _rowSummListSub = this._rowSummListSub,
                _rowSummList = this._rowSummList;

            if (!(keep && _rowSummList[0] >= 0))
            {
                if (!noauto && this._binddataset && this._summAutoSize && (this._autoSizeRowProc || this._p_autosizingtype == "row" || this._p_autosizingtype == "both"))
                {
                    for (j = 0; j < rowsLen; j++)
                    {
                        height = this._getMaxSubRowSize(-2, j);
                        _rowSummListSub[j] = height;
                        h += height;
                    }
                }
                else
                {
                    for (j = 0; j < rowsLen; j++)
                    {
                        height = rows[j].size;
                        _rowSummListSub[j] = height;
                        h += height;
                    }
                }
                this._rowSummList[0] = h;
            }
        }

        if (format._bodyrows)
        {
            keep = this._is_user_change_body_rowsize;

            if (!keep && !chk_srow)
            {
                this._rowSizeList = [];
                this._rowSizeListSub = [];
                this._lazy_load_rowsize = [];
            }

            rows = format._bodyrows;
            rowsLen = rows.length;

            var rowcount = this._rowcount,
                _rowSizeListSub = this._rowSizeListSub,
                _rowSizeList = this._rowSizeList;

            chk_srow = !chk_srow ? 0 : chk_srow;

            if (!noauto && this._binddataset && this._bodyAutoSize && (this._autoSizeRowProc || this._p_autosizingtype == "row" || this._p_autosizingtype == "both"))
            {
                var toppos, endpos;
                if (lazy_rowsize)
                {
                    var bodyHeight = this._getBodyClientSize()[1];
                    var bodyRowHeight = this._getMinRowTextHeight();
                    var disprowcnt_min = Math.ceil((bodyHeight + (bodyRowHeight - 0.1)) / bodyRowHeight);

                    toppos = this._getDataRow(this._toprowpos[0]);
                    endpos = toppos + (disprowcnt_min - 1) * 3;
                    endpos = Math.min(this._getDataRow(endpos > this._p_rowcount - 1 ? this._p_rowcount - 1 : endpos), this._rowcount);   // this._p_rowcount 와 this._rowcount는 tree일 때 달라짐
                }

                for (i = chk_srow; i < rowcount; i++)
                {
                    if (keep)
                    {
                        if (_rowSizeList[i] >= 0)
                            continue;
                    }

                    h = 0;
                    if (toppos != undefined)
                    {
                        if (toppos <= i && i <= endpos)
                        {
                            for (j = 0; j < rowsLen; j++)
                            {
                                height = this._getMaxSubRowSize(i, j);
                                _rowSizeListSub[i * rowsLen + j] = height;
                                h += height;
                            }
                            this._lazy_load_rowsize[i] = h;
                        }
                        else
                        {
                            for (j = 0; j < rowsLen; j++)
                            {
                                height = rows[j].size;
                                _rowSizeListSub[i * rowsLen + j] = height;
                                h += height;
                            }
                        }
                    }
                    else
                    {
                        for (j = 0; j < rowsLen; j++)
                        {
                            height = this._getMaxSubRowSize(i, j);
                            _rowSizeListSub[i * rowsLen + j] = height;
                            h += height;
                        }
                    }
                    _rowSizeList[i] = h;
                }
                this._is_variable_bodyrowsize = true;
            }
            else
            {
                for (i = chk_srow; i < rowcount; i++)
                {
                    if (keep)
                    {
                        if (_rowSizeList[i] >= 0)
                            continue;
                    }

                    h = 0;
                    for (j = 0; j < rowsLen; j++)
                    {
                        height = rows[j].size;
                        _rowSizeListSub[i * rowsLen + j] = height;
                        h += height;
                    }
                    _rowSizeList[i] = h;
                }

                if (!keep)
                    this._is_variable_bodyrowsize = false;
            }
        }

        this._updateRowSizeExtend();

    };

    _pGrid._isLazyAutoVscroll = function ()
    {
        var ret = false;

        if (this._isPagination())
            return ret;

        if ((this._p_autosizingtype == "row" || this._p_autosizingtype == "both") && this._p_extendsizetype == "row")
        {
            // 사용자가 Col을 변경하는 경우 lazy 계산 안하도록 수정
            if (this._lazy_calculate && !this._is_user_change_colsize)
            {
                ret = true;
            }
        }

        return ret;
    };

    _pGrid._getMinRowTextHeight = function ()
    {
        var font, refer_font;
        font = this._getCellStyleInfo(0, "font", 0, undefined, null, true);
        font = nexacro.FontObject(font);
        refer_font = this._getReferenceAbsoluteFont(font); // use to em / rem
        return nexacro._getTextSize(".", font, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, refer_font)[1];
    };

    _pGrid._resetRowSizeListBodyDisplay = function ()
    {
        var bodyHeight = this._getBodyClientSize()[1];
        var bodyRowHeight = this._getMinRowTextHeight();
        var disprowcnt_min = Math.ceil((bodyHeight + (bodyRowHeight - 0.1)) / bodyRowHeight);

        var toppos = this._getDataRow(this._toprowpos[0]);
        var endpos = toppos + (disprowcnt_min - 1) * 3;
        endpos = Math.min(this._getDataRow(endpos > this._p_rowcount - 1 ? this._p_rowcount - 1 : endpos), this._rowcount);   // this._p_rowcount 와 this._rowcount는 tree일 때 달라짐

        return this._resetRowSizeListBodyRange(toppos, endpos);
    };

    _pGrid._resetRowSizeListBodyRange = function (top_datarow, end_datarow, retn_rows, retn_subrows)
    {
        if (!this._curFormat)
            return;

        var noauto = false;

        //trace("_resetRowSizeListBodyDisplay");

        if (this._p_autosizingtype != "none" && !this._preloadImage())
            noauto = true;

        var format = this._curFormat;
        var i, j;
        var rows;
        var rowsLen;
        var height, h;

        if (format._bodyrows)
        {
            rows = format._bodyrows;
            rowsLen = rows.length;

            var _rowSizeListSub = this._rowSizeListSub,
                _rowSizeList = this._rowSizeList;

            var param_array = false;
            if (retn_rows && retn_subrows)
            {
                param_array = true;
                _rowSizeList = retn_rows;
                _rowSizeListSub = retn_subrows;
            }

            if (!noauto && this._binddataset && this._bodyAutoSize && (this._autoSizeRowProc || this._p_autosizingtype == "row" || this._p_autosizingtype == "both"))
            {
                for (i = top_datarow; i <= end_datarow; i++)
                {
                    if (this._lazy_load_rowsize[i] == undefined)    // size 계산이 되지 않았을 때..
                    {
                        h = 0;
                        for (j = 0; j < rowsLen; j++)
                        {
                            height = this._getMaxSubRowSize(i, j);
                            _rowSizeListSub[i * rowsLen + j] = height;
                            h += height;
                        }

                        if (param_array == false)
                            this._lazy_load_rowsize[i] = h;

                        _rowSizeList[i] = h;
                    }
                    else
                    {
                        if (param_array == true)
                        {
                            _rowSizeList[i] = this._rowSizeList[i];
                            for (j = 0; j < rowsLen; j++)
                            {
                                _rowSizeListSub[i * rowsLen + j] = this._rowSizeListSub[i * rowsLen + j];
                            }
                        }
                    }
                }
                this._is_variable_bodyrowsize = true;
            }
        }
        this._updateRowSizeExtend();
    };

    _pGrid._updateRowSizeExtendEx = function (rows, rowSizeList, rowSizeListSub, row, isbody)
    {
        if (this._p_extendsizetype != "row" && this._p_extendsizetype != "both")
        {
            if (!rows)
                return;

            var max = [];
            var rowsLen = rows.length;
            var i, j;

            for (j = 0; j < rowsLen; j++)
            {
                max[j] = 0;
            }

            var rowSizeListSubLen = rowSizeListSub.length;

            if (row != undefined)
            {
                for (i = 0; i < rowsLen; i++)
                {
                    max[i] = rowSizeListSub[row * rowsLen + i];
                }
            }
            else
            {
                for (i = 0; i < rowSizeListSubLen;)
                {
                    for (j = 0; j < rowsLen; j++)
                    {
                        max[j] = Math.max(max[j], rowSizeListSub[i]);
                        i++;
                    }
                }
            }
            for (i = 0; i < rowSizeListSubLen;)
            {
                for (j = 0; j < rowsLen; j++)
                {
                    rowSizeListSub[i] = max[j];
                    i++;
                }
            }
            var height = 0;

            for (j = 0; j < rowsLen; j++)
            {
                height += max[j];
            }

            var rowSizeListLen = rowSizeList.length;

            for (i = 0; i < rowSizeListLen; i++)
            {
                rowSizeList[i] = height;
            }
        }

        if (isbody)
            this._resetFixSize();
    };

    _pGrid._updateRowSizeExtend = function ()
    {
        if (!this._binddataset || !this._curFormat)
        {
            return;
        }
        if (this._headAutoSize)
        {
            this._updateRowSizeExtendEx(this._curFormat._headrows, this._rowHeadList, this._rowHeadListSub);
        }
        if (this._summAutoSize)
        {
            this._updateRowSizeExtendEx(this._curFormat._summrows, this._rowSummList, this._rowSummListSub);
        }
        if (this._bodyAutoSize)
        {
            this._updateRowSizeExtendEx(this._curFormat._bodyrows, this._rowSizeList, this._rowSizeListSub, undefined, true);
        }
    };

    _pGrid._isChangeBodyColSizeList = function (columnid, cols, row)
    {
        if (this._p_autosizingtype != "both" && this._p_autosizingtype != "col")
            return false;
        else if (this._p_autofittype == "col")
            return false;

        var format = this._curFormat;
        if (!this._binddataset || !format)
            return false;

        var cells = format._bodycells;
        var colinfo, col, size, j = 0;
        var retn = false;
        var displayType;

        for (var i = 0, n = cells.length; i < n; i++)  // 같은 columnid로 여러 셀에 바인드할 경우를 모두 체크
        {
            if (cells[i].text._bindexpr == columnid)
            {
                displayType = cells[i]._getDisplayTypeValue(row);

                if (displayType == "checkboxcontrol" || displayType == "radioitemcontrol")
                    continue;

                col = cells[i]._col;
                colinfo = format._cols[col];
                size = this._getMaxColDataSizeBand(col);

                if (colinfo.size != size)
                {
                    format._setColSize(col, size);
                    cols[j++] = col;
                    retn = true;
                }
            }
        }
        return retn;
    };

    _pGrid._isChangeBodyRowSizeList = function (rowposition)
    {
        if (this._rowSizeEx == false && this._p_autosizingtype != "both" && this._p_autosizingtype != "row")
            return false;

        if (!this._binddataset || !this._curFormat)
            return false;

        var row = rowposition;
        var rows = this._curFormat._bodyrows;
        var rowsLen;
        var oldsize;
        var newsize;
        var j;

        if (rows && this._bodyAutoSize == true)
        {
            rowsLen = rows.length;
            for (j = 0; j < rowsLen; j++)
            {
                var index = (row * rows.length) + j;
                oldsize = this._rowSizeListSub[index];
                newsize = this._getMaxSubRowSize(row, j);

                if (oldsize != newsize)
                    return true;
            }
        }

        rows = this._curFormat._headrows;

        if (rows && this._headAutoSize == true)
        {
            rowsLen = rows.length;

            for (j = 0; j < rowsLen; j++)
            {
                oldsize = this._rowHeadListSub[j];
                newsize = this._getMaxSubRowSize(-1, j);

                if (oldsize != newsize)
                    return true;
            }
        }

        rows = this._curFormat._summrows;

        if (rows && this._summAutoSize == true)
        {
            rowsLen = rows.length;

            for (j = 0; j < rowsLen; j++)
            {
                oldsize = this._rowSummListSub[j];
                newsize = this._getMaxSubRowSize(-2, j);

                if (oldsize != newsize)
                    return true;
            }
        }
        return false;
    };

    _pGrid._updateBodyRowSizeList = function (rowposition)
    {
        var change = false;
        if (this._rowSizeEx == false || this._bodyAutoSize == false)
            return false;

        if (!this._binddataset || !this._curFormat || !this._curFormat._bodyrows || this._curFormat._bodyrows.length == 0)
            return false;

        var row = rowposition;
        var rows = this._curFormat._bodyrows;
        var rowsLen = rows.length;

        for (var j = 0; j < rowsLen; j++)
        {
            var index = (row * rows.length) + j;
            var oldsize = this._rowSizeListSub[index];
            var newsize = this._getMaxSubRowSize(row, j);

            if (oldsize != newsize)
            {
                this._rowSizeListSub[index] = newsize;
                this._rowSizeList[row] += (newsize - oldsize);
                change = true;
            }
        }
        if (change == true)
        {
            this._updateRowSizeExtend();
        }
        return change;
    };

    _pGrid._getGridRowCount = function (isOnlyScreen)
    {
        if (isOnlyScreen && this._bodyrowheight === 0)
        {
            return 0;
        }

        var rowcount = 0;
        if (this._hasTree)
        {
            if (this._treeIndexes)
            {
                rowcount = this._treeIndexes.length;
            }
        }
        else
        {
            rowcount = this._rowcount;
        }

        if (this._isPagination())
        {
            this._p_pagecount = Math.ceil(rowcount / this.pagesize);

            if (this._p_pagecount == this._p_page)
            {
                if (rowcount > 0 && rowcount != this._p_pagesize)
                {
                    rowcount = rowcount % this._p_pagesize;
                    rowcount = (rowcount == 0) ? this._p_pagesize : rowcount;
                }
            }
            else
            {
                rowcount = Math.min(rowcount, this._p_pagesize);
            }
        }

        return rowcount;
    };

    _pGrid._isPagination = function ()
    {
        if (this._hasTree)
            return false;

        if (this._p_pagesize > 0 && this._p_page >= 1)
            return true;

        return false;
    };

    _pGrid._resetDisplayInfo = function (reset_bandsize)
    {
        this._p_pagerowcount = 0;
        this._pagerowcnt = 0;
        this._disprowcnt = 0;
        this._pagerowrealcnt = 0;

        var format = this._curFormat;

        if (!format)
        {
            return;
        }

        var bodysize = this._getBodyClientSize();
        var bodyHeight = bodysize[1];
        var rowcount = this._getGridRowCount();
        var _vpos;

        this._bodyrowheight = format._body_height;

        if (this._bodyrowheight > 0)
        {
            if (this._p_createrowstype === "all")
            {
                this._p_pagerowcount = this._pagerowcnt = rowcount;
            }
            else if (this._is_variable_bodyrowsize == false || rowcount == 0)
            {
                var bodyRowHeight = this._bodyrowheight;
                this._p_pagerowcount = Math.floor(bodyHeight / bodyRowHeight);
                this._pagerowcnt = Math.ceil((bodyHeight + (bodyRowHeight - 0.1)) / bodyRowHeight);  // (bodyRowHeight - 0.1) scrollpixel 사용시 맨위의 row가 다음 row의 경계선 근처로 가려졌을 경우 고려..
                this._pagerowrealcnt = Math.ceil(bodyHeight / bodyRowHeight);
            }
            else
            {
                _vpos = (this._vscrollmng) ? this._vscrollmng._pos : 0;
                var vlimit = Math.ceil(this._control_element.vscroll_limit);

                if (_vpos < 0)
                    _vpos = 0;
                else if (_vpos > vlimit)
                    _vpos = vlimit;

                var s, i, toprowpos = this._getScreenTopRowPos(_vpos);
                var remain;

                s = i = toprowpos[0];
                remain = toprowpos[1];

                var row = this._getDataRow(i);
                var h = 0 - (this._rowSizeList[row] - remain);  // 음수 일경우 맨위의 cell이 화면에서 잘려 있는 상태..
                var psrow = this._rowToPageRow(0);

                for (; i < rowcount + psrow; i++)
                {
                    row = this._getDataRow(i);
                    h += this._rowSizeList[row];

                    this._pagerowcnt++;

                    if (h > bodyHeight)
                    {
                        break;
                    }
                    else if (h == bodyHeight)
                    {
                        this._pagerowrealcnt++;
                        break;
                    }

                    this._p_pagerowcount++;
                    this._pagerowrealcnt++;
                }

                if (i == rowcount + psrow && h < bodyHeight)
                {
                    var end = (this._fixed_endrow >= 0) ? this._fixed_endrow : -1;
                    for (i = s - 1; i > end; i--)
                    {
                        row = this._getDataRow(i);
                        h += this._rowSizeList[row];

                        this._pagerowcnt++;

                        if (h > bodyHeight)
                        {
                            break;
                        }
                        else if (h == bodyHeight)
                        {
                            this._pagerowrealcnt++;
                            break;
                        }

                        this._p_pagerowcount++;
                        this._pagerowrealcnt++;
                    }
                }

                while (h < bodyHeight)
                {
                    h += this._bodyrowheight;
                    this._pagerowcnt++;

                    if (h > bodyHeight)
                    {
                        break;
                    }
                    else if (h == bodyHeight)
                    {
                        this._pagerowrealcnt++;
                        break;
                    }

                    this._p_pagerowcount++;
                    this._pagerowrealcnt++;
                }

                if (this._pagerowcnt == 0 && toprowpos[1] >= bodyHeight)  // cell의 body 높이보다 더 큰경우
                {
                    this._pagerowcnt = this._p_pagerowcount = 1;
                }
            }
            this._disprowcnt = this._pagerowcnt;
        }
    };

    // Cell Style Info
    _pGrid._createTempCell = function (cellidx, rowidx, parent_cellinfo)
    {
        var cellinfos = this._getCellinfos(rowidx);
        if (!cellinfos)
        {
            return;
        }

        var bandid = this._getBandId(rowidx);
        var gridrow = this._getGridRow(rowidx);

        // create temp band		
        var band_control = this._style_tempband[bandid];
        if (!band_control)
        {
            band_control = this._style_tempband[bandid] = new nexacro.Component(bandid, 0, -10, 0, 0, null, null, null, null, null, null, this);
            band_control._skip_mobile_tabfocus = true;
            band_control._is_subcontrol = true;
            band_control._is_temp = true;
            band_control._type_name = nexacro._GridBandControl.prototype._type_name;
            band_control.createComponent(true);

            band_control._org_on_destroy_contents = band_control.on_destroy_contents;
            band_control.on_destroy_contents = function ()
            {
                this._org_on_destroy_contents();

                this._stylerow.destroy();
                this._stylerow = null;
            };

            band_control._getClassCSSSelector = nexacro._GridBandControl.prototype._getClassCSSSelector;
            band_control._getElementClassCSSSelector = nexacro._GridBandControl.prototype._getElementClassCSSSelector;
        }

        if (this._is_created && !band_control._is_created)
            band_control.on_created();

        // create temp row
        var row_control = band_control._stylerow;
        if (!row_control)
        {
            row_control = band_control._stylerow = new nexacro._GridRowControl(band_control, 0, -10, 0, 0, gridrow, true);
            row_control._style_evecells = [];
            row_control._style_oddcells = [];
            row_control.createComponent(true);

            if (this._is_created)
                row_control.on_created();

            row_control._org_on_destroy_contents = row_control.on_destroy_contents;
            row_control.on_destroy_contents = function ()
            {
                this._org_on_destroy_contents();
                var i, n;

                for (i = 0, n = this._style_evecells.length; i < n; i++)
                {
                    if (this._style_evecells[i])
                    {
                        this._style_evecells[i].destroy();
                        this._style_evecells[i] = null;
                    }
                }

                for (i = 0, n = this._style_oddcells.length; i < n; i++)
                {
                    if (this._style_oddcells[i])
                    {
                        this._style_oddcells[i].destroy();
                        this._style_oddcells[i] = null;
                    }
                }

                this._style_evecells = null;
                this._style_oddcells = null;
            };
        }
        else if (row_control._rowidx != gridrow)
        {
            if (this._is_created && !row_control._is_created)
                row_control.on_created();

            row_control._changeRow(gridrow);
            row_control._updateAll();
        }

        // create temp cell
        var cell_control_idx = parent_cellinfo ? parent_cellinfo._cellidx : cellidx;
        var cell_control = (gridrow % 2) ? row_control._style_oddcells[cell_control_idx] : row_control._style_evecells[cell_control_idx];
        if (!cell_control)
        {
            cell_control = new nexacro._GridCellControl("tempcell_" + gridrow + "_" + cell_control_idx, 0, -10, 0, 0, null, null, row_control, cellinfos[cell_control_idx], gridrow, cell_control_idx);
            cell_control._is_tempcell = true;
            cell_control.createComponent(true);

            (gridrow % 2) ? row_control._style_oddcells[cell_control_idx] = cell_control : row_control._style_evecells[cell_control_idx] = cell_control;
        }

        // create temp subcell
        if (parent_cellinfo)
        {
            var subcell_control = cell_control.subcells[cellidx];
            if (!subcell_control)
            {
                subcell_control = new nexacro._GridSubCellControl("tempcell_sub_" + cellinfos[cellidx]._row + "_" + cellinfos[cellidx]._cellidx, 0, -10, 0, 0, null, null, cell_control, cellinfos[cellidx], gridrow, cellidx);
                subcell_control.parentcell = cell_control;
                subcell_control.createComponent(true);

                cell_control.subcells[cellidx] = subcell_control;
            }
        }
    };

    _pGrid._getTempCell = function (cellidx, rowidx, parent_cellinfo, autosizing, prop, bexport)
    {
        var bandid = this._getBandId(rowidx);
        var gridrow = this._getGridRow(rowidx);

        var band_control = this._style_tempband[bandid];
        if (band_control)
        {
            var format = this._curFormat;

            if (format)
            {
                var bandinfo = format["_" + bandid.substring(0, 4) + "band"];
                if (bandinfo)
                    band_control.set_cssclass(bandinfo._getAttrValue(bandinfo._p_cssclass, rowidx));
            }

            var row_control = band_control._stylerow;
            if (row_control)
            {
                var cell_control_idx = parent_cellinfo ? parent_cellinfo._cellidx : cellidx;
                var cell_control = (gridrow % 2) ? row_control._style_oddcells[cell_control_idx] : row_control._style_evecells[cell_control_idx];

                if (autosizing)
                    cell_control._updateAllEx(prop, rowidx);
                else
                    cell_control._updateAll(undefined, undefined, undefined, bexport);

                if (parent_cellinfo)
                {
                    var subcell_control = cell_control.subcells[cellidx];
                    return {
                        cell: cell_control,
                        subcell: subcell_control
                    };
                }
                else
                {
                    return {
                        cell: cell_control,
                        subcell: null
                    };
                }
            }
        }

        return {
            cell: null,
            subcell: null
        };
    };

    _pGrid._getCellinfos = function (rowidx)
    {
        if (rowidx >= 0)
            return this._curFormat._bodycells;
        if (rowidx == -1)
            return this._curFormat._headcells;
        if (rowidx == -2)
            return this._curFormat._summcells;
    };

    _pGrid._getBandId = function (rowidx)
    {
        if (rowidx >= 0)
            return "body";
        if (rowidx == -1)
            return "head";
        if (rowidx == -2)
            return "summary";
    };

    _pGrid._getCellStyleInfo = function (cellidx, prop, datarow, selected, parent_cellinfo, autosizing, bexport, status_obj, call_flush)
    {
        var cellinfos = parent_cellinfo ? parent_cellinfo._subcells : this._getCellinfos(datarow);
        if (!cellinfos)
        {
            return null;
        }

        var use_flush = true;
        if (this._flush_cell_oldrow == datarow && this._flush_cell_oldcell == cellidx)
        {
            use_flush = false;
        }
        else if (this._flush_cell_oldrow != datarow && this._flush_cell_oldcell == cellidx)
        {
            if (this._flush_cell_oldrow >= 0 && datarow >= 0)   // bodyrow change
            {
                if (cellinfos[cellidx]._p_cssclass._bindtype < 2)  // not expr
                {
                    if ((this._flush_cell_oldrow % 2) == (datarow % 2))
                        use_flush = false;
                }
            }
        }

        // create temp cell
        this._createTempCell(cellidx, datarow, parent_cellinfo);

        // get temp cell
        var cells = this._getTempCell(cellidx, datarow, parent_cellinfo, autosizing, prop, bexport);
        var cell = cells.cell;
        var subcell = cells.subcell;
        var target_cell = subcell ? subcell : cell;
        var odd = "";
        var status = "enable";

        if (datarow >= 0)
        {
            if (bexport)    
            {
                // export 일때는 접혀진 tree일 경우에도 fulldata row로 처리.
                odd = (datarow % 2);
            }
            else
            {
                //  접혀진 tree일 경우 datarow가 아닌 Grid화면 기준 row로 동작.
                var gridrow = this._getGridRow(datarow);
                odd = (gridrow % 2);
            }
        }

        if (cell)
            cell._changeUserStatus("selected", !!selected);
        if (subcell)
            subcell._changeUserStatus("selected", !!selected);

        if (!bexport && status_obj != undefined)
        {
            cell._changeStatus(status_obj.status, status_obj.value);
            if (status_obj.value)
                status = status_obj.status;
        }

        if (call_flush === true)
        {
            target_cell._control_element._flushCommand();
            use_flush = false;
        }
        else if (call_flush === false)
        {
            use_flush = false;
        }

        // get style
        var obj = undefined;
        var objs, props;

        if (nexacro._isArray(prop))
        {
            objs = {};
            props = prop;
        }

        var i = 0;
        var flush = false;

        while (true)
        {
            var passadd = false;

            if (props)
                prop = props[i++];

            obj = cellinfos[cellidx]._getStyleCache(prop, datarow, selected, odd, status);

            if (!obj)
            {
                if (!flush) // just one
                {
                    if (prop == "background" || prop == "cursor" || prop == "align" || prop == "textDecoration")
                    {
                        if (this._is_created)
                        {
                            if (!cell._is_created)
                                cell.on_created();

                            if (subcell && !subcell._is_created)
                                subcell.on_created();
                        }
                        else
                        {
                            passadd = true;
                        }

                        if (use_flush)
                        {
                            target_cell._control_element._flushCommand();
                            this._flush_cell_oldrow = datarow;
                            this._flush_cell_oldcell = cellidx;
                        }

                        flush = true;
                    }
                }

                if (prop == "background")
                {
                    obj = target_cell._control_element._getComputedStyleBackgroundColor(true, (bexport || datarow < 0));

                    if (cellinfos[cellidx]._getVirtualMergeInfo(datarow + 2))
                        passadd = true;
                }
                else if (prop == "cursor")
                {
                    obj = target_cell._control_element._getComputedStyle("cursor", true);
                }
                else if (prop == "align")
                {
                    var is_subComp = target_cell._subComp;
                    var align2;

                    if (is_subComp)
                    {
                        align2 = is_subComp._getCurrentStyleAlign(true);
                    }
                    else
                    {
                        align2 = target_cell._getCurrentStyleAlign(true);
                    }
                    obj = align2.textAlign + "," + align2.verticalAlign;
                }
                else if (prop == "font" || prop == "color" || prop == "wordSpacing" || prop == "letterSpacing")
                {
                    var nstyle = cellinfos[cellidx][prop];

                    if (nstyle && nstyle instanceof nexacro.BindableValue)
                        nstyle = nstyle._value;

                    obj = nstyle || target_cell._getCurrentStyleInheritValue(prop, status);

                    if (prop == "color" && cellinfos[cellidx]._getVirtualMergeInfo(datarow + 2))
                        passadd = true;
                }
                else if (prop == "border")
                {
                    if (cellinfos[cellidx]._getSuppress(datarow) > 0 || cellinfos[cellidx]._getVirtualMergeInfo(datarow + 2))
                        passadd = true;
                    obj = target_cell._getCurrentStyleBorder();
                }
                else if (prop == "textDecoration")
                {
                    var nstyle2 = cellinfos[cellidx][prop];

                    if (nstyle2 && nstyle2 instanceof nexacro.BindableValue)
                        nstyle2 = nstyle2._value;

                    obj = nstyle2 || target_cell._getCSSStyleValue(prop, status);

                    if (!obj)
                    {
                        var text_elem = target_cell._text_elem;
                        if (text_elem)
                            obj = text_elem._getComputedStyle("text-decoration", true);
                    }
                }
                else if (prop == "checkboxicon" || prop == "radioitemicon")
                {
                    obj = target_cell._subComp._getCurrentStyleInheritValue("icon", status);
                }
                else if (prop == "checkboxsize" || prop == "radioitemsize")
                {
                    if (target_cell._subComp)
                        obj = target_cell._subComp._on_getFitSize();
                    else
                        obj = [0, 0];
                }
                else if (prop == "controldisplaysize")
                {
                    var retnsize = [0, 0];
                    var control = target_cell._subComp;
                    if (!control)
                        return retnsize;

                    var padding = control._getCSSStyleValue("padding", status);
                    var border = control._getCSSStyleValue("border", status);


                    if (padding)
                    {
                        retnsize[0] += padding.left + padding.right;
                        retnsize[1] += padding.top + padding.bottom;

                    }
                    if (border)
                    {
                        retnsize[0] += border.left._width + border.right._width;
                        retnsize[1] += border.top._width + border.bottom._width;
                    }
                    obj = retnsize;
                }
                else if (prop == "treestatusicon")
                {
                    var tree2 = target_cell._subComp;

                    if (tree2._img_ctrl)
                        obj = tree2._img_ctrl._getCurrentStyleInheritValue("icon", status);
                }
                else if (prop == "treebuttonicon")
                {
                    var tree3 = target_cell._subComp;

                    if (tree3._btnimg_ctrl)
                    {
                        tree3._btnimg_ctrl._changeUserStatus("collapse", true);
                        obj = tree3._btnimg_ctrl._getCurrentStyleInheritValue("icon", status);
                    }
                }
                else if (prop == "treecheckboxicon")
                {
                    var tree4 = target_cell._subComp;

                    if (tree4._chk_ctrl)
                        obj = tree4._chk_ctrl._getCurrentStyleInheritValue("icon", status);
                }
                else if (prop == "treecheckboxsize")
                {
                    var tree5 = target_cell._subComp;

                    if (tree5._chk_ctrl)
                        obj = tree5._chk_ctrl._on_getFitSize();
                }
                else
                {
                    var nstyle3 = cellinfos[cellidx][prop];

                    if (nstyle3 && nstyle3 instanceof nexacro.BindableValue)
                        nstyle3 = nstyle3._value;

                    obj = nstyle3 || target_cell._getCSSStyleValue(prop, status);
                }

                var setobj = obj;

                if (obj && nexacro._isObject(obj) && !nexacro._isArray(obj))
                {
                    if (obj && obj._bindtype > 0)
                        setobj = "bindexpr";
                    else
                        setobj = obj.value;

                    obj = obj.value;
                }

                var cssclass = cellinfos[cellidx]._p_cssclass;

                if (prop == "font")
                {
                    if (cssclass && cssclass._bindtype > 0 && !cellinfos[cellidx].font)
                        setobj = "bindexpr";

                    if (!selected)
                        cellinfos[cellidx]._curfont = setobj;
                    else
                        cellinfos[cellidx]._curselfont = setobj;
                }
                else if (prop == "border")
                {
                    if (cssclass && cssclass._bindtype > 0 && !cellinfos[cellidx].border)
                        setobj = "bindexpr";

                    cellinfos[cellidx]._curborder = setobj;
                }
                else if (prop == "padding")
                {
                    if (cssclass && cssclass._bindtype > 0 && !cellinfos[cellidx].padding)
                        setobj = "bindexpr";

                    cellinfos[cellidx]._curpadding = setobj;
                }

                if (!passadd)
                {
                    if (obj)
                        cellinfos[cellidx]._setStyleCache(prop, datarow, selected, odd, status, obj);
                }
            }
            else
            {
                //trace(obj);
            }

            if (props)
            {
                objs[prop] = obj;

                if (i < props.length)
                    continue;

                return objs;
            }

            break;
        }
        return obj;
    };

    _pGrid._getMaxColSize = function (cells, colidx, row, parentcol, maxbyte, parent_cellinfo)
    {
        var max = 0;
        var cellsLen = cells.length;
        var subcells;
        var format = this._curFormat;
        var col, colspan;

        if (!format._cols[colidx].visible)
            return 0;

        for (var i = 0; i < cellsLen; i++)
        {
            col = cells[i]._col;
            colspan = cells[i]._colspan;

            if (col <= colidx && col + colspan > colidx)
            {
                subcells = cells[i]._subcells;

                if (subcells.length > 0)
                {
                    var subsize = this._getMaxColSize(subcells, colidx - col, row, colidx, maxbyte, cells[i]);
                    max = Math.max(max, subsize);
                }
                else
                {
                    if (colspan > 1)
                    {
                        if (col + colspan - 1 != colidx) // 병합된 셀일경우 마지막 col일 때만 비교
                            continue;
                    }

                    if (!parentcol) parentcol = 0;

                    var treesize = 0;

                    if (this._hasTree)
                    {
                        if (this._treeCellinfo._p_displaytype == "rowgroupcontrol")
                            treesize = this._getGroupWidth(row, cells[i]);
                        else
                            treesize = this._getDepthWidth(row, cells[i]);
                    }

                    if (treesize < 0)
                    {
                        return -1;  // not tree image load
                    }

                    var autosizecol = cells[i]._getAttrValue(cells[i]._p_autosizecol, row);
                    var formatsize = format._cols[colidx + parentcol].orgsize;
                    var size;
                    var j;

                    if (autosizecol == "none")
                    {
                        size = formatsize;
                    }
                    else
                    {
                        var controlSize;
                        var displayType = cells[i]._getDisplayTypeValue(row);
                        if (displayType == "checkboxcontrol")
                        {
                            controlSize = cells[i]._getCheckboxsize(row);

                            if (controlSize == undefined)
                            {
                                controlSize = this._getCellStyleInfo(cells[i]._cellidx, "checkboxsize", row, false, parent_cellinfo, true);
                                controlSize = controlSize[0];
                            }

                            size = controlSize + 6;
                        }
                        else if (displayType == "radioitemcontrol")
                        {
                            controlSize = cells[i]._getRadioitemsize(row);

                            if (controlSize == undefined)
                            {
                                controlSize = this._getCellStyleInfo(cells[i]._cellidx, "radioitemsize", row, false, parent_cellinfo, true);
                                controlSize = controlSize[0];
                            }

                            size = controlSize + 6;
                        }
                        else if (displayType == "rowgroupcontrol" && cells[i]._groupcol >= 0 && this._binddataset.getRowType(row) != 16)
                        {
                            size = 0;
                        }
                        else
                        {
                            var text = cells[i]._getVirtualMergeInfo(row + 2) ? "" : cells[i]._getDisplayText(row);
                            if (text && maxbyte && colspan == 1 && !this._hasTree)
                            {
                                var re_newline = /\r\n|\n|\r/;
                                var lines = text.split(re_newline);
                                var lcnt = lines.length;
                                var nbyte, max_byte = 0, max_len = 0;

                                for (j = 0; j < lcnt; j++)
                                {
                                    nbyte = this._getByteLength_UTF8(lines[j]);
                                    max_len = Math.max(max_len, lines[j].length);
                                    max_byte = Math.max(max_byte, nbyte);
                                }

                                if (maxbyte.max > max_byte && maxbyte.len > max_len)
                                    continue;

                                maxbyte.len = max_len;
                                maxbyte.max = max_byte;
                            }

                            size = this._getCellRowTextSize(cells[i], row, text);
                            size = size[0];
                        }

                        var padd = cells[i]._curpadding, bord = cells[i]._curborder;

                        if (padd === "bindexpr" || padd === undefined)
                            padd = this._getCellStyleInfo(cells[i]._cellidx, "padding", row, undefined, undefined, true);

                        if (bord === "bindexpr" || bord === undefined)
                            bord = this._getCellStyleInfo(cells[i]._cellidx, "border", row, undefined, undefined, true);

                        if (padd)
                        {
                            padd = nexacro.PaddingObject(padd);
                            size += padd.left + padd.right;
                        }
                        if (bord)
                        {
                            bord = nexacro.BorderObject(bord);
                            size += bord.right._width;
                        }

                        size += treesize;

                        if (autosizecol == "limitmin")
                        {
                            if (size < formatsize)
                                size = formatsize;
                        }
                        else if (autosizecol == "limitmax")
                        {
                            if (size > formatsize)
                                size = formatsize;
                        }

                        if (colspan > 1)
                        {
                            var t_colsize = 0;
                            var s = col, e = col + colspan - 1;

                            for (j = s; j < e; j++)
                            {
                                t_colsize += format._cols[j + parentcol].getSize();
                            }
                            size -= t_colsize;
                        }
                        size += this._getDisplaytypeControlSize(true, displayType, cells[i], parent_cellinfo, row);
                    }
                    max = Math.max(max, size);
                }
            }
        }

        return max;
    };

    _pGrid._getTextSizeCache = function (font, refer_font)
    {
        var ret;
        if (!this._arrtextsizeCache)
        {
            this._arrtextsizeCache = {};
        }

        if (this._arrtextsizeCache[font.value])
        {
            ret = this._arrtextsizeCache[font.value];
        }
        else
        {
            ret = nexacro._getTextSize("A", font, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, refer_font);
            this._arrtextsizeCache[font.value] = ret;
        }
        return ret;
    };

    /* em,rem overrides for Grid */
    _pGrid._getReferenceAbsoluteFont = function (target_font, datarow, cellinfo, parent_cellinfo, autosizing)
    {
        var target_comp = this;
        if (cellinfo)
        {
            var cellinfos = parent_cellinfo ? parent_cellinfo._subcells : this._getCellinfos(datarow);
            if (cellinfos)
            {
                var cellidx = cellinfo._cellidx;

                // create temp cell
                this._createTempCell(cellidx, datarow, parent_cellinfo);

                var cells = this._getTempCell(cellidx, datarow, parent_cellinfo, autosizing, "font");
                target_comp = cells.subcell ? cells.subcell : cells.cell ? cells.cell : this;

                var font = cellinfos[cellidx]["font"];
                if (font)
                {
                    if (font instanceof nexacro.BindableValue)
                    {
                        font = font._value;
                    }

                    target_font = nexacro.FontObject(font);
                }
                else
                {
                    target_font = null;
                    target_comp = target_comp.parent;
                }
            }
        }

        return nexacro.Component.prototype._getReferenceAbsoluteFont.call(target_comp, target_font);
    };

    _pGrid._getCellRowTextSize = function (cellinfo, rowidx, text, parent_cellinfo, only_normal, merge_width)
    {
        var font = cellinfo._curfont, select_font = cellinfo._curselfont, refer_font = null;
        var word = cellinfo._getWordwrap(rowidx);
        var size = [], size1, size2;

        if (!word)
            word = this._getCellStyleInfo(cellinfo._cellidx, "wordWrap", rowidx, undefined, parent_cellinfo, true);

        if (font === undefined)
        {
            font = this._getCellStyleInfo(cellinfo._cellidx, "font", rowidx, undefined, parent_cellinfo, true);
            font = nexacro.FontObject(font);
            refer_font = this._getReferenceAbsoluteFont(font, rowidx, cellinfo, parent_cellinfo, true);
            size1 = this._getTextSizeCache(font, refer_font);

            if (cellinfo._curfont !== "bindexpr")
                cellinfo._cur1font_size = size1;
        }
        else
        {
            if (font === "bindexpr")   // expr, bind
            {
                font = this._getCellStyleInfo(cellinfo._cellidx, "font", rowidx, undefined, parent_cellinfo, true);
                font = nexacro.FontObject(font);
                refer_font = this._getReferenceAbsoluteFont(font, rowidx, cellinfo, parent_cellinfo, true);
                size1 = this._getTextSizeCache(font, refer_font);
            }
            else
            {
                font = nexacro.FontObject(font);
                if (!(size1 = cellinfo._cur1font_size))
                {
                    refer_font = this._getReferenceAbsoluteFont(font, rowidx, cellinfo, parent_cellinfo, true);
                    size1 = this._getTextSizeCache(font, refer_font);
                    cellinfo._cur1font_size = size1;
                }
            }
        }

        if (select_font === undefined)
        {
            select_font = this._getCellStyleInfo(cellinfo._cellidx, "font", rowidx, true, parent_cellinfo, true);
            select_font = nexacro.FontObject(select_font);
            refer_font = this._getReferenceAbsoluteFont(select_font, rowidx, cellinfo, parent_cellinfo, true);
            size2 = this._getTextSizeCache(select_font, refer_font);

            if (cellinfo._curselfont !== "bindexpr")
                cellinfo._cur1selectfont_size = size2;
        }
        else
        {
            if (select_font === "bindexpr")  // expr, bind
            {
                select_font = this._getCellStyleInfo(cellinfo._cellidx, "font", rowidx, true, parent_cellinfo, true);
                select_font = nexacro.FontObject(select_font);
                refer_font = this._getReferenceAbsoluteFont(select_font, rowidx, cellinfo, parent_cellinfo, true);
                size2 = this._getTextSizeCache(select_font, refer_font);
            }
            else
            {
                select_font = nexacro.FontObject(select_font);
                if (!(size2 = cellinfo._cur1selectfont_size))
                {
                    refer_font = this._getReferenceAbsoluteFont(select_font, rowidx, cellinfo, parent_cellinfo, true);
                    size2 = this._getTextSizeCache(select_font, refer_font);
                    cellinfo._cur1selectfont_size = size2;
                }
            }
        }

        var default_height;//, defalut_width;

        if (!text)
        {
            if (size1[0] <= size2[0])
                size = [].concat(size2);
            else
                size = [].concat(size1);

            size[0] = 1;
            size[1] = Math.ceil(size[1]);
            return size;
        }
        else
        {
            if (size1[0] <= size2[0])
            {
                font = select_font;
                //                defalut_width = size2[0];
                default_height = size2[1];
            }
            else
            {
                //                defalut_width = size1[0];
                default_height = size1[1];
            }
        }

        var displayType = "normal";

        if (!only_normal)
            displayType = cellinfo._getDisplayTypeValue(rowidx);

        if (displayType == "imagecontrol")
        {
            var str = "row" + rowidx;
            var tempWidthsize = cellinfo._imgWidthTemp[str];
            var tempHeightsize = cellinfo._imgHeightTemp[str];
            var url;

            if (tempWidthsize > 0)
            {
                size[0] = tempWidthsize;
                size[1] = tempHeightsize;
            }
            else
            {
                url = nexacro._getURIValue(text);
                url = nexacro._getImageLocation(url, this._getRefFormBaseUrl());

                var callfunc = this._getImageCallbackfunc(this._p_autosizingtype);
                var imgsize = nexacro._getImageSize(url, callfunc, this, this._getRefFormBaseUrl(), text);

                if (imgsize)
                {
                    size[0] = imgsize.width;
                    size[1] = imgsize.height;
                }
                else
                {
                    size[0] = 1;
                    size[1] = default_height;
                }
            }
            size[0] = Math.ceil(size[0]);
            size[1] = Math.ceil(size[1]);
            return size;
        }
        else
        {
            var usewordwrap = true;
            var usedecorate = (displayType == "decoratetext") ? true : false;
            var ctrl_width = 0;

            if (this._p_autosizingtype == "col" || this._p_autosizingtype == "both")
                usewordwrap = false;

            if (!refer_font)
            {
                refer_font = this._getReferenceAbsoluteFont(font);
            }

            var style = this._getCellStyleInfo(cellinfo._cellidx, ["wordSpacing", "letterSpacing"], rowidx, undefined, parent_cellinfo, true);
            var wordspacing = style.wordSpacing;
            var letterspacing = style.letterSpacing;
            var expandshow = cellinfo._getAttrValue(cellinfo._p_expandshow, rowidx);

            if (expandshow == "show")
                ctrl_width += cellinfo._getAttrValue(cellinfo._p_expandsize, rowidx);

            if (letterspacing)
            {
                letterspacing = nexacro.CSSValueObject(letterspacing);
            }

            if (wordspacing)
            {
                wordspacing = nexacro.CSSValueObject(wordspacing);
            }

            var padd;
            if ((usewordwrap && (this._autoSizeRowProc || this._rowSizeEx) && word != null && word != "none" && word != false && word != "false")
                || (usedecorate && (this._autoSizeRowProc || this._rowSizeEx)))
            {
                var width;
                if (merge_width != undefined)
                {
                    width = merge_width;
                    padd = this._getCellStyleInfo(cellinfo._cellidx, "padding", rowidx, undefined, parent_cellinfo, true);
                    if (padd)
                    {
                        padd = nexacro.PaddingObject(padd);
                        width -= (padd.left + padd.right);
                    }
                }
                else
                {
                    var cols = this._curFormat._cols;
                    var colidx = (parent_cellinfo ? parent_cellinfo._col : 0) + cellinfo._col;

                    style = this._getCellStyleInfo(cellinfo._cellidx, ["padding", "border", "align"], rowidx, undefined, parent_cellinfo, true);

                    padd = style.padding;
                    var bord = style.border;
                    var select_bord = this._getCellStyleInfo(cellinfo._cellidx, "border", rowidx, true, parent_cellinfo, true);

                    width = cols[colidx + cellinfo._colspan - 1].right - cols[colidx].left;

                    if (bord)
                        bord = nexacro.BorderObject(bord);

                    if (bord && select_bord)
                    {
                        select_bord = nexacro.BorderObject(select_bord);
                        bord = (bord.right._width < select_bord.right._width) ? select_bord : bord;
                    }
                    if (padd)
                    {
                        padd = nexacro.PaddingObject(padd);
                        width -= (padd.left + padd.right);
                    }

                    if (bord)
                        width -= bord.right._width;
                }
                width -= this._getDisplaytypeControlSize(true, displayType, cellinfo, parent_cellinfo, rowidx);

                var halign, valign;

                if (style.align)
                {
                    var cellalign = style.align.split(",");
                    halign = cellalign[0];
                    valign = cellalign[1];
                }

                width -= ctrl_width;
                size = nexacro._getTextSize(text, font, true, width, word, wordspacing, letterspacing, usedecorate, halign, valign, refer_font, nexacro._toBoolean(this._rtl));
            }
            else
            {
                size = nexacro._getTextSize(text, font, true, undefined, undefined, wordspacing, letterspacing, usedecorate, undefined, undefined, refer_font, nexacro._toBoolean(this._rtl));
            }

            size[0] += ctrl_width;

            if (size[1] < default_height)
            {
                size[1] = default_height;
            }

            size[0] = Math.ceil(size[0]);
            size[1] = Math.ceil(size[1]);
            return size;
        }
    };

    _pGrid._getMaxSubRowSize = function (rowidx, subrowidx, cells, parentrow, parent_cellinfo)
    {
        var format = this._curFormat;
        var bandrows;

        if (rowidx == -2)
        {
            if (!cells)
                cells = this._curFormat._summcells;

            bandrows = format._summrows;
        }
        else if (rowidx == -1)
        {
            if (!cells)
                cells = this._curFormat._headcells;

            bandrows = format._headrows;
        }
        else
        {
            if (!cells)
                cells = this._curFormat._bodycells;

            bandrows = format._bodyrows;
        }

        if (!this._autoSizeRowProc && this._p_autosizingtype != "row" && this._p_autosizingtype != "both")
        {
            return bandrows[subrowidx].size;
        }

        var max = 0;
        var cellsLen = cells.length;
        var _row, _rowspan, subcells;

        for (var i = 0; i < cellsLen; i++)
        {
            _row = cells[i]._row;
            _rowspan = cells[i]._rowspan;
            subcells = cells[i]._subcells;

            if (_row == subrowidx || (subcells.length > 0 && _row <= subrowidx && (_row + _rowspan) > subrowidx))
            {
                var maxrow = 0;

                if (subcells.length > 0)
                {
                    maxrow = this._getMaxSubRowSize(rowidx, subrowidx - _row, subcells, _row, cells[i]);
                    max = Math.max(max, maxrow);
                }
                else
                {
                    if (!parentrow) parentrow = 0;

                    var autosizerow = cells[i]._getAttrValue(cells[i]._p_autosizerow, rowidx);
                    var formatsize = bandrows[subrowidx + parentrow].size;
                    var size;

                    if (autosizerow == "none")
                    {
                        size = formatsize;
                    }
                    else
                    {
                        var displayType = cells[i]._getDisplayTypeValue(rowidx);
                        if (displayType == "checkboxcontrol")
                        {
                            var controlSize = cells[i]._getCheckboxsize(rowidx);

                            if (controlSize == undefined)
                            {
                                controlSize = this._getCellStyleInfo(cells[i]._cellidx, "checkboxsize", rowidx, false, parent_cellinfo, true);
                                controlSize = controlSize[1];
                            }

                            size = controlSize + 6;
                        }
                        else if (displayType == "radioitemcontrol")
                        {
                            var controlSize = cells[i]._getRadioitemsize(rowidx);

                            if (controlSize == undefined)
                            {
                                controlSize = this._getCellStyleInfo(cells[i]._cellidx, "radioitemsize", rowidx, false, parent_cellinfo, true);
                                controlSize = controlSize[1];
                            }

                            size = controlSize + 6;
                        }
                        else
                        {
                            var text = cells[i]._getVirtualMergeInfo(rowidx + 2) ? "" : cells[i]._getDisplayText(rowidx);
                            var s = this._getCellRowTextSize(cells[i], rowidx, text, parent_cellinfo);
                            size = s[1];

                            var padd = cells[i]._curpadding, bord = cells[i]._curborder;

                            if (padd === "bindexpr" || padd === undefined)
                                padd = this._getCellStyleInfo(i, "padding", rowidx, undefined, parent_cellinfo, true);

                            if (bord === "bindexpr" || bord === undefined)
                                bord = this._getCellStyleInfo(i, "border", rowidx, undefined, parent_cellinfo, true);

                            if (padd)
                            {
                                padd = nexacro.PaddingObject(padd);
                                size += padd.top + padd.bottom;
                            }
                            if (bord)
                            {
                                bord = new nexacro.BorderObject(bord);
                                size += bord.bottom._width;
                            }
                            size += this._getDisplaytypeControlSize(false, displayType, cells[i], parent_cellinfo, rowidx);
                        }

                        if (autosizerow == "limitmin")
                        {
                            if (size < formatsize)
                                size = formatsize;
                        }
                        else if (autosizerow == "limitmax")
                        {
                            if (size > formatsize)
                                size = formatsize;
                        }
                    }
                    max = Math.max(max, size);
                }
            }
        }
        return max;
    };

    _pGrid._getDisplaytypeControlSize = function (b_col, displaytype, cellinfo, parent_cellinfo, rowidx)
    {
        if (displaytype.indexOf("control") < 0)
            return 0;

        var controlSize = this._getCellStyleInfo(cellinfo._cellidx, "controldisplaysize", rowidx, false, parent_cellinfo, true);

        if (b_col == true)
        {
            controlSize = controlSize[0]; // col size
            return controlSize;

        }
        else
        {
            controlSize = controlSize[1]; // row size
            return controlSize;
        }
    };

    _pGrid._getSubRowSizeList = function (row)
    {
        var format = this._curFormat;
        var rows = format._bodyrows;
        var rowsLen = rows.length;
        var sizes = [], j = 0;

        for (var i = 0; i < rowsLen; i++)
        {
            sizes[j++] = this._rowSizeListSub[row * rowsLen + i];
        }

        return sizes;
    };

    _pGrid._makeCssRefInfoCtrl = function (ctrl)
    {
        ctrl._refcssobj = this;
        ctrl._refcssid = "#" + ctrl.id;
        return this;
    };

    _pGrid._addFuncQueue = function (work, pthis, func, args_arr)
    {
        var info = { work: work, pthis: pthis, func: func, args: args_arr };
        this._func_queue.push(info);
    };

    _pGrid._exeFuncQueue = function (work)
    {
        var arr = this._func_queue;

        for (var i = 0; i < arr.length; i++)
        {
            if (arr[i].work == work)
            {
                arr[i].func.call(arr[i].pthis, arr[i].args);
                this._func_queue.splice(i, 1);
                i--;
            }
        }
    };

    _pGrid._addRefreshContents = function (workname, band, check)
    {
        if (band)
        {
            var arr = this._recreate_contents_proc;

            if (check)
            {
                for (var i = 0, n = arr.length; i < n; i++)
                {
                    if (arr[i].workname == workname)
                    {
                        return false;
                    }
                }
            }
            var add = { workname: workname, band: band };
            arr.push(add);

            return true;
        }
    };

    _pGrid._execRefreshContents = function (workname, bclearcache, noupdatesupp)
    {
        var arr = this._recreate_contents_proc;

        for (var i = 0; i < arr.length; i++)
        {
            if (arr[i].workname == workname)
            {
                arr[i].band._recreate_contents(false, false, false, noupdatesupp);
                this._recreate_contents_proc.splice(i, 1);
                i--;
            }
        }
    };

    _pGrid._applyColSizing = function (movepos, idx, only_size)
    {
        if (!this._p_enableredraw)
            return;

        var control_elem = this.getElement();
        var format = this._curFormat;

        if (control_elem && format && idx >= 0)
        {
            var band = this._headBand;
            var rows = band._get_rows();
            var cellitem = rows[0]._cells[idx];
            var cellinfo = cellitem._refinfo;

            var colidx = cellinfo._col + (cellinfo._colspan - 1);

            if (!format._cols[colidx].visible)
                return;

            if (this._isRtl())
                movepos = -movepos;

            if (cellinfo._area != "right")
            {
                var prevright = format._cols[colidx].left;
                var currright = format._cols[colidx].right + movepos;

                if (prevright > currright)
                {
                    var next_col = format._cols[colidx + 1];
                    if ((next_col && next_col._area == "right") || colidx == format._cols.length - 1)
                        movepos = prevright - format._cols[colidx].right + 7;
                    else
                        movepos = prevright - format._cols[colidx].right + 1;
                }
            }
            else
            {
                var nextleft = format._cols[colidx].right;
                var currleft = format._cols[colidx].left + movepos;

                if (nextleft < currleft)
                    movepos = nextleft - format._cols[colidx].left - 1;

                movepos = 0 - movepos;
            }

            var oldval = format._cols[colidx].size;
            var change = format._adjustColSizing(colidx, movepos);
            var newval = format._cols[colidx].size;

            if (cellinfo._groupcol >= 0)
            {
                var group = format._group_info;
                var bodygroupcells = this._getRowGroupControlCells();
                var limitsize = this._getMaxColSize(bodygroupcells, colidx, 0);

                if (newval < limitsize)
                {
                    var gap = limitsize - newval;

                    change = format._adjustColSizing(colidx, gap);
                    newval = format._cols[colidx].size;
                }
            }

            if (change)
            {
                /* _updateColSize 로 변경
                this._addRefreshContents("colsizing", band);

                if (this._bodyBand)
                    this._addRefreshContents("colsizing", this._bodyBand);

                if (this._summBand)
                    this._addRefreshContents("colsizing", this._summBand);
                */
                if (this._p_enableredraw)
                {
                    this._updateColSize(colidx);
                }
                else
                {
                    if (!this._enable_redraw_history.updatecolsize)
                        this._enable_redraw_history.updatecolsize = [];

                    this._enable_redraw_history.updatecolsize.push(colidx);
                }

                if (!only_size)
                {
                    this._is_user_change_colsize = true;
                    this._addFuncQueue("colsizing", this, this.on_fire_oncolresized, [colidx, -9, newval, oldval, colidx]);
                }
            }
        }
    };

    _pGrid._applyRowSizing = function (movepos, idx)
    {
        if (this._p_enableredraw == false)
            return;

        var control_elem = this.getElement();
        var format = this._curFormat;

        if (format && control_elem && idx >= 0) 
        {
            var range = this._resizerRowRange[idx];
            var bandstr = range.area;
            var row = this._getDataRow(range.row);
            var subrow = range.cellinfo._row + range.cellinfo._rowspan - 1;

            this._applyRowSizing2(movepos, bandstr, row, subrow);
        }
    };

    _pGrid._applyRowSizing2 = function (movepos, bandstr, row, subrow, only_size)
    {
        if (this._p_enableredraw == false)
            return;

        var control_elem = this.getElement();
        var formatidx, oldval, newval;
        var format = this._curFormat;
        var size;
        var redraw;

        if (format && control_elem)
        {
            var change = false;

            if (bandstr == "head")
            {
                oldval = this._rowHeadListSub[subrow];
                size = oldval + movepos;
                size = Math.max(size, 5);
                size = Math.min(size, this._getClientHeight() - 5);
                newval = size;

                redraw = this._p_enableredraw;
                this._p_enableredraw = false;
                this.setRealRowSize(-1, size, subrow, true);
                this._p_enableredraw = redraw;
                formatidx = subrow;

                if (movepos)
                {
                    this._resizeBand();

                    if (!only_size)
                        this._addRefreshContents("rowsizing", this._headBand);
                    else
                        this._headBand._recreate_contents(false, false, false);

                    change = true;
                }
            }
            else if (bandstr == "body")
            {
                oldval = this._rowSizeListSub[row * format._bodyrows.length + subrow];
                size = oldval + movepos;

                var gap, remain;

                if (row == this._rowcount - 1)
                    remain = 7; // 7 : 마지막 row일 경우 조절하기 위해 여백을 남겨둠.
                else
                    remain = 1;

                gap = size - remain;

                if (gap < 0)
                {
                    size = remain;
                    movepos -= gap;
                }

                newval = size;

                if (this._getFixRowCnt() > row) // fix영역 수정
                {
                    this._fixed_height += movepos;
                    this._fixedrow_height += movepos;
                }

                redraw = this._p_enableredraw;
                this._p_enableredraw = false;
                this.setRealRowSize(row, size, subrow, true);
                this._p_enableredraw = redraw;
                formatidx = subrow + ((format._headrows) ? format._headrows.length : 0);

                if (movepos)
                {
                    if (this._p_extendsizetype != "row" && this._p_extendsizetype != "both")
                    {
                        if (!only_size)
                            this._addRefreshContents("rowsizing", this._bodyBand);
                        else
                            this._bodyBand._recreate_contents(false, false, false);
                    }
                    else
                    {
                        this._updateRowSize(row, subrow);
                    }
                    change = true;
                }
            }
            else if (bandstr == "summ")
            {
                oldval = this._rowSummListSub[subrow];

                if (this._p_summarytype == "top" || this._p_summarytype == "lefttop")
                    size = oldval + movepos;
                else
                    size = oldval - movepos;

                size = Math.max(size, 5);
                size = Math.min(size, this._getClientHeight() - 5);
                newval = size;

                redraw = this._p_enableredraw;
                this._p_enableredraw = false;
                this.setRealRowSize(-2, size, subrow, true);
                this._p_enableredraw = redraw;
                formatidx = subrow + ((format._headrows) ? format._headrows.length : 0) + ((format._bodyrows) ? format._bodyrows.length : 0);

                if (movepos)
                {
                    this._resizeBand();

                    if (!only_size)
                        this._addRefreshContents("rowsizing", this._summBand);
                    else
                        this._summBand._recreate_contents(false, false, false);

                    change = true;
                }
            }

            if (change && !only_size)
                this._addFuncQueue("rowsizing", this, this.on_fire_onrowresized, [formatidx, row, newval, oldval, subrow]);
        }
    };

    _pGrid._updateColSize = function (col)  // 화면 갱신
    {
        if (this._after_recreate)
            return;

        var reset_bandsize = false;
        if (this._p_autosizingtype == "row" || this._p_autosizingtype == "both")
        {
            this._resetRowSizeList();
            this._resizeBand(true);

            reset_bandsize = true;
            //            col = null;
        }

        this._autofitcol_rate = [];
        this._applyAutofittype(true);

        //    if (this._getScrollLeft() != 0)
        //          col = 0;

        //      this._resetScrollMax(); 2차메인(없음)

        if (this._headBand)
        {
            this._headBand._matrix._adjustColsDisplay(true, true);
            this._headBand._matrix._adjustRowsDisplay(reset_bandsize);
        }

        if (this._summBand)
        {
            this._summBand._matrix._adjustColsDisplay(true, true);
            this._summBand._matrix._adjustRowsDisplay(reset_bandsize);
        }

        if (this._bodyBand)
        {
            var _vpos = this._getScrollTop();

            if (_vpos < 0)
                _vpos = 0;

            this._last_scroll_top = _vpos;
            this._toprowpos = this._getScreenTopRowPos(_vpos);
            this._bottomrowpos = this._getScreenBottomRowPos(_vpos);

            this._bodyBand._matrix._adjustColsDisplay(true);
            this._bodyBand._matrix._adjustRowsDisplay(reset_bandsize);

            this._bodyBand._update_rows = this._bodyBand._matrix._adjustScrollRows(_vpos, true);
            this._bodyBand._on_refresh_rows(false, true);
            this._adjustOverlayControls(true);
        }
        this._resetScrollMax();
    };

    _pGrid._updateRowSize = function (row, subrow, no_refresh_band)  // 화면 갱신
    {
        if (this._p_extendsizetype != "row" && this._p_extendsizetype != "both")
            return;

        var format = this._curFormat;
        var rowctrl;
        var updatesize;
        var rowsize;
        var cells;
        var i, j, k, n;
        var subrowsize;
        var _row, _rowspan;

        if (row == -1)
        {
            if (!this._headBand)
                return false;

            rowctrl = this._headBand._get_rows()[0];
            rowsize = this._rowHeadList[0];
            updatesize = 0;

            rowctrl.set_height(rowsize);
            rowctrl._init(format);

            cells = rowctrl._cells;
            for (j = 0, n = cells.length; j < n; j++)
            {
                _row = cells[j]._refinfo._row;
                _rowspan = cells[j]._refinfo._rowspan;
                subrowsize = 0;

                if (_row <= subrow && subrow < _row + _rowspan)
                {
                    for (k = _row; k < _row + _rowspan; k++)
                    {
                        subrowsize += this._rowHeadListSub[k];
                    }
                    updatesize = subrowsize - cells[j]._height;
                    cells[j].set_height(subrowsize);
                }
                else if (_row > subrow)
                {
                    cells[j].set_top(cells[j]._top + updatesize);
                }
            }

            this._resizeBand();

            if (this._bodyBand && !no_refresh_band)
            {
                this._bodyBand._matrix._adjustRowsDisplay();
                this._bodyBand._matrix._adjustColsDisplay();
                this._bodyBand._on_refresh_rows(false, false);
            }
        }
        else if (row == -2)
        {
            if (!this._summBand)
                return false;

            rowctrl = this._summBand._get_rows()[0];
            rowsize = this._rowSummList[0];
            updatesize = 0;

            rowctrl.set_height(rowsize);
            rowctrl._init(format);

            cells = rowctrl._cells;
            for (j = 0, n = cells.length; j < n; j++)
            {
                _row = cells[j]._refinfo._row;
                _rowspan = cells[j]._refinfo._rowspan;
                subrowsize = 0;

                if (_row <= subrow && subrow < _row + _rowspan)
                {
                    for (k = _row; k < _row + _rowspan; k++)
                    {
                        subrowsize += this._rowSummListSub[k];
                    }
                    updatesize = subrowsize - cells[j]._height;
                    cells[j].set_height(subrowsize);
                }
                else if (_row > subrow)
                {
                    cells[j].set_top(cells[j]._top + updatesize);
                }
            }

            this._resizeBand();

            if (this._bodyBand && !no_refresh_band)
            {
                this._bodyBand._matrix._adjustRowsDisplay();
                this._bodyBand._matrix._adjustColsDisplay();
                this._bodyBand._on_refresh_rows(false, false);
            }
        }
        else if (row >= 0)
        {
            if (!this._bodyBand)
                return false;

            var rows = this._bodyBand._get_rows();

            for (i = 0, n = rows.length; i < n; i++)
            {
                if (rows[i]._rowidx == row)
                {
                    rowctrl = rows[i];
                    break;
                }
            }

            if (!rowctrl)
                return false;

            rowctrl._init(format);

            if (this._fixed_height)
                this._bodyBand._control_element._setFixArea(this._fixed_height);

            var datarow = this._getDataRow(row);
            rowsize = this._rowSizeList[datarow];
            var rowslen = this._curFormat._bodyrows.length;
            updatesize = 0;

            rowctrl.set_height(rowsize);

            cells = rowctrl._cells;
            for (j = 0, n = cells.length; j < n; j++)
            {
                _row = cells[j]._refinfo._row;
                _rowspan = cells[j]._refinfo._rowspan;
                subrowsize = 0;

                if (_row <= subrow && subrow < _row + _rowspan)
                {
                    for (k = _row; k < _row + _rowspan; k++)
                    {
                        subrowsize += this._rowSizeListSub[datarow * rowslen + k];
                    }
                    updatesize = subrowsize - cells[j]._height;
                    cells[j].set_height(subrowsize);
                }
                else if (_row > subrow)
                {
                    cells[j].set_top(cells[j]._top + updatesize);
                }
            }

            var _vpos = this._getScrollTop();

            if (_vpos < 0)
                _vpos = 0;

            if (!no_refresh_band)
            {
                this._last_scroll_top = _vpos;
                this._toprowpos = this._getScreenTopRowPos(_vpos);
                this._bottomrowpos = this._getScreenBottomRowPos(_vpos);

                this._bodyBand._matrix._adjustRowsDisplay(true);
                this._bodyBand._matrix._adjustColsDisplay();

                this._bodyBand._update_rows = this._bodyBand._matrix._adjustScrollRows(_vpos, true);
                this._bodyBand._on_refresh_rows(false, false);
            }
        }
        else
        {
            return false;
        }

        this._adjustOverlayControls(true);
        return true;
    };

    _pGrid._applyResizer = function ()
    {
        if (!this._is_created)
            return;

        var curborder = this._border || this._getCSSStyleValue("border", this._status);
        var lborder_w = (curborder) ? curborder.left._width : 0;
        var tborder_w = (curborder) ? curborder.top._width : 0;
        var resizer_colctrl = this._resizer_colctrl;
        var resizer_rowctrl = this._resizer_rowctrl;
        var rows, cellitem, cellborder, cellinfo, cellpos, i;
        var resizermark_arr;
        var resizermark_range = {};
        var mark_idx;
        var cellcnt;
        var left, top, width, height;
        var band;
        var j;

        if (this._p_cellsizingtype == "col" || this._p_cellsizingtype == "both")
        {
            band = this._headBand;

            if (band == null)
                return;

            rows = band._get_rows();

            if (rows.length == 0)
                return;

            cellcnt = rows[0]._cells.length;
            resizermark_arr = this._resizerColRange = [];
            mark_idx = 0;

            /*if (resizer_colctrl)
            {
                resizer_colctrl.destroy();
                delete resizer_colctrl;
            }*/

            if (!resizer_colctrl)
            {
                resizer_colctrl = new nexacro._GridResizerControl("resizertrack", 0, 0, 0, 0, null, null, this);
            }
            resizer_colctrl.set_rtl(this._isRtl());
            resizer_colctrl._setDirection("horizon");
            resizer_colctrl._setTracksize(this._getClientHeight());
            resizer_colctrl._setCallbackFn(this._applyColSizing);
            if (!resizer_colctrl._is_created) resizer_colctrl.createComponent();
            this._resizer_colctrl = resizer_colctrl;

            for (j = 0; j < cellcnt; j++)
            {
                cellitem = rows[0]._cells[j];

                if (!cellitem)
                    break;

                cellinfo = cellitem._refinfo;
                cellpos = cellitem._setPositionInGrid(null, true, true);
                height = cellpos.height;
                cellborder = cellitem._refinfo._border || cellitem._getCSSStyleValue("border", cellitem._stauts);

                if (cellinfo._area == "left" || cellinfo._area == "body")
                {
                    width = cellborder ? cellborder.right._width : 0;
                    left = cellpos.left + cellitem._adjust_width - width - 4;

                    if (cellitem._adjust_width <= width)
                    {
                        if (mark_idx > 0)
                        {
                            resizermark_arr[mark_idx - 1].left -= 1;
                            resizermark_arr[mark_idx - 1].right -= 1;
                        }
                    }
                }
                else
                {
                    width = cellborder ? cellborder.left._width : 0;
                    left = cellpos.left - 2;
                }

                resizermark_range = { left: left + lborder_w, top: cellpos.top + tborder_w, right: left + width + lborder_w + 6, bottom: cellpos.top + height + tborder_w, index: cellitem._cellidx, area: cellinfo._area };

                // 좌표
                //              trace(resizermark_range.left + ", " + resizermark_range.right + ", " + resizermark_range.index);

                switch (this._p_cellsizebandtype)
                {
                    case "body":
                        if (cellinfo._area == "body")
                        {
                            resizermark_arr[mark_idx++] = resizermark_range;
                        }
                        break;
                    case "allband":
                    case "nohead":
                        resizermark_arr[mark_idx++] = resizermark_range;
                        break;
                    case "noleft":
                    case "nohead,noleft":
                        if (cellinfo._area != "left")
                        {
                            resizermark_arr[mark_idx++] = resizermark_range;
                        }
                        break;
                }
            }
        }
        else
        {
            if (resizer_colctrl)
            {
                resizer_colctrl.destroy();
                this._resizer_colctrl = null;
                this._resizerColRange = [];
            }
        }

        if (this._p_cellsizingtype == "row" || this._p_cellsizingtype == "both")
        {
            var head = this._headBand;
            var body = this._bodyBand;
            var summ = this._summBand;
            var cell_len;

            if (!head && !body && !summ)
                return;

            resizermark_arr = this._resizerRowRange = [];
            mark_idx = 0;

            if (resizer_rowctrl)
            {
                resizer_rowctrl.destroy();
            }

            resizer_rowctrl = new nexacro._GridResizerControl("resizertrack", 0, 0, 0, 0, null, null, this);
            resizer_rowctrl._setDirection("vertical");
            resizer_rowctrl._setTracksize(this._getClientWidth());
            resizer_rowctrl._setCallbackFn(this._applyRowSizing);
            resizer_rowctrl.createComponent();
            this._resizer_rowctrl = resizer_rowctrl;

            while (head)
            {
                if (this._p_cellsizebandtype == "body" || this._p_cellsizebandtype == "nohead" || this._p_cellsizebandtype == "nohead,noleft")
                    break;

                rows = head._get_rows();

                if (!rows.length)
                    break;

                cell_len = rows[0]._cells.length;

                for (i = 0; i < cell_len; i++)
                {
                    cellitem = rows[0]._cells[i];
                    cellinfo = cellitem._refinfo;

                    cellpos = cellitem._setPositionInGrid(null, true, true);

                    width = cellitem._adjust_width;
                    cellborder = cellitem._refinfo._border || cellitem._getCSSStyleValue("border", cellitem._status);

                    height = cellborder ? cellborder.bottom._width : 0;
                    top = cellpos.top + cellitem._adjust_height - height - 4;

                    resizermark_range = { left: cellpos.left + lborder_w, top: top + tborder_w, right: cellpos.left + width + lborder_w, bottom: top + height + 6 + tborder_w, index: mark_idx, area: "head", row: cellitem._rowidx, cellinfo: cellinfo };
                    resizermark_arr[mark_idx++] = resizermark_range;
                }
                break;  // 소나큐브무시
            }

            if (body)
            {
                rows = body._get_rows();
                var rows_len = rows.length;

                for (i = 0; i < rows_len; i++)
                {
                    cell_len = rows[i]._cells.length;
                    for (j = 0; j < cell_len; j++)
                    {
                        cellitem = rows[i]._cells[j];
                        cellinfo = cellitem._refinfo;

                        cellpos = cellitem._setPositionInGrid(null, true, true);

                        width = cellitem._adjust_width;
                        cellborder = cellitem._refinfo._border || cellitem._getCSSStyleValue("border", cellitem._status);

                        height = cellborder ? cellborder.bottom._width : 0;
                        top = cellpos.top + cellitem._adjust_height - height - 4;

                        resizermark_range = { left: cellpos.left + lborder_w, top: top + tborder_w, right: cellpos.left + width + lborder_w, bottom: top + height + 6 + tborder_w, index: mark_idx, area: "body", row: cellitem._rowidx, cellinfo: cellinfo };
                        resizermark_arr[mark_idx++] = resizermark_range;
                    }
                }
            }

            while (summ)
            {
                if (this._p_cellsizebandtype == "body")
                    break;

                rows = summ._get_rows();

                if (!rows.length)
                    break;

                cell_len = rows[0]._cells.length;

                for (i = 0; i < cell_len; i++)
                {
                    cellitem = rows[0]._cells[i];
                    cellinfo = cellitem._refinfo;
                    cellpos = cellitem._setPositionInGrid(null, true, true);
                    width = cellitem._adjust_width;
                    cellborder = cellitem._refinfo._border || cellitem._getCSSStyleValue("border", cellitem._status);

                    if (this._p_summarytype == "top" || this._p_summarytype == "lefttop")
                    {
                        height = cellborder ? cellborder.bottom._width : 0;
                        top = cellpos.top + cellitem._adjust_height - height - 4;
                    }
                    else
                    {
                        height = cellborder ? cellborder.top._width : 0;
                        top = cellpos.top - 2;
                    }

                    resizermark_range = { left: cellpos.left + lborder_w, top: top + tborder_w, right: cellpos.left + width + lborder_w, bottom: top + height + 6 + tborder_w, index: mark_idx, area: "summ", row: cellitem._rowidx, cellinfo: cellinfo };
                    resizermark_arr[mark_idx++] = resizermark_range;
                }
                break;  // 소나큐브무시
            }
        }
        else
        {
            if (resizer_rowctrl)
            {
                resizer_rowctrl.destroy();
                this._resizer_rowctrl = null;
                this._resizerRowRange = [];
            }
        }
    };

    _pGrid._destroyResizer = function ()
    {
        var resizer_colctrl = this._resizer_colctrl;
        if (resizer_colctrl)
        {
            resizer_colctrl.destroy();
            this._resizer_colctrl = null;
        }

        var resizer_rowctrl = this._resizer_rowctrl;
        if (resizer_rowctrl)
        {
            resizer_rowctrl.destroy();
            this._resizer_rowctrl = null;
        }
    };

    _pGrid._isAreaSelect = function ()
    {
        if (this._p_selecttype == "area" || this._p_selecttype == "multiarea")
            return true;

        return false;
    };

    _pGrid._isSelectRowType = function ()
    {
        if (this._p_selecttype == "row" || this._p_selecttype == "multirow")
            return true;

        return false;
    };

    _pGrid._isMultiSelect = function ()
    {
        if (this._p_selecttype == "multirow" || this._p_selecttype == "multicell" || this._p_selecttype == "multitreecell" || this._p_selecttype == "multiarea")
            return true;

        return false;
    };

    _pGrid._setColSize = function (nPivotIndex, nColIndex, nSize, bBandIndex, bRedraw, autosize, noAdjust)
    {
        var format = this._curFormat;

        var leftcnt = this._getColFixCnt("left");
        var bodycnt = this._getColFixCnt("body");
        var rightcnt = this._getColFixCnt("right");
        var _cols = format._cols;
        var _colsLen = _cols.length;

        var areatype = "body";

        if (typeof (nPivotIndex) != "string")
        {
            if (nPivotIndex == -1)
                areatype = "left";
            else if (nPivotIndex == -2)
                areatype = "right";
        }
        else
            areatype = nPivotIndex;

        if (bBandIndex == true || nPivotIndex >= -2)
        {
            if (areatype == "left")
            {
                if (nColIndex >= leftcnt)
                    return false;
            }
            if (areatype == "body" && nColIndex >= 0)
            {
                if (nColIndex >= bodycnt)
                    return false;

                nColIndex += leftcnt;
            }
            else if (areatype == "right")
            {
                if (nColIndex >= rightcnt)
                    return false;

                nColIndex += leftcnt;
                nColIndex += bodycnt;
            }
        }

        var bChange = false;
        if (nColIndex == -1)
        {
            var change;
            for (var i = 0; i < _colsLen; i++)
            {
                if (autosize)
                {
                    if (_cols[i]._area == "left" && this._AutoSizeLcol == false)
                        continue;

                    if (_cols[i]._area == "right" && this._AutoSizeRcol == false)
                        continue;
                }

                change = format.setFormatColProperty(i, "size", nSize);

                if (change)
                {
                    bChange = change;
                    this._autofitcol_rate = [];

                    if (bRedraw)
                        this._recreate_contents_all(true, false);
                }
            }
        }
        else
        {
            while (true)
            {
                if (autosize)
                {
                    if (_cols[nColIndex]._area == "left" && this._AutoSizeLcol == false)
                        break;

                    if (_cols[nColIndex]._area == "right" && this._AutoSizeRcol == false)
                        break;
                }
                if (bChange = format._setColSize(nColIndex, nSize, noAdjust))
                {
                    if (bRedraw)
                    {
                        if (this._p_enableredraw)
                        {
                            this._updateColSize(nColIndex);
                        }
                        else
                        {
                            if (!this._enable_redraw_history.updatecolsize)
                                this._enable_redraw_history.updatecolsize = [];

                            this._enable_redraw_history.updatecolsize.push(nColIndex);
                        }
                    }
                }
                break;  // 소나큐브무시
            }
        }

        return bChange;
    };

    _pGrid._getLastRowBand = function ()
    {
        var format = this._curFormat;
        var band = "body";

        if (this._p_summarytype == "top" || this._p_summarytype == "lefttop")
        {
            if (format._headrows && format._headrows.length)
                band = "head";

            if (format._summrows && format._summrows.length)
                band = "summ";

            if (format._bodyrows && format._bodyrows.length)
                band = "body";
        }
        else
        {
            if (format._headrows && format._headrows.length)
                band = "head";

            if (format._bodyrows && format._bodyrows.length)
                band = "body";

            if (format._summrows && format._summrows.length)
                band = "summ";
        }
        return band;
    };

    _pGrid._getDispRowCnt = function ()
    {
        if (this._bodyBand)
            return this._bodyBand._get_rows().length;

        return 0;
    };

    _pGrid._getScreenBottomRowPos = function (vpos, b_force)
    {
        if (!this._is_use_suppress && !this._is_performance_scroll && !b_force) // 성능 때문에 suppress만 동작하도록함.
            return -2;

        var band = this._bodyBand;
        var scrolltop = (vpos != null) ? vpos : this._getScrollTop();
        var row = -1;
        var height = 0;
        var cnt = this._getGridRowCount();
        var bandh = this._getAvailableRect(band).height;

        for (var i = 0; i < cnt; i++)
        {
            if (i <= this._fixed_endrow)
                continue;

            var prow = this._rowToPageRow(i);
            height += this._getRowSize(prow);

            if (height >= scrolltop + bandh)
            {
                row = prow;
                break;
            }
        }
        return row;
    };

    _pGrid._getScreenBottomRowPosEx = function (vpos)
    {
        if (!this._is_use_suppress && !this._is_performance_scroll) // 성능 때문에 suppress만 동작하도록함.
            return -1;

        var band = this._bodyBand;
        var scrolltop = (vpos != null) ? vpos : this._getScrollTop();
        var row = -1, over = 0;
        var height = 0;
        var cnt = this._getGridRowCount();
        var bandh = this._getAvailableRect(band).height;

        for (var i = 0; i < cnt; i++)
        {
            if (i <= this._fixed_endrow)
                continue;

            var prow = this._rowToPageRow(i);

            height += this._getRowSize(prow);

            if (height <= scrolltop + bandh)
                row = prow;
            else
                over++;
        }
        return [row, over];
    };

    _pGrid._getScreenTopRowPos = function (vpos)
    {
        var band = this._bodyBand;
        var scrolltop = (vpos != null) ? vpos : this._getScrollTop();
        var row = 0;
        var height = 0;
        var cnt = this._getGridRowCount();
        var remain = 0;
        var bset = false;
        var i;

        for (i = 0; i < cnt; i++)
        {
            var prow = this._rowToPageRow(i);

            if (prow <= this._fixed_endrow)
                continue;

            if (height > scrolltop)
            {
                row = prow - 1;
                remain = height - scrolltop;
                bset = true;
                break;
            }
            height += this._getRowSize(prow);
        }

        if (!bset)
        {
            if (band._getClientHeight() < height)
            {
                if (height > scrolltop)
                {
                    row = this._rowToPageRow(i - 1);
                    remain = height - scrolltop;
                }
            }
            else
            {
                row = this._rowToPageRow(this._getFixRowCnt());
            }
        }
        return [row, remain];
    };

    _pGrid._isRemainAreaScroll = function ()
    {
        var band = this._bodyBand;
        var rows = band._get_rows();

        if (rows.length == 0)
            return false;

        var scrolltop = this._getScrollTop();
        var height = 0;
        var rows_len = rows.length;
        var lastrow = rows[rows_len - 1];
        var lastrowidx = this._getGridRowCount() - 1;

        if (lastrow._rowidx != lastrowidx)
            return false;

        var bodyheight = this._getBodyClientSize()[1];
        var lasttoprow = 0;

        for (var i = rows.length - 1; i >= 0; i--)
        {
            lasttoprow = rows[i]._rowidx;
            height += this._getRowSize(lasttoprow);

            if (height >= bodyheight)
                break;
        }

        scrolltop -= rows[0]._adjust_top;

        for (i = 0; i < rows_len; i++)
        {
            if (height == scrolltop)
            {
                return false;
            }
            else if (height > scrolltop)
            {
                return (lasttoprow == rows[i]._rowidx - 1);
            }
            height += this._getRowSize(rows[i]._rowidx);
        }
        return false;
    };

    _pGrid._getScollMaxLeft = function ()
    {
        if (this._control_element)
            return this._control_element.hscroll_limit;

        return 0;
    };

    _pGrid._getScrollLeft = function ()
    {
        if (this._control_element)
            return this._control_element.scroll_left;

        return 0;
    };

    _pGrid._getScrollTop = function ()
    {
        if (this._control_element)
            return this._control_element.scroll_top;

        return 0;
    };

    _pGrid._pageRowToRow = function (rowidx)
    {
        if (this._isPagination() && rowidx >= 0)
        {
            var page = this._p_page;
            rowidx -= (this._p_pagesize * (page - 1));
        }

        return rowidx;
    }

    _pGrid._rowToPageRow = function (physical_rowidx, page)
    {
        if (this._isPagination() && physical_rowidx >= 0)
        {
            if (page == undefined)
                page = this._p_page;

            physical_rowidx += (this._p_pagesize * (page - 1));
        }

        return physical_rowidx;
    }

    _pGrid._getDataRow = function (rowidx)
    {
        if (rowidx >= this._rowcount)
            return -9;

        if (this._hasTree && rowidx >= 0)
        {
            rowidx = this._treeIndexes[rowidx];
            if (rowidx == undefined)
                rowidx = -9;
        }
        return rowidx;
    };

    _pGrid._getGridRow = function (datarow)
    {
        if (this._hasTree && datarow >= 0)
        {
            var _treeKeys = this._treeKeys;
            var row = _treeKeys.indexOf(datarow);

            if (row != undefined)
                return row;
            return -9;
        }
        return datarow;
    };

    _pGrid._refreshCol = function (nColIdx, clearCurstyle, strBand, nDisplayRowIdx)
    {
        if (!this._p_enableredraw)
        {
            this._enable_redraw_history.refreshall = true;
            return;
        }

        if (this._after_recreate)
            return;

        if (!this.getElement())
            return;

        var band = this._headBand;
        var cells;
        var cellsLen;
        var i, j, nn;
        var cell;

        if (band && (!strBand || strBand == "head"))
        {
            cells = band._get_rows()[0]._cells;
            cellsLen = cells.length;

            for (i = 0; i < cellsLen; i++)
            {
                cell = cells[i];
                if (cell && cell._refinfo._col == nColIdx)
                {/*
                    if (clearCurstyle)
                    {
                    }*/
                    cell._updateAll();
                }
            }
        }
        band = this._summBand;
        if (band && (!strBand || (strBand == "summ" || strBand == "summary")))
        {
            cells = band._get_rows()[0]._cells;
            cellsLen = cells.length;

            for (i = 0; i < cellsLen; i++)
            {
                cell = cells[i];
                if (cell && cell._refinfo._col == nColIdx)
                {/*
                    if (clearCurstyle)
                    {
                    }*/
                    cell._updateAll();
                }
            }
        }
        band = this._bodyBand;
        var rows = band._get_rows();
        if (band && rows.length && (!strBand || strBand == "body"))
        {
            cells = rows[0]._cells;
            cellsLen = cells.length;

            for (i = 0; i < cellsLen; i++)
            {
                cell = cells[i];
                if (cell && cell._refinfo._col == nColIdx)
                {
                    if (nDisplayRowIdx >= 0)
                    {
                        this._refreshCell("body", cell._cellidx, nDisplayRowIdx);
                    }
                    else
                    {
                        for (j = 0, nn = this._getDispRowCnt(); j < nn; j++)
                        {
                            this._refreshCell("body", cell._cellidx, j);
                        }
                    }
                }
            }
        }
    };

    _pGrid._refreshCell = function (strBand, nCellIdx, nDisplayRowIdx, styleprop, nSubCellIdx, for_select)
    {
        if (!this._p_enableredraw)
        {
            this._enable_redraw_history.refreshall = true;
            return;
        }

        if (this._after_recreate)
            return;

        var cell, band, subcellinfo, cellinfo;

        strBand = strBand.toLowerCase();

        if (strBand == "head")
        {
            band = this._headBand;
            if (band)
            {
                cell = band._get_rows()[0]._cells[nCellIdx];
                if (cell)
                {
                    if (nSubCellIdx >= 0)
                    {
                        subcellinfo = cell._refinfo._subcells[nSubCellIdx];
                        if (styleprop && subcellinfo && cell.subcells[nSubCellIdx]["set_" + styleprop])
                            cell.subcells[nSubCellIdx]["set_" + styleprop](subcellinfo._getAttrValue(subcellinfo["_p_" + styleprop], this._currentDSrow));
                    }
                    else
                    {
                        cellinfo = cell._refinfo;
                        if (styleprop && cell["set_" + styleprop])
                            cell["set_" + styleprop](cellinfo._getAttrValue(cellinfo["_p_" + styleprop], this._currentDSrow));
                    }

                    cell._updateAll();
                }
            }
        }
        else if (strBand == "summ" || strBand == "summary")
        {
            band = this._summBand;
            if (band)
            {
                cell = band._get_rows()[0]._cells[nCellIdx];
                if (cell)
                {
                    if (nSubCellIdx >= 0)
                    {
                        subcellinfo = cell._refinfo._subcells[nSubCellIdx];
                        if (styleprop && subcellinfo && cell.subcells[nSubCellIdx]["set_" + styleprop])
                            cell.subcells[nSubCellIdx]["set_" + styleprop](subcellinfo._getAttrValue(subcellinfo["_p_" + styleprop], this._currentDSrow));
                    }
                    else
                    {
                        cellinfo = cell._refinfo;
                        if (styleprop && cell["set_" + styleprop])
                            cell["set_" + styleprop](cellinfo._getAttrValue(cellinfo["_p_" + styleprop], this._currentDSrow));
                    }
                    cell._updateAll();
                }
            }
        }
        else
        {
            if (nDisplayRowIdx >= 0)
            {
                this._refreshBodyCell(nCellIdx, nDisplayRowIdx, for_select, styleprop, nSubCellIdx);
            }
            else
            {
                for (var i = 0, n = this._getDispRowCnt(); i < n; i++)
                {
                    this._refreshBodyCell(nCellIdx, i, for_select, styleprop, nSubCellIdx);
                }
            }
        }
    };

    _pGrid._isEnable = function ()
    {
        this._enable = nexacro.Component.prototype._isEnable.call(this);
        return this._enable;
    };

    _pGrid._getMaxColDataSizeBand = function (nColIndex, chk_srow)
    {
        var totalmax = -1;
        var format = this._curFormat;
        var cells;
        var cellsLen;
        var colcells;
        var size;
        var maxbyte;
        var bfont, bselfont, bborder, bpadding;
        var cellinfo, prevcellinfo, subcells;
        var i, j, nn;
        var max;

        if (this._bodyAutoSize)
        {
            max = -1;

            if (this._binddataset)
            {
                var rowcount = this._getGridRowCount();

                if (rowcount > 0 && format._bodycells)
                {
                    if (!this._preloadTreeImage())
                        return -1;

                    if (!this._preloadImage())
                        return -1;

                    cells = format._bodycells;
                    cellsLen = cells.length;
                    colcells = [];
                    maxbyte = { max: -1, len: -1 };

                    for (i = 0; i < cellsLen; i++)
                    {
                        cellinfo = cells[i];

                        if (cellinfo._col <= nColIndex && (cellinfo._col + cellinfo._colspan) > nColIndex)
                        {
                            if (cellinfo != prevcellinfo)
                                colcells.push(cellinfo);

                            prevcellinfo = cellinfo;

                            if (cellinfo._subcells.length)
                            {
                                subcells = cellinfo._subcells;

                                for (j = 0, nn = subcells.length; j < nn; j++)
                                {
                                    if (cellinfo._col + subcells[j]._col <= nColIndex && (cellinfo._col + subcells[j]._col + subcells._colspan) > nColIndex)
                                    {
                                        cellinfo = subcells[j];
                                        break;
                                    }
                                }
                            }

                            if (maxbyte)
                            {
                                if (cellinfo._curfont === undefined)
                                    this._getCellStyleInfo(cellinfo._cellidx, "font", 0, false, undefined, true);
                                if (cellinfo._curselfont === undefined)
                                    this._getCellStyleInfo(cellinfo._cellidx, "font", 0, true, undefined, true);
                                if (cellinfo._curborder === undefined)
                                    this._getCellStyleInfo(cellinfo._cellidx, "border", 0, false, undefined, true);
                                if (cellinfo._curpadding === undefined)
                                    this._getCellStyleInfo(cellinfo._cellidx, "padding", 0, undefined, undefined, true);

                                // 모든 스타일이 동일해야 byte체크
                                if (cellinfo._curfont === "bindexpr" || cellinfo._curselfont === "bindexpr" || cellinfo._curborder === "bindexpr" || cellinfo._curpadding === "bindexpr")
                                {
                                    maxbyte = null;
                                    continue;
                                }
                                else if (bfont !== undefined) // 이전 값이 존재할때 만 체크
                                {
                                    if ((bfont != cellinfo._curfont) || (bselfont != cellinfo._curselfont) || (bborder != cellinfo._curborder) || (bpadding != cellinfo._curpadding))
                                    {
                                        maxbyte = null;
                                        continue;
                                    }
                                }

                                bfont = cellinfo._curfont;
                                bselfont = cellinfo._curselfont;
                                bborder = cellinfo._curborder;
                                bpadding = cellinfo._curpadding;
                            }
                        }
                    }

                    for (j = 0; j < rowcount; j++)
                    {
                        var datarow = this._getDataRow(j);

                        if (datarow == -9)
                            continue;

                        if (chk_srow >= 0 && j < chk_srow)
                        {
                            max = format._cols[nColIndex].getSize();
                            continue;
                        }

                        size = this._getMaxColSize(colcells, nColIndex, datarow, null, maxbyte);

                        if (size < 0)
                            return -1;

                        max = Math.max(max, size);
                    }
                }
            }
            totalmax = Math.max(totalmax, max);
        }
        if (this._headAutoSize && format._headcells)
        {
            cells = format._headcells;
            cellsLen = cells.length;
            colcells = [];

            for (i = 0; i < cellsLen; i++)
            {
                cellinfo = cells[i];
                if (cellinfo._col <= nColIndex && (cellinfo._col + cellinfo._colspan) > nColIndex)
                    colcells.push(cellinfo);
            }

            max = this._getMaxColSize(colcells, nColIndex, -1);
            totalmax = Math.max(totalmax, max);
        }

        if (this._summAutoSize && format._summcells)
        {
            cells = format._summcells;
            cellsLen = cells.length;
            colcells = [];

            for (i = 0; i < cellsLen; i++)
            {
                cellinfo = cells[i];
                if (cellinfo._col <= nColIndex && (cellinfo._col + cellinfo._colspan) > nColIndex)
                    colcells.push(cellinfo);
            }

            max = this._getMaxColSize(colcells, nColIndex, -2);
            totalmax = Math.max(totalmax, max);
        }
        return totalmax;
    };

    _pGrid._on_treeloadImagetemp = function (url, imgW, imgH)
    {
        // 이곳에 타면 안됨. 이 전에 이미지가 로드가 다 되어있어야함. 테스트용
        //alert("load");
    };

    _pGrid._img_preload_cnt = 0;
    _pGrid._hasTree = false;
    _pGrid._treeIndexes = null;
    _pGrid._treeKeys = null;
    _pGrid._treeStates = null;
    _pGrid._treeChecked = null;
    _pGrid._treeCellinfo = null;
    _pGrid._hasSameNextNode = null;
    _pGrid._maxdepth = 0;
    _pGrid._rootlevel = 99;
    _pGrid._treeInitStatus = { "collapse,null": 0, "expand,null": 1, "collapse,all": 2, "expand,all": 3 };
    _pGrid._currentCellEditor = null;
    _pGrid._currentCellCell = -1;
    _pGrid._currentCellRow = -1;
    _pGrid._showEditing = false;
    _pGrid._beforeEditRowIdx = -1;
    _pGrid._beforeEditCellIdx = -1;
    _pGrid._onceTime_focus = false;
    _pGrid._set_focus_dir = -1;
    _pGrid._showEditorFocus = false;

    _pGrid._on_treeloadImage_autosize = function (url, imgW, imgH)
    {
        var tree_load = this._tree_load_all;
        tree_load[url].isload = true;

        var key, load = true;

        this._img_preload_cnt--;

        for (key in tree_load)
        {
            if (tree_load.hasOwnProperty(key))
            {
                if (tree_load[key].isload == false)
                {
                    load = false;
                    break;
                }
            }
        }

        if (load)
        {
            if (this._is_created && this._img_preload_cnt == 0)
                this._recreate_contents_all(true);
        }
        else
        {
            if (this._is_created)
            {
                if (this._resetColSizeList())
                    this._bodyBand._matrix._adjustColsDisplay(true);
            }
        }
    };

    _pGrid._on_treeloadImage = function (url, imgW, imgH)
    {
        var tree_load = this._tree_load_all;
        tree_load[url].isload = true;
    };

    _pGrid._on_sizeloading_autosize = function (url, imgW, imgH)
    {
        var image_load = this._image_load_all;
        if (image_load)
        {
            if (!image_load[url])
                image_load[url] = {};
            image_load[url].isload = true;
        }

        var key, load = true;
        if (this._img_preload_cnt > 0)
            this._img_preload_cnt--;

        for (key in image_load)
        {
            if (image_load.hasOwnProperty(key))
            {
                if (image_load[key].isload == false)
                {
                    load = false;
                    break;
                }
            }
        }

        if (load)
        {
            if (this._is_created && this._img_preload_cnt == 0)
                this._recreate_contents_all(true);
        }
        else
        {
            if (this._is_created)
            {
                if (this._resetColSizeList())
                    this._bodyBand._matrix._adjustColsDisplay(true);
            }
        }
    };

    _pGrid._on_sizeloading = function (url, imgW, imgH)
    {
        var image_load = this._image_load_all;
        if (image_load)
        {
            if (!image_load[url])
                image_load[url] = {};
            image_load[url].isload = true;
        }
    };

    _pGrid._preloadTreeImage = function ()  // autosize시 grid treeimage 미리 로드하여 처리
    {
        if (this._tree_load_all != null)
            return true;

        if (!this._binddataset)
            return true;

        var rowcount = this._binddataset.getRowCount();
        var cellinfos = this._curFormat._bodycells;
        var state, displayType, cellinfo, prop;
        var image;
        var orgsrc;
        this._tree_load_all = {};

        for (var i = 0; i < rowcount; i++)
        {
            for (var j = 0, nn = cellinfos.length; j < nn; j++)
            {
                cellinfo = cellinfos[j];
                displayType = cellinfo._getDisplaytype(i);

                if (displayType != "treeitemcontrol" && displayType != "rowgroupcontrol")
                    continue;

                state = this._treeStates[i];

                if (state == 0)
                    prop = "treecollapseimage";
                else if (state == 1)
                    prop = "treeexpandimage";
                else if (state == 2)
                    prop = "treeitemimage";

                image = cellinfo._query_status_treecontrol(i, prop);
                if (image)
                {
                    orgsrc = image;
                    if (image.substring(0, 4).toLowerCase() == "url(")
                        image = image.substring(5, image.length - 2);

                    image = nexacro._getImageLocation(image, this._getRefFormBaseUrl());
                    this._tree_load_all[image] = { "isload": false, "orgsrc": orgsrc };
                }

                prop = "";
                if (state == 0)
                    prop += "treeopenbuttonimage";
                else if (state == 1)
                    prop += "treeclosebuttonimage";

                if (prop)
                {
                    image = cellinfo._query_status_treecontrol(i, prop);
                    if (image)
                    {
                        orgsrc = image;
                        if (image.substring(0, 4).toLowerCase() == "url(")
                            image = image.substring(5, image.length - 2);

                        image = nexacro._getImageLocation(image, this._getRefFormBaseUrl());

                        this._tree_load_all[image] = { "isload": false, "orgsrc": orgsrc };
                    }
                }
            }
        }

        var key, load = true, size;

        for (key in this._tree_load_all)
        {
            if (this._tree_load_all.hasOwnProperty(key))
            {
                size = nexacro._getImageSize(key, this._on_treeloadImage_autosize, this, this._getRefFormBaseUrl(), this._tree_load_all[key].orgsrc);

                if (!size)
                {
                    load = false;
                    this._img_preload_cnt++;
                }
                else
                    this._tree_load_all[key].isload = true;
            }
        }

        return load;
    };

    _pGrid._preloadImage = function ()  // autosize시 gridimage 미리 로드하여 처리
    {
        if (this._image_load_all != null)
            return true;

        if (!this._binddataset)
            return true;

        var rowcount = this._binddataset.getRowCount();
        var cellinfos = this._curFormat._bodycells;
        var displayType, cellinfo;

        if (!cellinfos)
            return true;

        this._image_load_all = {};

        for (var i = 0; i < rowcount; i++)
        {
            for (var j = 0, nn = cellinfos.length; j < nn; j++)
            {
                cellinfo = cellinfos[j];
                displayType = cellinfo._getDisplaytype(i);

                var image;
                var orgsrc;
                if (displayType == "imagecontrol")
                    image = cellinfo._getDisplayText_text(i);
                else if (displayType == "checkboxcontrol")
                    image = this._getCellStyleInfo(j, "checkboxicon", i);
                else if (displayType == "radioitemcontrol")
                    image = this._getCellStyleInfo(j, "radioitemicon", i);

                if (image)
                {
                    orgsrc = image;
                    if (image.substring(0, 4).toLowerCase() == "url(")
                        image = image.substring(5, image.length - 2);

                    image = nexacro._getImageLocation(image, this._getRefFormBaseUrl());
                    this._image_load_all[image] = { "isload": false, "orgsrc": orgsrc };
                }

                // subcell
                var subcells = cellinfo._subcells;
                var subcellinfo;

                for (var k = 0, nnn = subcells.length; k < nnn; k++)
                {
                    subcellinfo = subcells[k];
                    displayType = subcellinfo._getDisplaytype(i);

                    if (displayType == "imagecontrol")
                        image = subcellinfo._getDisplayText_text(i);
                    else if (displayType == "checkboxcontrol")
                        image = this._getCellStyleInfo(k, "checkboxicon", i, cellinfo);
                    else if (displayType == "radioitemcontrol")
                        image = this._getCellStyleInfo(k, "radioitemicon", i, cellinfo);

                    if (image)
                    {
                        orgsrc = image;
                        if (image.substring(0, 4).toLowerCase() == "url(")
                            image = image.substring(5, image.length - 2);

                        image = nexacro._getImageLocation(image, this._getRefFormBaseUrl());
                        this._image_load_all[image] = { "isload": false, "orgsrc": orgsrc };
                    }
                }
            }
        }

        var key, load = true, size;

        for (key in this._image_load_all)
        {
            if (this._image_load_all.hasOwnProperty(key))
            {
                size = nexacro._getImageSize(key, this._on_sizeloading_autosize, this, this._getRefFormBaseUrl(), this._image_load_all[key].orgsrc);

                if (size)
                    this._image_load_all[key].isload = true;
                else
                {
                    load = false;
                    this._img_preload_cnt++;
                }
            }
        }
        return load;
    };

    _pGrid._getDepthWidth = function (datarow, cellinfo)
    {
        // 여기가 수정되면 _pCellTree._adjustSubCompAlign도 동일한 처리가 필요합니다.

        var displayType = cellinfo._getDisplaytype(datarow);

        if (displayType != "treeitemcontrol")
            return 0;

        var start = cellinfo._getTreeStartLevel(datarow);
        var level = cellinfo._getTreeLevel(datarow);
        var state = this._treeStates[datarow];
        var gap = 22;
        var defaultsize = 9;
        var imagewidth = 14;
        var buttonwidth = 14;
        var checkwidth;
        var prop;

        if (state == 0)
            prop = "treecollapseimage";
        else if (state == 1)
            prop = "treeexpandimage";
        else if (state == 2)
            prop = "treeitemimage";

        var image = cellinfo._query_status_treecontrol(datarow, prop);
        var size;
        var orgVal = undefined;
        if (image)
        {
            orgVal = image;
            if (image.substring(0, 4).toLowerCase() == "url(")
            {
                image = image.substring(5, image.length - 2);
            }

            image = nexacro._getImageLocation(image, this._getRefFormBaseUrl());
            size = nexacro._getImageSize(image, this._on_treeloadImagetemp, this, this._getRefFormBaseUrl(), orgVal);

            if (size)
                imagewidth = size.width;


            // trace("img " + imagewidth);
        }

        prop = "";
        if (state == 0)
            prop += "treeopenbuttonimage";
        else if (state == 1)
            prop += "treeclosebuttonimage";

        if (prop)
        {
            image = cellinfo._query_status_treecontrol(datarow, prop);
            if (image)
            {
                orgVal = image;
                if (image.substring(0, 4).toLowerCase() == "url(")
                {
                    image = image.substring(5, image.length - 2);
                }

                image = nexacro._getImageLocation(image, this._getRefFormBaseUrl());
                size = nexacro._getImageSize(image, this._on_treeloadImagetemp, this, this._getRefFormBaseUrl(), orgVal);
                if (size)
                    buttonwidth = size.width;
            }
        }

        level -= start;

        if (level < 0)
            level = -1;

        var offset = (level * gap) + defaultsize;
        var line_button_gap_width = 0;
        var btn_visible = ((state == 0 || state == 1) && this._p_treeusebutton == "use");

        var buttonLeft = offset - (buttonwidth / 2);

        if (buttonLeft < 0)
            buttonLeft = offset - (defaultsize / 2);

        if (!this._p_treeuseline)
            buttonLeft -= ((buttonwidth / 2) * level);

        if (btn_visible)
        {
            line_button_gap_width = buttonwidth;
            offset = buttonLeft + buttonwidth;
        }
        else
        {
            if (!this._p_treeuseline)
            {
                offset = buttonLeft + buttonwidth;
            }
        }

        if (this._p_treeuseline)
        {
            offset += (buttonwidth - (line_button_gap_width / 2));
        }
        else
        {
            offset += 1;
        }

        if (this._p_treeusecheckbox == true)
        {
            checkwidth = cellinfo._getCheckboxsize(datarow);

            if (checkwidth == undefined)
            {
                checkwidth = this._getCellStyleInfo(cellinfo._cellidx, "treecheckboxsize", datarow, false);
                checkwidth = checkwidth[0];
            }
            // trace("chk " + checkwidth);
            offset += checkwidth;
        }

        if (this._p_treeuseimage == true)
        {
            offset += imagewidth;
            offset += 6;
        }
        else 
        {
            offset += 4;
        }

        return offset;
    };

    _pGrid._getGroupWidth = function (datarow, cellinfo)
    {
        var displayType = cellinfo._getDisplaytype(datarow);

        if (displayType != "rowgroupcontrol")
            return 0;

        if (this._binddataset.getRowType(datarow) == 16)
            return 0;

        var level = cellinfo._getGroupRowLevel(datarow);
        var defaultsize = 9;
        var gap = 16;   //defaultsize;
        var buttonwidth = 14;
        var prop = "groupopenbuttonimage";
        var is_groupcol = cellinfo._groupcol >= 0;

        if (is_groupcol)
            level = 0;

        var offset = (level * gap) + defaultsize;

        if (prop)
        {
            let image = cellinfo._query_status_treecontrol(datarow, prop);
            if (image)
            {
                let orgVal = image;
                if (image.substring(0, 4).toLowerCase() == "url(")
                {
                    image = image.substring(5, image.length - 2);
                }

                image = nexacro._getImageLocation(image, this._getRefFormBaseUrl());
                let size = nexacro._getImageSize(image, this._on_treeloadImagetemp, this, this._getRefFormBaseUrl(), orgVal);
                if (size)
                    buttonwidth = size.width;
            }
        }

        var buttonLeft = offset - (buttonwidth / 2);

        if (buttonLeft < 0)
            buttonLeft = offset - (defaultsize / 2);

        var retn;
        if (!is_groupcol)
            retn = buttonwidth + buttonLeft + 8;   // 8 offset text
        else
            retn = buttonwidth + buttonLeft * 2;

        return retn;
    };

    _pGrid._isPassPrevCell = function (area, cells, type, idx)
    {
        var rowcnt = area.endsubrow.length;
        var b_subrow = area.begsubrow;
        var e_subrow = area.endsubrow;
        var b_col = area.begcol;
        var e_col = area.endcol;
        var cellcnt = cells.length;
        var i, j, n;

        if (type == "next" || type == "prev")
        {
            for (i = 0; i < rowcnt; i++)
            {
                for (j = 0; j < cellcnt; j++)
                {
                    if (b_subrow[i] <= cells[j]._row && e_subrow[i] >= cells[j]._row)
                    {
                        if (cells[j]._colspan > 1)
                        {
                            if (type == "next" && cells[j]._col < idx && idx < cells[j]._col + cells[j]._colspan)
                                return true;
                            else if (type == "prev" && cells[j]._col <= idx && idx < cells[j]._col + cells[j]._colspan - 1)
                                return true;
                        }
                    }
                }
            }
        }
        else
        {
            for (i = 0, n = cells.length; i < n; i++)
            {
                if (b_col <= cells[i]._col && e_col >= cells[i]._col)
                {
                    if (cells[i]._rowspan > 1)
                    {
                        if (type == "down" && cells[i]._row < idx && idx < cells[i]._row + cells[i]._rowspan)
                            return true;
                        else if (type == "up" && cells[i]._row <= idx && idx < cells[i]._row + cells[i]._rowspan - 1)
                            return true;
                    }
                }
            }
        }
        return false;
    };

    _pGrid._getAreaMoveCell = function (type, afterIdx, row)
    {
        var selectinfo = this._selectinfo;

        if (selectinfo.area.length == 0)
            return true;

        var area = selectinfo.area[selectinfo.area.length - 1];
        var cells = this._curFormat._bodycells;

        if (type == "next")
        {
            if (selectinfo.ctrlpoint.col < afterIdx)
            {
                if (area.endcol >= afterIdx)
                    return false;
            }
            else
            {
                if (this._isPassPrevCell(area, cells, type, afterIdx))
                    return false;
            }
        }
        else if (type == "prev")
        {
            if (selectinfo.ctrlpoint.col > afterIdx)
            {
                if (area.begcol <= afterIdx)
                    return false;
            }
            else
            {
                if (this._isPassPrevCell(area, cells, type, afterIdx))
                    return false;
            }
        }
        else if (type == "down")
        {
            if (selectinfo.ctrlpoint.row < row || (selectinfo.ctrlpoint.row == row && selectinfo.ctrlpoint.subrow < afterIdx))
            {
                if (area.endsubrow.length == (row - selectinfo.ctrlpoint.row + 1))
                {
                    if (area.endsubrow[area.endsubrow.length - 1] >= afterIdx)
                        return false;
                }
            }
            else
            {
                if (this._isPassPrevCell(area, cells, type, afterIdx))
                    return false;
            }
        }
        else if (type == "up")
        {
            if (selectinfo.ctrlpoint.row > row || (selectinfo.ctrlpoint.row == row && selectinfo.ctrlpoint.subrow > afterIdx))
            {
                if (area.begsubrow.length == (selectinfo.ctrlpoint.row - row + 1))
                {
                    if (area.begsubrow[0] <= afterIdx)
                        return false;
                }
            }
            else
            {
                if (this._isPassPrevCell(area, cells, type, afterIdx))
                    return false;
            }
        }
        return true;
    };

    _pGrid._moveToCell = function (type, editable, colmove, area, lastcol, showcell)
    {
        if (!this._curFormat || !this._curFormat._bodycells)
        {
            return false;
        }

        var retn = false;
        var beforeCell, beforeCol, beforeRow, beforeSubrow, beforePvt;
        var afterCell, afterCol, afterRow, afterSubrow;
        var afterPvt = -9;

        beforeCell = this._beforebodycellpos = this._selectinfo.curcell;
        beforeCol = this._beforebodycolpos = this._selectinfo.curcol;
        beforeRow = this._beforebodyrowpos = this._selectinfo.curdsrow;
        beforeSubrow = this._beforebodysubrowpos = this._selectinfo.cursubrow;

        if (this._tempmergeeditor)
        {
            while (true)
            {
                if (this.__moveToCell(type, editable, colmove, area, lastcol, showcell))
                {
                    retn = true;
                    afterCell = this._selectinfo.curcell;
                    afterCol = this._selectinfo.curcol;
                    afterRow = this._selectinfo.curdsrow;
                    afterSubrow = this._selectinfo.cursubrow;

                    var cell = this._getCurrentBodyCell(afterRow, afterCell);

                    if (cell._virtualmerge)
                        continue;
                }
                break;
            }
        }
        else
        {
            retn = this.__moveToCell(type, editable, colmove, area, lastcol, showcell);
            afterCell = this._selectinfo.curcell;
            afterCol = this._selectinfo.curcol;
            afterRow = this._selectinfo.curdsrow;
            afterSubrow = this._selectinfo.cursubrow;
        }

        if (!retn)
            return false;

        var evt_name;
        this._iskey_movetocell = false;

        if (this._keydown_elem)
        {
            this._iskey_movetocell = true;
            evt_name = "keydown";
        }

        this._hideEditor(undefined, undefined, this._need_confirm_control_value);
        var change = this._ChangeSelect(afterCell, afterCol, afterRow, afterSubrow, afterPvt, false, beforeCell, beforeCol, beforeRow, beforeSubrow, beforePvt, "body", evt_name);
        /*
                var cell;
        
                if (change == false)
                    cell = this._getCurrentBodyCell(beforeRow, beforeCell);
                else
                    cell = this._getCurrentBodyCell(afterRow, afterCell);
                    */
        if (!this._keydown_elem)
        {
            nexacro._OnceCallbackTimer.callonce(this, function ()
            {
                this._moveCellAfterFocus();
            });
        }
        else
        {
            if (change == false)
            {

                if (this._p_autoenter == "select")
                {
                    nexacro._OnceCallbackTimer.callonce(this, function ()
                    {
                        this._showEditor();
                    });
                }

            }
        }
        return true;
    };

    _pGrid.__moveToCell = function (type, editable, colmove, area, lastcol, showcell)
    {
        if (this._selectinfo.curdsrow < 0)
        {
            if (!editable)
            {
                if (this._p_rowcount > 0 && (type == "next" || type == "down"))
                    return this._moveToPosCell(0, 0);
            }
            else
            {
                var editcell = this._getFirstEditableCell();

                if (editcell.row !== null)
                {
                    if (this._vscrollmng)
                        this._vscrollmng.setPos(0);

                    return this._moveToPosCell(editcell.row, editcell.cell);
                }
            }
            return false;
        }

        var format = this._curFormat;
        var beforeCell, beforeCol, beforeRow, beforeSubrow, beforePvt;
        var afterCell, afterCol, afterRow, afterSubrow;
        var afterPvt = -9;
        var cellarr;
        var bodycells = format._bodycells;
        var bodycells_len = bodycells.length;
        var i;
        var _treeKeys;
        var row;
        var rowcount;
        var prevcell, prevcol, prevsubrow;
        var selectedrowspan;
        var newsubrow;
        var cellinfo;
        var editType;
        var obj;

        /*
        beforeCell = this._beforebodycellpos = this._selectinfo.curcell;
        beforeCol = this._beforebodycolpos = this._selectinfo.curcol;
        beforeRow = this._beforebodyrowpos = this._selectinfo.curdsrow;
        beforeSubrow = this._beforebodysubrowpos = this._selectinfo.cursubrow;
        */
        if (type == "next")
        {
            if (editable)
            {
                cellarr = this._getLastEditableCell();
                if (cellarr.row == null || (cellarr.row <= this._selectinfo.curdsrow && cellarr.cell == this._selectinfo.curcell))
                {
                    this._hideEditor();
                    /*
                    beforeCell = this._beforebodycellpos = this._selectinfo.curcell;
                    beforeCol = this._beforebodycolpos = this._selectinfo.curcol;
                    beforeRow = this._beforebodyrowpos = this._selectinfo.curdsrow;
                    beforeSubrow = this._beforebodysubrowpos = this._selectinfo.cursubrow;
                    */
                    if (this._setdataobj && this._setdataobj.succ == false)
                    {
                        beforeCell = this._beforebodycellpos = this._selectinfo.curcell;
                        beforeCol = this._beforebodycolpos = this._selectinfo.curcol;
                        beforeRow = this._beforebodyrowpos = this._selectinfo.curdsrow;
                        beforeSubrow = this._beforebodysubrowpos = this._selectinfo.cursubrow;

                        /* cancolumnchange에서 false이면 이동 하지 않음*/
                        this._setSelectedInfo(beforeCell, beforeCol, beforeRow, beforeSubrow, beforePvt);
                        this._iskey_movetocell = true;
                        this._setdataobj = null;

                        if (this._p_autoenter == "select")
                            this._showEditor();

                        return true;
                    }
                    return false;
                }
            }

            while (true)
            {
                rowcount = this._p_rowcount;
                if (this._selectinfo.currow >= (rowcount - 1) && this._selectinfo.curcell >= (format._bodycells.length - 1))
                    return false;

                if (this._selectinfo.curcell >= bodycells.length - 1)
                {
                    if (colmove)
                        return false;
                    while (true)
                    {
                        afterCell = 0;
                        afterCol = 0;
                        afterRow = this._selectinfo.curdsrow + 1;
                        afterSubrow = 0;

                        this._setSelectedInfo(afterCell, afterCol, afterRow, afterSubrow, afterPvt);

                        if (this._hasTree)
                        {
                            _treeKeys = this._treeKeys;
                            row = _treeKeys.indexOf(afterRow);

                            if (row != undefined)
                                break;

                            continue;
                        }
                        break;
                    }

                }
                else
                {
                    if (colmove)
                    {
                        afterCell = this._selectinfo.curcell;
                        afterCol = bodycells[this._selectinfo.curcell]._col + bodycells[this._selectinfo.curcell]._colspan;
                        afterRow = this._selectinfo.curdsrow;
                        afterSubrow = this._selectinfo.cursubrow;

                        for (i = 0; i < bodycells_len; i++)
                        {
                            if (bodycells[i]._col == afterCol && (bodycells[i]._row <= this._selectinfo.cursubrow && this._selectinfo.cursubrow < (bodycells[i]._row + bodycells[i]._rowspan)))
                            {
                                if (!area || area == bodycells[i]._area)
                                {
                                    afterCell = i;
                                    afterSubrow = bodycells[i]._row;
                                    break;
                                }
                            }
                        }

                        if (afterCell == this._selectinfo.curcell)
                            return false;
                    }
                    else
                    {
                        afterCell = this._selectinfo.curcell + 1;
                        afterCol = bodycells[afterCell]._col;
                        afterRow = this._selectinfo.curdsrow;
                        afterSubrow = bodycells[afterCell]._row;
                    }

                    if (lastcol != undefined && lastcol < afterCol)
                        return false;

                    this._setSelectedInfo(afterCell, afterCol, afterRow, afterSubrow, afterPvt);

                    // width가 0이면 없는 걸로 간주
                    if (format._cols[afterCol].getSize() <= 0)
                        continue;

                    if (this._isAreaSelect())
                    {
                        if (!this._getAreaMoveCell(type, afterCol, afterRow))
                            continue;
                    }
                }

                if (editable)
                {
                    if (this._hasTree)
                    {
                        _treeKeys = this._treeKeys;
                        row = _treeKeys.indexOf(afterRow);

                        if (row != undefined)
                            break;

                        continue;
                    }

                    cellinfo = bodycells[afterCell];
                    editType = cellinfo._getEdittype(afterRow);

                    if (editType == "" || editType == "none")
                        continue;
                }

                if (showcell && afterRow >= 0)
                {
                    obj = this._getCurrentBodyCell(afterRow, afterCell);
                    if (obj)
                        obj._showfull(obj);  // up, down은 다른 곳에서 처리
                }
                break;
            }
        }
        else if (type == "prev")
        {
            while (true)
            {
                if (this._selectinfo.curcell <= 0)
                {
                    if (colmove || this._selectinfo.currow <= 0)
                    {
                        this._hideEditor();
                        /*
                        beforeCell = this._beforebodycellpos = this._selectinfo.curcell;
                        beforeCol = this._beforebodycolpos = this._selectinfo.curcol;
                        beforeRow = this._beforebodyrowpos = this._selectinfo.curdsrow;
                        beforeSubrow = this._beforebodysubrowpos = this._selectinfo.cursubrow;
                        */
                        if (this._setdataobj && this._setdataobj.succ == false)
                        {
                            beforeCell = this._beforebodycellpos = this._selectinfo.curcell;
                            beforeCol = this._beforebodycolpos = this._selectinfo.curcol;
                            beforeRow = this._beforebodyrowpos = this._selectinfo.curdsrow;
                            beforeSubrow = this._beforebodysubrowpos = this._selectinfo.cursubrow;

                            /* cancolumnchange에서 false이면 이동 하지 않음*/
                            this._setSelectedInfo(beforeCell, beforeCol, beforeRow, beforeSubrow, beforePvt);
                            this._iskey_movetocell = true;
                            this._setdataobj = null;

                            if (this._p_autoenter == "select")
                                this._showEditor();

                            return true;
                        }

                        return false;
                    }

                    while (true)
                    {
                        afterCell = format._bodycells.length - 1;
                        afterCol = bodycells[afterCell]._col;
                        afterRow = this._selectinfo.curdsrow - 1;
                        afterSubrow = bodycells[afterCell]._row;

                        this._setSelectedInfo(afterCell, afterCol, afterRow, afterSubrow, afterPvt);
                        if (this._hasTree)
                        {
                            _treeKeys = this._treeKeys;
                            row = _treeKeys.indexOf(afterRow);

                            if (row != undefined)
                                break;

                            continue;
                        }

                        break;
                    }
                }
                else
                {
                    var newcol;
                    if (colmove)
                    {
                        afterCell = this._selectinfo.curcell;
                        newcol = afterCol = this._selectinfo.curcol - 1;
                        afterRow = this._selectinfo.curdsrow;
                        afterSubrow = this._selectinfo.cursubrow;

                        for (i = 0; i < bodycells_len; i++)
                        {
                            if ((bodycells[i]._col <= afterCol && afterCol < bodycells[i]._col + bodycells[i]._colspan) &&
                                (bodycells[i]._row <= this._selectinfo.cursubrow && this._selectinfo.cursubrow < (bodycells[i]._row + bodycells[i]._rowspan)))
                            {
                                if (!area || area == bodycells[i]._area)
                                {
                                    afterCol = bodycells[i]._col;
                                    afterCell = i;
                                    afterSubrow = bodycells[i]._row;
                                    break;
                                }
                            }
                        }
                        if (afterCell == this._selectinfo.curcell)
                            return false;
                    }
                    else
                    {
                        afterCell = this._selectinfo.curcell - 1;
                        newcol = afterCol = bodycells[afterCell]._col;
                        afterRow = this._selectinfo.curdsrow;
                        afterSubrow = bodycells[afterCell]._row;
                    }

                    if (lastcol != undefined && lastcol > afterCol)
                        return false;

                    this._setSelectedInfo(afterCell, afterCol, afterRow, afterSubrow, afterPvt);

                    // width가 0이면 없는 걸로 간주
                    if (format._cols[afterCol].getSize() <= 0)
                        continue;

                    if (this._isAreaSelect())
                    {
                        if (!this._getAreaMoveCell(type, newcol, afterRow))
                            continue;
                    }
                }

                if (editable)
                {
                    if (this._hasTree)
                    {
                        _treeKeys = this._treeKeys;
                        row = _treeKeys.indexOf(afterRow);

                        if (row != undefined)
                            break;

                        continue;
                    }

                    cellinfo = bodycells[afterCell];
                    editType = cellinfo._getEdittype(afterRow);

                    if (editType == "" || editType == "none")
                        continue;
                }

                if (showcell && afterRow >= 0)
                {
                    obj = this._getCurrentBodyCell(afterRow, afterCell);
                    if (obj)
                        obj._showfull(obj);  // up, down은 다른 곳에서 처리
                }

                break;
            }
        }
        else if (type == "up")
        {
            prevcell = -1;
            prevcol = -1;
            prevsubrow = -1;
            //            selectedcol = this._selectinfo.curcol;

            while (true)
            {
                if (this._isSelectRowType())
                {
                    if (this._selectinfo.curdsrow == 0)
                        return false;

                    afterCell = this._selectinfo.curcell;
                    afterCol = this._selectinfo.curcol;
                    afterRow = this._selectinfo.curdsrow - 1;
                    afterSubrow = this._selectinfo.cursubrow;
                }
                else
                {
                    if (this._selectinfo.curdsrow == 0 && this._selectinfo.cursubrow == 0)
                        return false;

                    if (this._fixed_startrow >= this._selectinfo.curdsrow)
                        return false;

                    //                    selectedrowspan = bodycells[this._selectinfo.curcell]._rowspan;

                    if (this._selectinfo.cursubrow == 0)
                    {
                        for (i = bodycells_len - 1; i >= 0; i--)
                        {
                            if (bodycells[i]._col <= this._selectinfo.curcol && this._selectinfo.curcol < (bodycells[i]._col + bodycells[i]._colspan))
                            {
                                prevcell = bodycells[i]._cellidx;
                                prevcol = bodycells[i]._col;
                                prevsubrow = bodycells[i]._row;
                                newsubrow = prevsubrow + bodycells[i]._rowspan - 1;
                                break;
                            }
                        }
                        afterCol = prevcol;
                        afterCell = prevcell;
                        afterRow = this._selectinfo.curdsrow - 1;
                        afterSubrow = prevsubrow;
                    }
                    else
                    {
                        for (i = this._selectinfo.curcell - 1; i >= 0; i--)
                        {
                            if (bodycells[i]._col <= this._selectinfo.curcol && this._selectinfo.curcol < (bodycells[i]._col + bodycells[i]._colspan) &&
                                bodycells[i]._row <= (this._selectinfo.cursubrow - 1) && (this._selectinfo.cursubrow - 1) < (bodycells[i]._row + bodycells[i]._rowspan))
                            {
                                prevcell = bodycells[i]._cellidx;
                                prevcol = bodycells[i]._col;
                                prevsubrow = bodycells[i]._row;
                                newsubrow = prevsubrow + bodycells[i]._rowspan - 1;
                                break;
                            }
                        }

                        afterCol = prevcol;
                        afterCell = prevcell;
                        afterRow = this._selectinfo.curdsrow;
                        afterSubrow = prevsubrow;
                    }
                }

                this._setSelectedInfo(afterCell, afterCol, afterRow, afterSubrow, afterPvt);

                if (this._hasTree)
                {
                    _treeKeys = this._treeKeys;
                    row = _treeKeys.indexOf(afterRow);

                    if (row != undefined)
                        break;

                    continue;
                }

                if (this._isAreaSelect())
                {
                    if (!this._getAreaMoveCell(type, newsubrow, afterRow))
                        continue;
                }

                break;
            }
        }
        else if (type == "down")
        {
            rowcount = this._getGridRowCount();
            var curr = this._dsRowToDispRow(this._selectinfo.curdsrow);
            var lastsubrow = format._bodyrows.length - 1;
            var nextcell = -1, nextcol = -1, nextsubrow = -1;
            //            selectedcol = this._selectinfo.curcol;
            //            var selectedsubrow = this._selectinfo.cursubrow;

            while (true)
            {
                if (this._isSelectRowType())
                {
                    if (rowcount - 1 <= curr)
                        return false;

                    afterCell = this._selectinfo.curcell;
                    afterCol = this._selectinfo.curcol;
                    afterRow = this._selectinfo.curdsrow + 1;
                    afterSubrow = this._selectinfo.cursubrow;
                }
                else
                {
                    selectedrowspan = bodycells[this._selectinfo.curcell]._rowspan;

                    if (rowcount - 1 <= curr && (this._selectinfo.cursubrow + selectedrowspan) - 1 == lastsubrow)
                    {
                        if (this._vscrollmng)
                            this._vscrollmng.setPos(this._vscrollmng.max);

                        return false;
                    }

                    if ((this._selectinfo.cursubrow + selectedrowspan - 1) == lastsubrow)
                    {
                        for (i = 0; i < bodycells_len; i++)
                        {
                            if (bodycells[i]._col <= this._selectinfo.curcol && this._selectinfo.curcol < (bodycells[i]._col + bodycells[i]._colspan))
                            {
                                nextcell = bodycells[i]._cellidx;
                                nextcol = bodycells[i]._col;
                                nextsubrow = bodycells[i]._row;
                                break;
                            }
                        }
                        afterCol = nextcol;
                        afterCell = nextcell;
                        afterRow = this._selectinfo.curdsrow + 1;
                        afterSubrow = nextsubrow;
                    }
                    else
                    {
                        for (i = this._selectinfo.curcell + 1; i < bodycells_len; i++)
                        {
                            if (bodycells[i]._col <= this._selectinfo.curcol && this._selectinfo.curcol < (bodycells[i]._col + bodycells[i]._colspan) &&
                                (bodycells[i]._row == this._selectinfo.cursubrow + (selectedrowspan - 1) + 1))
                            {
                                nextcell = bodycells[i]._cellidx;
                                nextcol = bodycells[i]._col;
                                nextsubrow = bodycells[i]._row;
                                break;
                            }
                        }

                        afterCol = nextcol;
                        afterCell = nextcell;
                        afterRow = this._selectinfo.curdsrow;
                        afterSubrow = nextsubrow;
                    }
                }

                this._setSelectedInfo(afterCell, afterCol, afterRow, afterSubrow, afterPvt);

                if (this._hasTree)
                {
                    _treeKeys = this._treeKeys;
                    row = _treeKeys.indexOf(afterRow);

                    if (row != undefined)
                        break;

                    continue;
                }

                if (this._isAreaSelect())
                {
                    if (!this._getAreaMoveCell(type, afterSubrow, afterRow))
                        continue;
                }

                break;
            }
        }



        return true;
    };

    _pGrid._moveCellAfterFocus = function ()
    {
        var retn = true;

        if (this._p_autoenter == "select")
        {
            if (nexacro._Browser == "Opera")
            {
                this._onceTime_focus = true;
            }

            if (this._currentBand == "body" && !this._showEditor())
            {
                if (this._is_data_enter_apply)
                {
                    this._is_data_enter_apply = false;
                    this._hideEditor();
                }
                else
                {

                    this._showEditor();

                }

                retn = false;
            }
            this._onceTime_focus = false;
        }
        return retn;
    };

    _pGrid._setTree = function (v, no_recreate)
    {
        v = nexacro._toBoolean(v);

        if (this._hasTree != v)
        {
            this._hasTree = v;

            if (v == true)
            {
                this._setFixedRow(-1, true);
                this._initTreeStates();
            }
            else
            {
                this._clearTreeStates();
            }
            if (!no_recreate)
                this._recreate_contents_all(false, false, true);
        }
    };

    _pGrid._resetTreeCellinfo = function (no_recreate)
    {
        var format = this._curFormat;
        var cells = format._bodycells;
        var bset = false;

        for (var i = 0; i < cells.length; i++)
        {
            var disptype = cells[i]._p_displaytype;
            if (disptype == "rowgroupcontrol" || disptype == "treeitemcontrol")
            {
                this._setTreeCellinfo(cells[i], no_recreate);
                bset = true;
            }

            if (bset)
                break;
        }

        if (bset)
            this._initTreeStates();
        else
            this._removeTreeCellinfo(this._treeCellinfo, no_recreate);
    };

    _pGrid._setTreeCellinfo = function (v, no_recreate)
    {
        if (this._treeCellinfo != v)
        {
            this._treeCellinfo = v;
            this._setTree(true, no_recreate);
        }
    };

    _pGrid._removeTreeCellinfo = function (v, no_recreate)
    {
        if (this._treeCellinfo == v)
        {
            this._treeCellinfo = null;
            this._setTree(false, no_recreate);
        }
    };

    _pGrid._initTreeStates = function (keepstate, recheck_leaf)
    {
        if (this._hasTree && this._binddataset)
        {
            this._treeIndexes = this._createTreeIndexes();
            this._treeStates = this._createTreeStates(keepstate, undefined, recheck_leaf);
            this._treeChecked = this._createTreeChecked();
            this._createTreeHasChild();
            this._applyTreeStates();
            this._createTreeKeys();

            if (this._treeIndexes.length > 0)
                this._p_rowcount = this._treeIndexes.length;
            else
                this._p_rowcount = 0;
        }
    };

    _pGrid._createTreeHasChild = function ()
    {
        var rowcount = this._rowcount;
        var cellinfo = this._treeCellinfo;

        if (this._hasSameNextNode)
            delete this._hasSameNextNode;

        this._hasSameNextNode = new Array(rowcount);

        for (var i = rowcount - 1; i >= 0; i--)
        {
            var lvl = cellinfo._getTreeLevel(i);
            this._maxdepth = Math.max(lvl, this._maxdepth);
            this._rootlevel = Math.min(lvl, this._rootlevel);

            if (this._hasSameNextNode[i] == undefined)
            {
                var val = [];
                val[0] = lvl;
                val[1] = false;
                this._hasSameNextNode[i] = val;

                for (var j = i - 1; j >= 0; j--)
                {
                    var lvl2 = cellinfo._getTreeLevel(j);
                    if (lvl == lvl2)
                    {
                        val = [];
                        val[0] = lvl;
                        val[1] = true;
                        this._hasSameNextNode[j] = val;
                    }
                    else if (lvl > lvl2)
                    {
                        break;
                    }
                }
            }
        }

        this._rootlevel = Math.max(cellinfo._getTreeStartLevel(0), this._rootlevel);
    };

    _pGrid._createTreeKeys = function ()
    {
        if (this._binddataset == null)
            return;

        var rowcount = this._binddataset._p_rowcount;
        var keys;

        if (this._treeKeys)
        {
            this._treeKeys.clear();
            keys = this._treeKeys;
        }
        else
        {
            keys = this._treeKeys = new nexacro.Collection();
        }

        for (var i = 0; i < rowcount; i++)
            keys.setItem(this._treeIndexes[i], i); // (key, val)
    };

    _pGrid._createTreeIndexes = function ()
    {
        if (this._binddataset == null)
            return [];

        var rowcount = this._binddataset._p_rowcount;
        var indexes = new Array(rowcount);

        for (var i = 0; i < rowcount; i++)
            indexes[i] = i;

        return indexes;
    };

    _pGrid._getTreeInitStatusValue = function ()
    {
        if (this._treeCellinfo._p_displaytype == "rowgroupcontrol")
            return this._groupinitstatus;

        return this._p_treeinitstatus;
    };

    _pGrid._getTreeDefaultStatus = function ()
    {
        var initstatus = this._treeInitStatus[this._getTreeInitStatusValue()];

        if (initstatus == null)
            initstatus = 0;

        var defaultstatus;

        if (initstatus == 0 || initstatus == 1)
            defaultstatus = (initstatus == 0) ? 0 : 1;
        else if (initstatus == 2 || initstatus == 3)
            defaultstatus = (initstatus == 2) ? 0 : 1;

        return defaultstatus;
    };

    _pGrid._createTreeStates = function (keepstate, ignoreDS, recheck_leaf)
    {
        if (this._binddataset == null)
            return [];

        var dataset = this._binddataset;
        var rowcount = dataset._p_rowcount;
        var states = new Array(rowcount);
        var cellinfo = this._treeCellinfo;
        var initstatus = this._treeInitStatus[this._getTreeInitStatusValue()];
        var state = null;
        var level;
        var prelevel;
        var prestate;

        if (initstatus == null)
            initstatus = 0;

        var oldstates = this._treeStates;
        var i;
        var defaultstatus;

        if (keepstate && oldstates.length == rowcount)
        {
            for (i = 0; i < rowcount; i++)
            {
                states[i] = oldstates[i];
            }
        }

        // initstatus --> "collapse,null": 0, "expand,null": 1, "collapse,all": 2, "expand,all": 3

        if (initstatus == 0 || initstatus == 1)
        {
            defaultstatus = (initstatus == 0) ? 0 : 1;
            prelevel = -1;

            for (i = 0; i < rowcount; i++)
            {
                if (!ignoreDS)
                {
                    state = cellinfo._getTreeState(i);
                }

                if (states[i] == undefined || (recheck_leaf && states[i] == 2))
                {
                    if (nexacro._isNull(state) || state === "")
                    {
                        states[i] = defaultstatus;
                    }
                    else if (nexacro._isString(state))
                    {
                        states[i] = Number(state);
                    }
                    else
                    {
                        states[i] = state;
                    }
                }

                level = cellinfo._getTreeLevel(i);

                if (nexacro._isNull(prestate) || prestate === "" || cellinfo.treestate._bindtype == 0)
                {
                    if (prelevel >= level)
                    {
                        states[i - 1] = 2; // leaf
                    }
                    else if (states[i - 1] >= 2)
                    {
                        states[i - 1] = defaultstatus;
                    }
                }
                prelevel = level;
                prestate = state;
            }

            if (cellinfo.treestate._bindtype == 0 || nexacro._isNull(state))
                states[rowcount - 1] = 2;
        }
        else if (initstatus == 2 || initstatus == 3)
        {
            defaultstatus = (initstatus == 2) ? 0 : 1;
            prelevel = -1;

            for (i = 0; i < rowcount; i++)
            {
                if (states[i] == undefined || (recheck_leaf && states[i] == 2))
                {
                    states[i] = defaultstatus;
                }

                level = cellinfo._getTreeLevel(i);
                if (prelevel >= level)
                {
                    states[i - 1] = 2; // leaf
                }
                prelevel = level;
            }

            if (rowcount > 0)
                states[rowcount - 1] = 2;
        }

        if (this._org_treeStates.length == 0)
            this._org_treeStates = this._org_treeStates.concat(states);

        return states;
    };

    _pGrid._getCheck = function (col, row, subrow)
    {
        if (subrow == undefined)
            subrow = 0;

        if (row < 0)
        {
            var cell = this._getColumnCellinfos(col, row, subrow)[0];
            return cell._value;
        }
        else
        {
            if (this._group_checked && this._group_checked.length > 0)
            {
                var rowslen = this._curFormat._bodyrows.length;
                var check = this._group_checked[col][row * rowslen + subrow];

                if (check.bind == null)
                    return check.value;
                else
                    return check.cellinfo._getTextValueForDisp(row);
            }
            else
            {
                var cellinfo = this._getColumnCellinfos(col, row, subrow)[0];
                return cellinfo._getTextValueForDisp(row);
            }
        }
    };

    _pGrid._setCheck = function (col, row, subrow, val, false_value, no_groupproc)
    {
        if (subrow == undefined)
            subrow = 0;

        var format = this._curFormat;

        if (row < 0)
        {
            this._setCheckHeadSumm(col, row, subrow, val);
        }
        else
        {
            var dataset = this._binddataset;
            var rowslen = format._bodyrows.length;
            var check = this._group_checked[col][row * rowslen + subrow];

            if (check.bind == 1)
            {
                return dataset.setColumn(row, check.value, val);
                // remove head check <- oncolumnchanged...
            }
            else if (check.bind == null)
            {
                check.value = val;

                var disprow = this._dsRowToDispRow(row, true);
                this._refreshCol(col, false, "body", disprow);

                if (!no_groupproc)
                {
                    if (dataset.getRowType(row) == 32)    // group head
                        this._checkAllGroup(col, row, subrow, val);
                }
            }

            if (nexacro._toBoolean(val) == false || val == false_value)
            {
                if (!no_groupproc)
                {
                    var vv = check.cellinfo._convCheckValueToBoolean(val, row);
                    this._setCheckGroupHead(col, row, subrow, false_value, vv, true);
                }

                subrow = this._getCheckSubrow(col, row, subrow);
                val = check.cellinfo._convCheckValueToBoolean(val, row);

                this._setCheckHeadSumm(col, -1, subrow, val, true, true);   // remove head check
            }
        }
        return true;
    };

    _pGrid._setCheckGroupHead = function (col, row, subrow, false_value, val, conv_check_value)
    {
        var dataset = this._binddataset;

        if (dataset.getMaxRowLevel() > 0) // use group
        {
            var curr_rowlv = dataset.getRowLevel(row);
            var curr_rowtp = dataset.getRowType(row);

            for (row--; row >= 0; row--)
            {
                var prev_rowlv = dataset.getRowLevel(row);
                var proc;

                if (curr_rowtp == 16)
                    proc = prev_rowlv >= curr_rowlv;
                else
                    proc = prev_rowlv > curr_rowlv;

                if (proc && dataset.getRowType(row) == 32)
                {
                    curr_rowlv = prev_rowlv;
                    curr_rowtp = null;

                    var vv = val;

                    if (conv_check_value)
                    {
                        var cell = this._getColumnCellinfos(col, row, subrow)[0];
                        vv = cell._convBooleanToCheckValue(val, row);
                    }

                    this._setCheck(col, row, subrow, vv, false_value, true);
                }
            }
        }
    };

    _pGrid._setCheckHeadSumm = function (col, row, subrow, val, no_defact, conv_check_value)
    {
        if (row >= 0)
            return;

        if (!subrow)
            subrow = 0;

        if (subrow < 0)
            return;

        var cell = this._getColumnCellinfos(col, row, subrow)[0];
        var edittype = cell._getEdittype(-1);

        if (edittype == "checkbox")
        {
            if (conv_check_value)
                val = cell._convBooleanToCheckValue(val, -1);

            if (cell._setValue(val) && row == -1)
                this._on_fire_onheadvaluechanged(cell._value, val, cell._cellidx, no_defact);

            this._refreshCol(col, false, "head");
        }
    };

    _pGrid._destroyChecked = function (col)
    {
        if (!this._group_checked)
            return;

        this._group_checked[col] = undefined;
        this._check_subrow_map[col] = undefined;
    };

    _pGrid._initChecked = function ()
    {
        var format = this._curFormat;

        if (!format)
            return;

        var cells = format._bodycells;

        if (!cells)
            return;

        this._group_checked = [];
        this._check_subrow_map = [];

        if (cells)
        {
            for (var i = 0; i < cells.length; i++)
            {
                if (cells[i]._p_edittype == "checkbox") // expr 무시
                    this._createChecked(cells[i]._col);
            }
        }

        cells = format._headcells;

        if (cells)
        {
            for (i = 0; i < cells.length; i++)
            {
                if (cells[i]._getEdittype(-1) == "checkbox")
                    cells[i]._setValue(0);
            }
        }
    };

    _pGrid._createChecked = function (col)
    {
        if (this._binddataset == null || !this._curFormat)
            return;

        if (!this._group_checked)
            this._group_checked = [];

        if (this._group_checked[col])
            return;

        if (!this._curFormat._bodyrows)
            return;

        var rowcount = this._binddataset._p_rowcount;
        var rowslen = this._curFormat._bodyrows.length;
        var totalcnt = rowcount * rowslen;
        var checked = new Array(totalcnt);
        var cells = this._getColumnCellinfos(col, 0); // bodycells

        for (var i = 0; i < rowcount; i++)
        {
            for (var j = 0; j < cells.length; j++)
            {
                if (cells[j]._getEdittype(i) == "checkbox")
                {
                    if (cells[j]._p_text._bindtype == 1)
                    {
                        if (this._binddataset.getRowType(i) >= 16)
                            checked[i * rowslen + j] = { cellinfo: cells[j], bind: null, value: null };
                        else
                            checked[i * rowslen + j] = { cellinfo: cells[j], bind: 1, value: cells[j]._p_text._bindexpr };
                    }
                    else if (cells[j]._p_text._bindtype == 2 || (cells[j]._p_expr._value != null && cells[j]._p_expr._value != ""))
                    {
                        checked[i * rowslen + j] = { cellinfo: cells[j], bind: 2, value: null };
                    }
                    else if (cells[j]._p_text._value != null && cells[j]._p_text._value != "")
                    {
                        checked[i * rowslen + j] = { cellinfo: cells[j], bind: 0, value: null };
                    }
                    else
                    {
                        checked[i * rowslen + j] = { cellinfo: cells[j], bind: null, value: null };
                    }
                }
            }
        }

        this._group_checked[col] = checked;
    };

    _pGrid._createTreeChecked = function ()
    {
        if (this._binddataset == null)
            return [];

        var rowcount = this._binddataset._p_rowcount;
        var checked = new Array(rowcount);
        var cellinfo = this._treeCellinfo;
        var v = null;

        for (var i = 0; i < rowcount; i++)
        {
            v = cellinfo._getTreeCheck(i);

            if (v && (v > 0 || v.length))
                checked[i] = parseInt(v, 10);
            else
                checked[i] = 0;
        }

        return checked;
    };

    _pGrid._updateTreeStates = function (row, add_row)
    {
        if (this._hasTree && this._binddataset)
        {
            if (row >= 0)
            {
                var states = this._treeStates;
                if (add_row) // add row states
                {
                    states.splice(row, 0, 2);
                }
                else //delete row states
                {
                    states.splice(row, 1); //delete row states

                    var cellinfo = this._treeCellinfo;
                    var level = cellinfo._getTreeLevel(row);
                    var pre_level = cellinfo._getTreeLevel(row - 1);

                    if (level == pre_level)
                        states[row - 1] = 2;
                }
                this._treeStates = states;
            }

            this._treeIndexes = this._createTreeIndexes();
            this._treeChecked = this._createTreeChecked();
            this._createTreeHasChild();
            this._applyTreeStates();
            this._createTreeKeys();

            if (this._treeIndexes.length > 0)
                this._p_rowcount = this._treeIndexes.length;
            else
                this._p_rowcount = 0;
        }
    };

    _pGrid._applyTreeStates = function ()
    {
        var indexes = this._treeIndexes;
        var states = this._treeStates;
        var rowcount = indexes.length;
        var cellinfo = this._treeCellinfo;
        var v = indexes.slice(0, indexes.length);
        var prelevel = -1;
        var level = -1;
        var offset = 0;

        for (var i = 0; i < rowcount; i++)
        {
            offset++;
            if (states[i] == 0)
            {
                prelevel = cellinfo._getTreeLevel(v[i]);

                for (var j = i + 1; j < rowcount; j++)
                {
                    level = cellinfo._getTreeLevel(v[j]);
                    if (level > prelevel)
                    {
                        i++;
                        indexes.splice(offset, 1);
                    }
                    else
                    {
                        break;
                    }
                }
            }
        }
    };

    _pGrid._clearTreeStates = function ()
    {
        this._treeIndexes = null;
        this._treeStates = null;
        this._treeChecked = null;

        if (this._hasTree)
            this._p_rowcount = 0;

        if (this._treeKeys)
        {
            this._treeKeys.destroy();
            this._treeKeys = null;
        }
    };

    _pGrid._getTreeRowPosition = function (v)
    {
        if (v < 0 || !this._hasTree)
            return v;

        var indexes = this._treeIndexes;
        if (indexes == null)
            return v;

        var max = indexes.length - 1;

        for (var i = max; i >= 0; i--)
        {
            if (indexes[i] == v)
                return i;
            else if (indexes[i] < v)
                break;
        }
        return -1;
    };

    _pGrid._getBindTextCellInfo = function (columnid)
    {
        var format = this._curFormat;
        var bind = true;

        if (!format)
            return null;

        var retn = [];
        var cellinfo;
        var i;

        if (columnid)
        {
            if (format._headcells)
            {
                var _headcells = format._headcells;
                var _headcellsLen = _headcells.length;

                for (i = 0; i < _headcellsLen; i++)
                {
                    cellinfo = _headcells[i];
                    if (cellinfo.text._bindexpr == columnid)
                    {
                        retn.push(cellinfo);
                    }
                }
            }
            if (format._bodycells)
            {
                var _bodycells = format._bodycells;
                var _bodycellsLen = _bodycells.length;

                for (i = 0; i < _bodycellsLen; i++)
                {
                    cellinfo = _bodycells[i];
                    if (cellinfo.text._bindexpr == columnid)
                    {
                        retn.push(cellinfo);
                    }
                }
            }
            if (format._summcells)
            {
                var _summcells = format._summcells;
                var _summcellsLen = _summcells.length;

                for (i = 0; i < _summcellsLen; i++)
                {
                    cellinfo = _summcells[i];
                    if (cellinfo.text._bindexpr == columnid)
                    {
                        retn.push(cellinfo);
                    }
                }
            }
        }
        if (retn.length == 0 && format._bodycells)
        {
            retn = format._bodycells;
            bind = false;
        }
        return [retn, bind];
    };

    _pGrid._isTreeStateChanged = function (e, dsEventOccured)
    {
        var changed = false;

        if (this._hasTree)
        {
            var rowidx = this._getTreeRowPosition(e.row);

            var colid = e.columnid;
            var cellinfo = this._treeCellinfo;

            // tree check가 변경된 경우
            if (colid == cellinfo.treecheck._bindexpr)
            {
                this._setTreeChecked(rowidx, e.newvalue);
            }

            if (dsEventOccured == false)
            {
                // status가 변경된 경우
                if (colid == cellinfo.treestate._bindexpr)
                {
                    this._setTreeState(rowidx, e.newvalue);
                    changed = true;
                }

                var dfstatus = this._getTreeDefaultStatus();
                var initstatus = this._treeInitStatus[this._getTreeInitStatusValue()];
                // level이 변경된 경우

                // lv이 변경되었을때 Grid의 status를 변경하는 조건은 
                //1. { "collapse,null": 0, "expand,null": 1, "collapse,all": 2, "expand,all": 3 }; 2,3 일때
                //2. treestate 속성이 bindexpr이 걸려있지 않을때
                //3. state값이 null,undefined,""과 같이 유효하지 않을때
                if (colid == cellinfo.treelevel._bindexpr)
                {
                    var cur_level, cur_state, hasChild;
                    var states = this._treeStates;

                    var level = cellinfo._getTreeLevel(e.row);

                    var setchange = false;
                    if (initstatus == 0 || initstatus == 1)
                    {
                        if (cellinfo.treestate._bindtype != 0)
                            setchange = true;
                    }


                    for (var i = e.row - 1; i >= 0; i--)
                    {
                        cur_level = cellinfo._getTreeLevel(i);
                        cur_state = cellinfo._getTreeState(i);

                        if (cur_level < level)
                        {
                            if (states[i] >= 2)
                            {
                                states[i] = dfstatus;
                            }

                            break;
                        }
                        else if (cur_level > level)
                        {
                            hasChild = true;
                        }
                        else
                        {
                            if (!hasChild)
                            {
                                if (((nexacro._isNull(cur_state) || cur_state === "") && setchange) || !setchange)
                                {
                                    states[i] = 2;
                                }
                            }

                            break;
                        }
                    }

                    if (states[e.row] >= 2)
                    {
                        if (this._rowcount > 0 && e.row < this._rowcount - 1)
                        {
                            cur_level = cellinfo._getTreeLevel(e.row + 1);
                            if (cur_level > level)
                                states[e.row] = dfstatus;
                        }
                    }

                    changed = true;
                }
            }
        }
        return changed;
    };

    _pGrid._setTreeState = function (rowidx, v, redraw, prop_set)
    {
        v = parseInt(v, 10);

        if (isFinite(v))
        {
            var dsrowidx = this._treeIndexes[rowidx];
            var state = this._treeStates[dsrowidx];
            var retn = 0;

            if (v != state)
            {
                if (v == 2)
                {
                    if (redraw)
                    {
                        this._refreshBodyRow(rowidx - this._getBodyBegRowPos(rowidx));
                    }
                    return 1;
                }
                else if ((retn = this._toggleTreeState(rowidx, redraw, v, prop_set)) > 0)
                {
                    return retn;
                }
            }
        }
        return 0;
    };

    _pGrid._getOrgTreeStates = function (rowidx)
    {
        var states;

        if (this._org_treeStates.length)
            states = this._org_treeStates;
        else
            states = this._createTreeStates(false, true);

        if (states[rowidx] == 2)
            return 2;
        else
            return this._treeStates[rowidx];
    };

    _pGrid._treeStateKeyAction = function (rowidx, v)
    {
        var dsrowidx = this._treeIndexes[rowidx];
        var state = this._treeStates[dsrowidx];

        if (state < 2 && state != v)
            return this._toggleTreeState(rowidx, true);

        return 0;
    };

    _pGrid._callback_treetoggle = function (rowidx, collapse)
    {
        var change = this._bodyBand._matrix._adjustTreeDisplay(rowidx, collapse);

        var cellobj = this._getCurrentBodyCell(-1, -1);
        if (cellobj)
            cellobj._apply_setfocus();

        if (change)
        {
            if (this._headBand)
                this._headBand._matrix._adjustColsDisplay(true);
            if (this._summBand)
                this._summBand._matrix._adjustColsDisplay(true);
        }
    };

    _pGrid._supphorztype = 0;
    _pGrid.set_suppresshorzcell = function (v)
    {
        switch (v)
        {
            case "none":
                this._supphorztype = 0;
                break;
            case "left":
                this._supphorztype = 1;
                break;
            case "right":
                this._supphorztype = 2;
                break;
            case "leftright":
                this._supphorztype = 3;
                break;
            default:
                return;
        }

        if (v != this._p_suppresshorzcell)
        {
            this._p_suppresshorzcell = v;
            this.on_apply_suppresshorzcell();
        }
    };

    _pGrid.on_apply_suppresshorzcell = function ()
    {
        this._refreshAll();
    };

    _pGrid.set_treeasynctoggle = function (v)
    {
        if (v != null && this._p_treeasynctoggle != v)
        {
            v = nexacro._toBoolean(v);
            this._p_treeasynctoggle = v;
        }
    };

    _pGrid._toggleTreeState = function (rowidx, redraw, v, prop_set)
    {
        var dsrowidx = this._treeIndexes[rowidx];

        if (this._p_treeasynctoggle)
        {
            if (this._treetogglecell)
                return;

            this._treetogglecell = this._getCurrentBodyCell(dsrowidx, this._treeCellinfo._cellidx);

            if (redraw)
                this._setGlobalCursor("wait", this._treetogglecell);
        }

        var state;

        if (prop_set)
            state = this._getOrgTreeStates(dsrowidx);
        else
            state = this._treeStates[dsrowidx];

        var collapse = false;
        var retn;

        if (state == 0)
        {
            if (this.on_fire_cantreestatuschange(rowidx, dsrowidx, 1) !== false)
            {
                retn = this._expandTreeState(rowidx);
                this.on_fire_ontreestatuschanged(rowidx, dsrowidx, 1);
            }
        }
        else if (state == 1)
        {
            if (this.on_fire_cantreestatuschange(rowidx, dsrowidx, 0) !== false)
            {
                collapse = true;
                retn = this._collapseTreeState(rowidx);
                this.on_fire_ontreestatuschanged(rowidx, dsrowidx, 0);
            }
        }
        else if (state == 2)
        {
            if (prop_set)
            {
                if (prop_set == "null_value")
                    this._treeStates[dsrowidx] = v;
                else
                    this._treeStates[dsrowidx] = 2;
            }
            else
            {
                if (this.on_fire_cantreestatuschange(rowidx, dsrowidx, 0) !== false)
                {

                    retn = 1;
                    if (v != undefined)
                        this._treeStates[dsrowidx] = v;
                    else
                        this._treeStates[dsrowidx] = 2;
                    this.on_fire_ontreestatuschanged(rowidx, dsrowidx, 0);
                }
            }
        }

        if (redraw)
        {
            if (retn == 2)
            {
                if (this._bodyBand)
                {
                    if (this._p_enableredraw)
                    {
                        if (this._p_treeasynctoggle)
                        {
                            var pthis = this;
                            nexacro._OnceCallbackTimer.callonce(this, function ()
                            {
                                pthis._setGlobalCursor(null, this._treetogglecell);
                                pthis._callback_treetoggle(rowidx, collapse);
                                pthis._treetogglecell = null;
                            }, 50);
                        }
                        else
                        {
                            this._callback_treetoggle(rowidx, collapse);
                        }
                    }
                    else
                        this._enable_redraw_history.recreate_body = true;
                }
            }
            else if (retn == 1)
            {
                this._refreshBodyRow(rowidx - this._getBodyBegRowPos(rowidx));

                if (this._p_treeasynctoggle)
                {
                    if (this._treetogglecell)
                    {
                        this._setGlobalCursor(null, this._treetogglecell);
                        this._treetogglecell = null;
                    }
                }
            }
        }
        else
        {
            if (this._p_treeasynctoggle)
            {
                if (this._treetogglecell)
                {
                    this._setGlobalCursor(null, this._treetogglecell);
                    this._treetogglecell = null;
                }
            }
        }

        return retn;
    };

    _pGrid._collapseTreeState = function (rowidx)
    {
        var indexes = this._treeIndexes;
        var states = this._treeStates;
        var rowcount = indexes.length;
        var dsrowidx = indexes[rowidx];
        var cellinfo = this._treeCellinfo;

        if (states[dsrowidx] == 1)
            states[dsrowidx] = 0;
        else
            return 0;

        var level = cellinfo._getTreeLevel(dsrowidx);

        if (this._env._p_enableaccessibility)
        {
            var cellobj = this._getAccessibilityCurrentCell();
            if (cellobj)
            {
                //expand,collapse 상태를 읽지 않을 경우
                if (nexacro._OS == "Android" && nexacro._Browser != "Runtime")
                    cellobj._setAccessibilityStatLive(true);
                cellobj._setAccessibilityStatExpanded(false);
            }

        }

        var lvl = -1;
        var count = 0;

        for (var i = rowidx + 1; i < rowcount; i++)
        {
            lvl = cellinfo._getTreeLevel(indexes[i]);

            if (lvl > level)
                count++;
            else
                break;
        }

        if (count > 0)
        {
            indexes.splice(rowidx + 1, count);
            this._createTreeKeys();
            this._p_rowcount = indexes.length;	// rowcount property set
            return 2;
        }

        return 1;
    };

    _pGrid._expandTreeState = function (rowidx)
    {
        var indexes = this._treeIndexes;
        var states = this._treeStates;
        var rowcount = states.length;
        var dsrowidx = indexes[rowidx];
        var cellinfo = this._treeCellinfo;

        if (states[dsrowidx] == 0)
            states[dsrowidx] = 1;
        else
            return 0;

        var level = cellinfo._getTreeLevel(dsrowidx);

        if (this._env._p_enableaccessibility)
        {
            var cellobj = this._getAccessibilityCurrentCell();
            if (cellobj)
            {
                //expand,collapse 상태를 읽지 않을 경우
                if (nexacro._OS == "Android" && nexacro._Browser != "Runtime")
                    cellobj._setAccessibilityStatLive(true);
                cellobj._setAccessibilityStatExpanded(true);
            }

        }

        var lvl = -1;
        var count = 0;
        var parentidx = dsrowidx;
        var parents = [dsrowidx];
        var preidx = -1;
        var prelevel = -1;
        var close = false;
        var depth;
        var curent_plv = -1;

        for (var i = dsrowidx + 1; i < rowcount; i++)
        {
            lvl = cellinfo._getTreeLevel(i);

            if (lvl > level)
            {
                if (preidx < 0)
                {
                    if ((depth = (lvl - level)) > 1)
                    {
                        for (var j = 0; j < depth - 1; j++)
                        {
                            parents.push(preidx);
                            curent_plv = -1;
                        }
                    }
                }
                else
                {
                    prelevel = cellinfo._getTreeLevel(preidx);
                    if (lvl > prelevel)
                    {
                        if (close == true)
                            continue;

                        parentidx = preidx;
                        if ((depth = (lvl - prelevel)) > 1)
                        {
                            for (var jj = 0; jj < depth - 1; jj++)
                            {
                                parents.push(preidx);
                                curent_plv = prelevel;
                            }
                        }
                        else
                        {
                            parents.push(preidx);
                            curent_plv = prelevel;
                        }
                    }
                    else if (lvl < prelevel)
                    {
                        var n = prelevel - lvl;
                        var splice = true;
                        if (parents[parents.length - 1] >= 0)
                        {

                            if (curent_plv < lvl)
                            {
                                splice = false;
                            }
                        }
                        if (splice)
                            parents.splice(parents.length - n, n);

                        //parentidx = parents[parents.length - 1];
                        for (var loop = 1; loop <= parents.length; loop++)
                        {
                            parentidx = parents[parents.length - loop];
                            if (parentidx >= 0) break;
                        }

                    }
                    close = false;
                }

                if (states[parentidx] > 0)
                {
                    indexes.splice(rowidx + 1 + count, 0, i);
                    count++;
                }
                else
                {
                    close = true;
                }

                preidx = i;
            }
            else
            {
                break;
            }
        }
        this._createTreeKeys();

        if (count > 0)
        {
            this._p_rowcount = this._treeIndexes.length;	// rowcount property set
            return 2;
        }

        return 1;
    };

    _pGrid._setTreeChecked = function (rowidx, v)
    {
        v = parseInt(v, 10);

        if (isFinite(v))
        {
            var dsrowidx = this._treeIndexes[rowidx];
            var checked = this._treeChecked[dsrowidx];

            if (v == checked)
                return false;
            else
                return (this._toggleTreeChecked(rowidx));
        }

        return false;
    };

    _pGrid._toggleTreeChecked = function (rowidx)
    {
        var dsrowidx = this._treeIndexes[rowidx];
        var checked = this._treeChecked[dsrowidx];
        var v = (checked == 0) ? 1 : 0;
        this._treeChecked[dsrowidx] = v;
        return true;
    };

    _pGrid._getCurrentBodyCell = function (ridx, cidx)
    {
        var band = this._bodyBand;
        if (band)
        {
            if (ridx < 0) ridx = this._selectinfo.curdsrow;
            if (cidx < 0) cidx = this._selectinfo.curcell;

            var row = band._get_row(ridx);

            if (row)
                return row._cells[cidx];
        }
        return null;
    };

    _pGrid._getCurrentHeadCell = function (cidx, noccheck)
    {
        var band = this._headBand;
        if (band && (noccheck || this._currentDSrow == -1))
        {
            if (cidx < 0) cidx = this._p_currentcell;

            var row = band._get_rows()[0];

            if (row)
                return row._cells[cidx];
        }
        return null;
    };

    _pGrid._getCurrentSummCell = function (cidx, noccheck)
    {
        var band = this._summBand;
        if (band && (noccheck || this._currentDSrow == -2))
        {
            if (cidx < 0) cidx = this._p_currentcell;

            var row = band._get_rows()[0];

            if (row)
                return row._cells[cidx];
        }
        return null;
    };

    _pGrid._isFocused = function ()
    {
        var owner_frame = this._getOwnerFrame();
        var form = this._getForm();

        if (!owner_frame && !form._isMainForm())   // window가 닫힌 이후 들어오는 경우..
            return false;

        var is_activate = owner_frame ? owner_frame._activate || form._activate : form._activate;
        var ismodal = false;
        var modalframe = this._getWindow()._getLastModalFrame();

        if (modalframe && !modalframe._contains(this))
            ismodal = true;

        if (is_activate == false || ismodal)
            return false;

        if (this._focused != undefined)
            return this._focused;

        var lastfocus = this._find_lastFocused();

        if (lastfocus instanceof nexacro.Div)
            lastfocus = lastfocus._getLastFocused();

        var retn = true;
        var comp = this;

        if (comp._is_subcontrol)
            comp = this._getRootComponent(comp);

        if (lastfocus != comp)
            retn = false;

        this._focused = retn;
        return retn;
    };

    _pGrid._showEditor = function (focus_cellobj)
    {
        // Modal 아래에 가려진 컴포넌트인 경우 setFocus 차단.
        var win = this._getRootWindow();
        var is_active_layer = win._isActiveLayerComponent(this);
        if (!is_active_layer)
            return;
        if (this._firstEditableCell)
            this._firstEditableCell = null;
        if (this._hide_applydata)
            return true;

        if (nexacro._toBoolean(this._p_readonly) == true)
            return false;

        if (!this._isFocused())
            return false;

        var cellobj = focus_cellobj;

        if (!cellobj)
            cellobj = this._getCurrentBodyCell(-1, -1);

        if (!cellobj)
            return false;

        var startrow = this._getBodyBegRowPos(cellobj._rowidx);
        var endrow = this._endrowpos;
        var currow = this._selectinfo.currow;
        var curcell = this._selectinfo.curcell;

        if (startrow > currow || endrow < currow)
        {
            return false;
        }
        else
        {
            var rowtype = this._binddataset.getRowType(currow);

            if (rowtype != 16 && rowtype != 32)
            {
                if (currow < 0 || (this._beforeEditRowIdx != currow || this._beforeEditCellIdx != curcell))
                {
                    if (cellobj._virtualmerge)
                    {
                        this._showEditorMergeCell(cellobj, true, true);
                    }
                    else if (cellobj._hasEditor())
                    {
                        cellobj._showEditor(true, true);
                        this._beforeEditRowIdx = this._getDataRow(cellobj._rowidx);
                        this._beforeEditCellIdx = cellobj._cellidx;
                        this._showEditing = true;
                    }
                    else
                    {
                        cellobj._setFocus(false);
                        cellobj._setSubControlFocus(true);
                    }
                }
            }
        }

        return true;
    };

    _pGrid._applyMultiContainerScrollPos = function ()
    {
        // Grid 는 예전에 구현된 구조를 쓴다.
        this._notifyParentDisplayOn();
    };
    _pGrid._notifyParentDisplayOn = function ()
    {
        if (this._control_element)
        {
            this._absolutelyResetScrollPos(true);
            this._control_element.setElementHScrollPos(this._control_element.scroll_left);
            this._control_element.setElementVScrollPos(this._control_element.scroll_top);
            this._absolutelyResetScrollPos(false);
        }
    };
    _pGrid._setdataobj = null;
    _pGrid._hideEditor = function (noApplyDataset, grid_killfocus, need_confirm_control_value)
    {
        if (this._FocuedCell && this._FocuedCell._is_alive)
        {
            this._FocuedCell._setSubControlFocus(false);
        }

        if (this._hide_applydata && this._currentCellEditor && !this._currentCellEditor._is_alive == false)
            this._currentCellEditor = null;

        if (this._firstEditableCell)
            this._firstEditableCell = null;
        if (!this._currentCellEditor || this._hide_applydata)
            return false;

        var editComp = this._currentCellEditor;
        var setdataobj = null;

        if (!noApplyDataset && editComp._is_alive)
        {
            this._hide_applydata = true;

            if (need_confirm_control_value)
                editComp._confirmValue();   // <-- 여기서 _pGrid._hideEditor를 호출하는 상황이 있음. this._hide_applydata로 체크...

            setdataobj = { succ: false };
            setdataobj.succ = editComp._setDataset(true);
            if (setdataobj.succ && editComp._cellobj)
                editComp._cellobj._updateAll();

            editComp = this._currentCellEditor; // setdataset 이후 edit가변경될수있음. this._currentCellEditor 가 null 될 수도 있음.

            this._hide_applydata = false;
        }

        if (this._binddataset.enableevent == false)
            this._refreshAll();

        this._currentCellEditor = null;

        if (editComp && editComp._is_alive)
        {
            var cellobj = editComp._cellobj;

            cellobj._setDisplayText();

            if (cellobj._is_mergetemp)
                this._hideEditorMergeCell();
            else
                cellobj._hideEditor();

            if (this._keydown_elem && !grid_killfocus)
                cellobj._setFocus(false);
        }

        this._showEditing = false;
        this._setdataobj = setdataobj;

        this._beforeEditCellIdx = -1;
        this._beforeEditRowIdx = -1;
        this._currentCellCell = -1;
        this._currentCellRow = -1;

        return true;
    };

    _pGrid._evtvalue = function (obj, postvalue, is_inputeditor)
    {
        var val = "";

        if (is_inputeditor)
        {
            if (obj && obj._child_editor)
                obj = obj._child_editor;
        }

        if (obj && obj.value)
            val = obj.value;
        else if (postvalue)
            val = postvalue;

        return val;
    };

    _pGrid._getAvailableRect = function (comp)
    {
        var rect = { left: 0, top: 0, right: 0, bottom: 0, width: 0, height: 0 };
        rect.left = comp._getClientLeft();
        rect.top = comp._getClientTop();
        rect.right = comp._getClientLeft() + comp._getClientWidth();
        rect.bottom = comp._getClientTop() + comp._getClientHeight();
        rect.width = comp._getClientWidth();
        rect.height = comp._getClientHeight();
        return rect;
    };

    _pGrid._getPosRect = function (comp)
    {
        var rect = {
            left: comp._adjust_left,
            top: comp._adjust_top,
            right: comp.getOffsetRight(),
            bottom: comp.getOffsetBottom(),
            width: comp._adjust_width,
            height: comp._adjust_height
        };
        return rect;
    };

    _pGrid._closePopup = function ()
    {
        var edit = this._currentCellEditor;
        if (edit && edit._popupcontrol)
            edit._closePopup();
    };

    _pGrid._getTreeStats = function (rowidx)
    {
        if (rowidx < 0)
            return 2;

        return this._treeStates[rowidx];
    };

    _pGrid._getTreeCheck = function (rowidx)
    {
        return this._treeChecked[rowidx];
    };

    //===============================================================
    // nexacro.Grid : VirtualMerge
    //===============================================================
    // VirtualMerge Logical Part
    _pGrid._initVirtualMerge = function ()
    {
        var i, j;
        var virtualmerge_cellinfos;
        var virtualmerge_arr = this._virtual_mergecell_arr;

        if (this.first_cellinfo)
        {
            this.first_cellinfo._initVirtualMergeInfo();
            this.first_cellinfo = null;
        }

        for (i = 0; i < virtualmerge_arr.length; i++)
        {
            virtualmerge_cellinfos = virtualmerge_arr[i].cellinfos;
            for (j = 0; j < virtualmerge_cellinfos.length; j++)
            {
                virtualmerge_cellinfos[j]._initVirtualMergeInfo();
                virtualmerge_cellinfos[j] = null;
            }
            virtualmerge_arr[i] = null;
        }

        this._virtual_mergecell_arr = [];
    };

    _pGrid._setVirtualMerge = function (scol, srow, ssubrow, ecol, erow, esubrow, release)
    {
        var format = this._curFormat;
        var cellinfos;
        var subrowcnt;
        var band;

        if (scol > ecol || scol < 0 || ecol < 0)
            return false;

        if (!format._cols.length || !format._cols[scol] || !format._cols[ecol])
            return false;

        if (format._cols[scol]._area != format._cols[ecol]._area)
            return false;

        if (this._p_suppresshorzcell != "none" && (format._cols[scol]._area == "left" || format._cols[scol]._area == "right"))
            return false;

        if (srow == -1 || erow == -1)
        {
            if (srow != erow)
                return false;

            if (!format._headrows)
                return false;

            cellinfos = format._headcells;
            subrowcnt = format._headrows.length;
            band = "head";

            if (esubrow < ssubrow)
                return false;
        }
        else if (srow == -2 || erow == -2)
        {
            if (srow != erow)
                return false;

            if (!format._summrows)
                return false;

            cellinfos = format._summcells;
            subrowcnt = format._summrows.length;
            band = "summ";

            if (esubrow < ssubrow)
                return false;
        }
        else
        {
            if (srow < 0 || erow < 0)
                return false;

            if (srow > erow)
                return false;

            if (!format._bodyrows)
                return false;

            cellinfos = format._bodycells;
            subrowcnt = format._bodyrows.length;
            band = "body";
        }

        if (ssubrow == undefined)
            ssubrow = 0;
        if (esubrow == undefined)
            esubrow = subrowcnt - 1;

        if (subrowcnt <= ssubrow || subrowcnt <= esubrow)
            return false;

        var col1, colspan, col2;
        var row1, rowspan, row2;
        var target_cellinfos = [];
        var cell = null, first_cellinfo = null;
        var cellsrow, cheksrow, cellerow, chekerow;

        // suppress랑 충돌여부 체크
        for (var i = 0, n = cellinfos.length; i < n; i++)
        {
            cell = cellinfos[i];
            col1 = cell._col;
            colspan = cell._colspan;
            col2 = col1 + colspan - 1;
            row1 = cell._row;
            rowspan = cell._rowspan;
            row2 = row1 + rowspan - 1;

            if ((scol <= col1 && ecol >= col1) || (scol <= col2 && ecol >= col2) || (col1 <= scol && col2 >= scol) || (col1 <= ecol && col2 >= ecol))
            {
                // esubrow가 ssubrow보다 작을 수 있으므로 계산하여 체크
                if (srow >= 0)
                {
                    cellsrow = srow * subrowcnt + row1;
                    cheksrow = srow * subrowcnt + ssubrow;
                    cellerow = erow * subrowcnt + row2;
                    chekerow = erow * subrowcnt + esubrow;
                }
                else
                {
                    cellsrow = row1;
                    cheksrow = ssubrow;
                    cellerow = row2;
                    chekerow = esubrow;
                }

                if ((cheksrow <= cellsrow && chekerow >= cellsrow) || (cheksrow <= cellerow && chekerow >= cellerow) || (cellsrow <= cheksrow && cellerow >= cheksrow) || (cellsrow <= chekerow && cellerow >= chekerow))
                {
                    if (cell._p_suppress != 0)
                        return false;

                    var change = false;

                    if (!first_cellinfo && row1 == ssubrow)
                        first_cellinfo = cell;

                    if (cell._colspan > 1)
                    {
                        var cellecol = cell._col + cell._colspan - 1;
                        if (cell._col < scol)
                        {
                            change = true;
                            scol = cell._col;
                        }
                        if (cellecol > ecol)
                        {
                            change = true;
                            ecol = cellecol;
                        }
                    }

                    if (cell._rowspan > 1)
                    {
                        if (cellsrow < cheksrow)
                        {
                            change = true;
                            ssubrow = cell._row;
                        }
                        if (cellerow > chekerow)
                        {
                            change = true;
                            esubrow = cell._row + cell._rowspan - 1;
                        }
                    }

                    if (change == true)
                    {
                        // 처음부터 다시
                        target_cellinfos = [];
                        i = -1;
                    }
                    else
                        target_cellinfos.push(cell);
                }
            }
        }

        var virtual_mergecell = { start_column: scol, start_row: srow, start_subrow: ssubrow, end_column: ecol, end_row: erow, end_subrow: esubrow, cellinfos: target_cellinfos, first_cellinfo: first_cellinfo };
        var virtual_arr = this._virtual_mergecell_arr;
        var virtual_arr_len = virtual_arr.length;

        // 이전에 설정된 것과 겹치는지 여부 체크

        var fail_idxs = [];
        var j, k;

        for (i = 0; i < virtual_arr_len; i++)
        {
            // 범위rect에서 각각의 꼭지점 포함여부 체크
            if (this._checkInclude(virtual_arr[i], subrowcnt, scol, srow, ssubrow))
                fail_idxs.push(i);
            else if (this._checkInclude(virtual_arr[i], subrowcnt, scol, erow, esubrow))
                fail_idxs.push(i);
            else if (this._checkInclude(virtual_arr[i], subrowcnt, ecol, srow, ssubrow))
                fail_idxs.push(i);
            else if (this._checkInclude(virtual_arr[i], subrowcnt, ecol, erow, esubrow))
                fail_idxs.push(i);

            // 반대의 경우
            else if (this._checkInclude(virtual_mergecell, subrowcnt, virtual_arr[i].start_column, virtual_arr[i].start_row, virtual_arr[i].start_subrow))
                fail_idxs.push(i);
            else if (this._checkInclude(virtual_mergecell, subrowcnt, virtual_arr[i].start_column, virtual_arr[i].end_row, virtual_arr[i].end_subrow))
                fail_idxs.push(i);
            else if (this._checkInclude(virtual_mergecell, subrowcnt, virtual_arr[i].end_column, virtual_arr[i].start_row, virtual_arr[i].start_subrow))
                fail_idxs.push(i);
            else if (this._checkInclude(virtual_mergecell, subrowcnt, virtual_arr[i].end_column, virtual_arr[i].end_row, virtual_arr[i].end_subrow))
                fail_idxs.push(i);
        }

        // 겹치면 해제 / 설정
        if (fail_idxs.length == 0)
        {
            if (release)
                return false;

            virtual_arr.push(virtual_mergecell);

            for (i = 0, n = target_cellinfos.length; i < n; i++)
            {
                for (j = srow; j <= erow; j++)
                    this._checkVirtualMerge(target_cellinfos[i], j);

                this._refreshCell(band, target_cellinfos[i]._cellidx, -1);
            }
            this._updateMergeData(virtual_arr.length - 1);
        }
        else
        {
            if (!release)
                return false;

            var nn;
            for (i = 0, n = fail_idxs.length; i < n; i++)
            {
                var idx = fail_idxs[i];
                var release_virtual = virtual_arr.splice(idx - i, 1)[0];
                var release_cellinfos = this._getVirtualMergeCellInfos(cellinfos, release_virtual.start_column, release_virtual.end_column, release_virtual.start_row, release_virtual.end_row, release_virtual.start_subrow, release_virtual.end_subrow, subrowcnt);

                for (j = 0, nn = release_cellinfos.length; j < nn; j++)
                {
                    for (k = release_virtual.start_row; k <= release_virtual.end_row; k++)
                    {
                        release_cellinfos[j]._setVirtualMergeInfo(k + 2, undefined);	// +2를 하는 이유 - summ : 0, head : 1, body : 2 ~ n
                    }

                    this._refreshCell(band, release_cellinfos[j]._cellidx, -1);
                }

                for (j = 0, nn = target_cellinfos.length; j < nn; j++)
                {
                    for (k = srow; k <= erow; k++)
                    {
                        target_cellinfos[j]._setVirtualMergeInfo(k + 2, undefined);
                    }

                    this._refreshCell(band, target_cellinfos[j]._cellidx, -1);
                }
            }
        }
        this._adjustOverlayControls(true);

        if (this._p_autosizingtype != "none")
            this._recreate_contents_all(true);
        else
            this._autosizeMergeCell();

        return true;
    };

    _pGrid._autosizeMergeCell = function ()
    {
        if (this._is_autosizemerge)
            return;

        var infos = this._virtual_mergecell_arr;

        if (!infos || !infos.length)
            return;

        var format = this._curFormat;
        var cols = format._cols;

        if (!cols && !cols.length)
            return;

        var i, j;
        var info;
        var total;
        var cellinfo, row, text, width;
        var size;
        var padd, bord;
        var pwidth, bwidth;
        var pheight, bheight;

        this._is_autosizemerge = true;
        if (this._p_autosizingtype == "both" || this._p_autosizingtype == "col")
        {
            for (i = 0; i < infos.length; i++)
            {
                info = infos[i];
                total = 0;

                for (j = info.start_column; j <= info.end_column; j++)
                {
                    total += cols[j].getSize();
                }

                cellinfo = info.first_cellinfo;
                row = info.start_row;
                text = cellinfo._getDisplayText(row);

                padd = cellinfo._curpadding;
                bord = cellinfo._curborder;

                if (padd === "bindexpr" || padd === undefined)
                    padd = this._getCellStyleInfo(cellinfo._cellidx, "padding", row);

                if (bord === "bindexpr" || bord === undefined)
                    bord = this._getCellStyleInfo(cellinfo._cellidx, "border", row);

                pwidth = 0;
                bwidth = 0;

                if (padd)
                {
                    padd = new nexacro._PaddingObject(padd);
                    pwidth = (padd.left + padd.right);
                }
                if (bord)
                {
                    bord = new nexacro._BorderObject(bord);
                    bwidth = (bord.left._width + bord.right._width);
                }

                if (this._overlay_controls[i])  // overlay는 padding 계산되지않음
                    width = this._overlay_controls[i]._adjust_width;
                else
                    width = format._getColSizeRange(info.start_column, info.end_column) - bwidth;

                size = this._getCellRowTextSize(cellinfo, row, text, null, true, width);

                size[0] += pwidth;
                size[0] += bwidth;

                if (size[0] > total)
                {
                    this._applyColSizing(size[0] - total, info.end_column, true);
                }
            }
        }
        else if (this._p_autosizingtype == "both" || this._p_autosizingtype == "row")
        {
            var start_row, start_subrow, end_row, end_subrow, formatrows, rowsizessub;
            var bandstr;

            for (i = 0; i < infos.length; i++)
            {
                info = infos[i];
                total = 0;
                start_row = info.start_row;
                end_row = info.end_row;
                start_subrow = info.start_subrow;
                end_subrow = info.end_subrow;

                if (start_row == -1) 
                {
                    formatrows = format._headrows;
                    rowsizessub = this._rowHeadListSub;
                    bandstr = "head";
                }
                else if (start_row == -2)
                {
                    formatrows = format._summrows;
                    rowsizessub = this._rowSummListSub;
                    bandstr = "summ";
                }
                else
                {
                    formatrows = format._bodyrows;
                    rowsizessub = this._rowSizeListSub;
                    bandstr = "body";
                }

                for (j = start_row; j <= end_row; j++)
                {
                    for (var k = 0, n = formatrows.length; k < n; k++)
                    {
                        if (j == start_row && k < start_subrow)
                            continue;
                        else if (j == end_row && k > end_subrow)
                            break;

                        total += rowsizessub[j * formatrows.length + k];
                    }
                }

                cellinfo = info.first_cellinfo;
                var autosizerow = cellinfo._getAttrValue(cellinfo._p_autosizerow, row);
                var formatsize = formatrows[start_subrow + cellinfo._row].size;
                row = info.start_row;
                text = cellinfo._getDisplayText(row);

                padd = cellinfo._curpadding;
                bord = cellinfo._curborder;

                if (padd === "bindexpr" || padd === undefined)
                    padd = this._getCellStyleInfo(cellinfo._cellidx, "padding", row);

                if (bord === "bindexpr" || bord === undefined)
                    bord = this._getCellStyleInfo(cellinfo._cellidx, "border", row);

                pheight = 0;
                bwidth = 0;
                bheight = 0;

                if (padd)
                {
                    padd = new nexacro._PaddingObject(padd);
                    pheight = (padd.top + padd.bottom);
                }
                if (bord)
                {
                    bord = new nexacro._BorderObject(bord);
                    bwidth = (bord.left._width + bord.right._width);
                    bheight = (bord.top._width + bord.bottom._width);
                }

                if (this._overlay_controls[i])  // overlay는 padding 빼고 border만 계산됨.
                    width = this._overlay_controls[i]._adjust_width;
                else
                    width = format._getColSizeRange(info.start_column, info.end_column) - bwidth;

                size = this._getCellRowTextSize(cellinfo, row, text, null, true, width);

                size[1] += pheight;
                size[1] += bheight;

                if (autosizerow == "limitmin")
                {
                    if (size[1] < formatsize)
                        size[1] = formatsize;
                }
                else if (autosizerow == "limitmax")
                {
                    if (size[1] > formatsize)
                        size[1] = formatsize;
                }

                if (size[1] > total)
                {
                    this._applyRowSizing2(size[1] - total, bandstr, info.end_row, info.end_subrow, true);
                }
            }
        }
        this._is_autosizemerge = false;
    };

    _pGrid._showEditorMergeCell = function (cellobj, focus, showfull)
    {
        var info = cellobj._virtualmerge;
        var band, bandid, overlay = this._overlay_controls[info.overlayidx];
        var cellinfos, bandc;

        if (info.targetrow >= 0)
        {
            bandid = "body";
            cellinfos = this._curFormat._bodycells;
            bandc = this._bodyBand;
        }
        else if (info.targetrow == -1)
        {
            bandid = "head";
            cellinfos = this._curFormat._headcells;
            bandc = this._headBand;
        }
        else if (info.targetrow == -2)
        {
            bandid = "summary";
            cellinfos = this._curFormat._summcells;
            bandc = this._summBand;
        }

        if (!cellinfos)
            return;

        var cellinfo = cellinfos[info.targetcell];

        if (!cellinfo._hasEditor(info.targetrow))
            return;

        var area = this._curFormat._cols[cellinfo._col]._area;
        var l = overlay._control_element.left;
        var t = overlay._control_element.top;
        var w = overlay._getClientWidth();
        var h = overlay._getClientHeight();

        band = this._tempmergeeditor = new nexacro._OverlayControl(l, t, w, h, null, null, this, overlay._org_left, overlay._org_top, overlay._org_width, overlay._org_height, true, bandid, true, (area == "left"), (bandid == "head" || bandid == "summary"));
        band._type_name = nexacro._GridBandControl.prototype._type_name;
        band.id = bandid;
        band._refinfo = bandc._refinfo;
        band.set_background("transparent");
        band.set_border("0px none");

        this._tempmergeeditor._overlayidx = info.overlayidx;

        var rowc = band._ctrl = new nexacro._GridRowControl(band, 0, 0, overlay._org_width, overlay._org_height, info.targetrow, true);

        band.createComponent();

        var cell = new nexacro._GridCellControl("tempcell_" + info.targetrow + "_" + info.targetcell, 0, 0, overlay._org_width, overlay._org_height, null, null, rowc, cellinfo, info.targetrow, info.targetcell);
        cell._is_tempcell = true;
        cell._is_mergetemp = true;
        cell.createComponent();
        cell._updateAll();

        cell.set_background("transparent");
        cell.set_border("0px none");

        rowc._tempcell = cell;

        this._tempmergeeditor.setControlElemPosition(l, t, w, h);

        cell._showEditor(focus, showfull);
        this._beforeEditRowIdx = info.targetrow;
        this._beforeEditCellIdx = info.targetcell;

        overlay.set_visible(false);
        this._showEditing = true;
    };

    _pGrid._hideEditorMergeCell = function (after_hideeditor)
    {
        if (!this._tempmergeeditor)
            return;

        var after = false;

        if (!after_hideeditor && this._isDownActionKeyMouse())
            after = true;

        this._after_hideeditor = null;

        if (!after)
        {
            var band = (after_hideeditor) ? after_hideeditor : this._tempmergeeditor;
            var cell = band._ctrl._tempcell;
            var dataset = this._binddataset;
            var cellinfo = cell._refinfo;
            var oldval, newval;

            if (cellinfo.text._bindexpr)
            {
                oldval = dataset.getColumn(cellinfo.text._bindexpr, cell._getDataRow());
                cell._hideEditor();
                newval = dataset.getColumn(cellinfo.text._bindexpr, cell._getDataRow());
            }
            else
            {
                cell._hideEditor();
            }

            var info = cell._virtualmerge;
            var overlay = this._overlay_controls[info.overlayidx];

            overlay.set_visible(true);

            band._refinfo = null;

            cell.destroy();
            band._ctrl._tempcell = null;
            band.destroy();

            if (this._tempmergeeditor == after_hideeditor || band == this._tempmergeeditor)
            {
                this._showEditing = false;
                this._tempmergeeditor = null;
            }

            this._updateMergeData(info.overlayidx);

            if (oldval != newval)
                this._autosizeMergeCell();

            cell = this._getCurrentBodyCell(-1, -1);

            if (cell)
                cell.setFocus(false);

            this._after_hideeditor = null;
        }
        else
        {
            this._after_hideeditor = this._tempmergeeditor;
        }
    };

    _pGrid._updateMergeData = function (overlayidx)
    {
        var merge_info = this._virtual_mergecell_arr[overlayidx];
        var start_row = merge_info.start_row;
        var end_row = merge_info.end_row;
        var start_subrow = merge_info.start_subrow;
        var end_subrow = merge_info.end_subrow;
        var start_col = merge_info.start_column;
        var end_col = merge_info.end_column;
        var subrow_start, subrow_end;
        var cellinfos = this._curFormat._bodycells;
        var columnid;
        var dataset = this._binddataset;
        var cnt = 0, v;

        for (var k = start_row; k <= end_row; k++)
        {
            subrow_start = 0;
            subrow_end = this._curFormat._bodyrows.length - 1;

            if (k == end_row && end_subrow != undefined)
                subrow_end = end_subrow;

            if (k == start_row && start_subrow != undefined)
                subrow_start = start_subrow;

            var apply = true;
            for (var l = 0, n = cellinfos.length; l < n; l++)
            {
                if (k == start_row && cellinfos[l]._row < subrow_start)
                    continue;
                else if (k == end_row && cellinfos[l]._row > subrow_end)
                    break;

                if (columnid = cellinfos[l].text._bindexpr)
                {
                    if (cellinfos[l]._col >= start_col && cellinfos[l]._col <= end_col)
                    {
                        if (!apply)
                            return;

                        if (cnt++)
                            dataset.setColumn(k, columnid, v);
                        else
                        {
                            if (cellinfos[l].text._bindtype == 1)
                                v = dataset.getColumn(k, columnid);
                            else
                                apply = false;
                        }
                    }
                }
            }
        }
    };

    _pGrid._adjustOverlayControls = function (is_create, only)
    {
        if (!this._p_enableredraw)
            return;

        if (is_create)
        {
            this._destroyOverlayControls();
            this._destroySelectionControls();
            this._destroyCellSelectionControl();
        }

        this._applySelection();
        this._applyCellSelection();

        var format = this._curFormat;
        if (!format)
            return;

        if (!this._hasVirtualMergeCell())
            return;

        var i, j, k, l, n;
        var left = 0, top = 0, width = 0, height = 0;
        var start_column, end_column, start_row, end_row, subrow_start, subrow_end, start_subrow, end_subrow, first_cellinfo;
        var style_cells = [];

        var cellobj = null;
        var cellinfo = null;

        var virtual_mergecell;
        var virtual_mergecell_arr = this._virtual_mergecell_arr;

        var overlay_control;
        var overlay_controls = this._overlay_controls;
        var overlay_index = 0;

        for (i = 0, n = virtual_mergecell_arr.length; i < n; i++)
        {
            virtual_mergecell = virtual_mergecell_arr[i];

            start_row = virtual_mergecell.start_row;
            end_row = virtual_mergecell.end_row;
            start_column = virtual_mergecell.start_column;
            end_column = virtual_mergecell.end_column;
            start_subrow = virtual_mergecell.start_subrow;
            end_subrow = virtual_mergecell.end_subrow;
            first_cellinfo = virtual_mergecell.first_cellinfo;

            if (only)
            {
                if (only == "head" && start_row != -1)
                    continue;
                else if (only == "summ" && start_row != -2)
                    continue;
            }

            if (start_row == -1)
            {
                // head band
                start_row = end_row = 0;
                subrow_start = (start_subrow >= 0) ? start_subrow : 0;
                subrow_end = (end_subrow >= 0) ? end_subrow : format._headrows.length - 1;

                for (j = start_column; j <= end_column; j++)
                {
                    l = 0;
                    while (true)
                    {
                        cellobj = this._getCurrentHeadCell(l++, true);

                        if (!cellobj || cellobj._refinfo._row > subrow_end)
                            break;
                        else if (cellobj._refinfo._row < subrow_start)
                            continue;

                        cellinfo = cellobj._refinfo;

                        if (cellinfo._col == j)
                            style_cells.push(cellobj);
                    }
                }
            }
            else if (start_row == -2)
            {
                // summ band
                start_row = end_row = 0;
                subrow_start = (start_subrow >= 0) ? start_subrow : 0;
                subrow_end = (end_subrow >= 0) ? end_subrow : format._summrows.length - 1;

                for (j = start_column; j <= end_column; j++)
                {
                    l = 0;
                    while (true)
                    {
                        cellobj = this._getCurrentSummCell(l++, true);

                        if (!cellobj || cellobj._refinfo._row > subrow_end)
                            break;
                        else if (cellobj._refinfo._row < subrow_start)
                            continue;

                        cellinfo = cellobj._refinfo;

                        if (cellinfo._col == j)
                            style_cells.push(cellobj);
                    }
                }
            }
            else
            {
                if (!format._bodyrows)
                    return;

                for (j = start_column; j <= end_column; j++)
                {
                    for (k = start_row; k <= end_row; k++)
                    {
                        subrow_start = 0;
                        subrow_end = format._bodyrows.length - 1;

                        if (k == end_row && end_subrow != undefined)
                            subrow_end = end_subrow;

                        if (k == start_row && start_subrow != undefined)
                            subrow_start = start_subrow;

                        l = 0;
                        while (true)
                        {
                            cellobj = this._getCurrentBodyCell(k, l++);

                            if (!cellobj)
                                break;

                            if (k == start_row && cellobj._refinfo._row < subrow_start)
                                continue;
                            else if (k == end_row && cellobj._refinfo._row > subrow_end)
                                break;

                            cellinfo = cellobj._refinfo;

                            if (cellinfo._col == j)
                                style_cells.push(cellobj);
                        }
                    }
                }
            }

            if (style_cells.length > 0)
            {
                start_row = virtual_mergecell.start_row;

                var org_spos = {};
                var org_epos = {};
                var s_pos = style_cells[0]._setPositionInGrid(undefined, undefined, true, org_spos);
                var e_pos = style_cells[style_cells.length - 1]._setPositionInGrid(undefined, undefined, true, org_epos);
                var org_width, org_height, org_top;

                org_width = org_epos.right - org_spos.left;

                left = s_pos.left;
                top = s_pos.top;
                width = (e_pos.right > left) ? e_pos.right - left : 0;
                height = (e_pos.bottom > top) ? e_pos.bottom - top : 0;

                overlay_control = overlay_controls[overlay_index];

                var is_create_ctrl = false;

                if (!overlay_control)
                {
                    if (start_row < 0)
                    {
                        org_top = org_spos.top;
                        org_height = org_epos.bottom - org_spos.top;
                    }
                    else
                    {
                        org_height = this._getBodyRowsSize(start_row, end_row, start_subrow, end_subrow);
                        org_top = this._bodyBand._matrix._getBodyRowTopPos(start_row);

                        if (start_subrow > 0)
                        {
                            org_top += this._rowSizeListSub[start_row * format._bodyrows.length + start_subrow];
                        }
                    }

                    var area = this._curFormat._cols[first_cellinfo._col]._area;
                    overlay_control = new nexacro._OverlayControl(left, top, width, height, null, null, this, org_spos.left, org_top, org_width, org_height, undefined, undefined, undefined, (area == "left"), (start_row < 0));
                    overlay_control.createComponent();
                    overlay_controls[overlay_index] = overlay_control;
                    is_create_ctrl = true;
                }

                this._setOverlayControlProperty(overlay_control, left, top, width, height, style_cells, start_row, first_cellinfo, is_create_ctrl, (start_row <= this._fixed_endrow));

                if (this._tempmergeeditor && this._tempmergeeditor._overlayidx == overlay_index)
                    this._tempmergeeditor.setControlElemPosition(left, top, width, height);
            }
            else
            {
                if (overlay_controls[overlay_index])
                    overlay_controls[overlay_index].set_top(this._adjust_height);

                if (this._tempmergeeditor && this._tempmergeeditor._overlayidx == overlay_index)
                    this._tempmergeeditor.set_top(this._adjust_height);
            }

            style_cells = [];
            overlay_index++;
        }
    };

    _pGrid._destroyOverlayControls = function ()
    {
        var overlay_controls = this._overlay_controls;
        if (overlay_controls.length)
        {
            for (var i = 0, n = overlay_controls.length; i < n; i++)
            {
                if (overlay_controls[i])
                    overlay_controls[i].destroy();
            }
        }
        this._overlay_controls = [];
    };

    // VirtualMerge Util
    _pGrid._getVirtualMergeCellInfos = function (cellinfos, scol, ecol, srow, erow, ssubrow, esubrow, subrowcnt)
    {
        var target_cellinfos = [];
        var cellsrow, cheksrow, cellerow, chekerow;
        var col1, col2, colspan, row1, row2, rowspan;

        for (var i = 0, n = cellinfos.length; i < n; i++)
        {
            col1 = cellinfos[i]._col;
            colspan = cellinfos[i]._colspan;
            col2 = col1 + colspan - 1;
            row1 = cellinfos[i]._row;
            rowspan = cellinfos[i]._rowspan;
            row2 = row1 + rowspan - 1;

            if ((scol <= col1 && ecol >= col1) || (scol <= col2 && ecol >= col2) || (col1 <= scol && col2 >= scol) || (col1 <= ecol && col2 >= ecol))
            {
                // esubrow가 ssubrow보다 작을 수 있으므로 계산하여 체크
                if (srow >= 0)
                {
                    cellsrow = srow * subrowcnt + row1;
                    cheksrow = srow * subrowcnt + ssubrow;
                    cellerow = erow * subrowcnt + row2;
                    chekerow = erow * subrowcnt + esubrow;
                }
                else
                {
                    cellsrow = row1;
                    cheksrow = ssubrow;
                    cellerow = row2;
                    chekerow = esubrow;
                }

                if ((cheksrow <= cellsrow && chekerow >= cellsrow) || (cheksrow <= cellerow && chekerow >= cellerow) || (cellsrow <= cheksrow && cellerow >= cheksrow) || (cellsrow <= chekerow && cellerow >= chekerow))
                {
                    target_cellinfos.push(cellinfos[i]);
                }
            }
        }
        return target_cellinfos;
    };

    _pGrid._getVirtualMergeCellObjs = function (virtual_mergecell)
    {
        var band;
        var cellobjs = [];
        var format = this._curFormat;
        var subrowcnt;

        if (virtual_mergecell.start_row == -1)
        {
            band = this._headBand;
            subrowcnt = format._headrows.length;
        }
        else if (virtual_mergecell.start_row == -2)
        {
            band = this._summBand;
            subrowcnt = format._summrows.length;
        }
        else if (virtual_mergecell.start_row >= 0)
        {
            band = this._bodyBand;
            subrowcnt = format._bodyrows.length;
        }

        if (!band) return cellobjs;

        var rows = band._get_rows();
        var cells;
        var scol = virtual_mergecell.start_column;
        var ecol = virtual_mergecell.end_column;
        var srow = virtual_mergecell.start_row;
        var erow = virtual_mergecell.end_row;
        var ssubrow = virtual_mergecell.start_subrow;
        var esubrow = virtual_mergecell.end_subrow;
        var datarow;
        var cellsrow, cheksrow, cellerow, chekerow;
        var cellinfo;

        for (var i = 0, n = rows.length; i < n; i++)
        {
            datarow = this._getDataRow(rows[i]._rowidx);

            if (datarow >= srow && datarow <= erow)
            {
                cells = rows[i]._cells;

                for (var j = 0, nn = cells.length; j < nn; j++)
                {
                    cellinfo = cells[j]._refinfo;

                    if (cellinfo._col >= scol && cellinfo._col <= ecol)
                    {
                        if (ssubrow == undefined)
                        {
                            cellobjs.push(cells[j]);
                        }
                        else
                        {
                            if (srow >= 0)
                            {
                                cellsrow = datarow * subrowcnt + cellinfo._row;
                                cheksrow = srow * subrowcnt + ssubrow;
                                cellerow = datarow * subrowcnt + cellinfo._row + cellinfo._rowspan - 1;
                                chekerow = erow * subrowcnt + esubrow;
                            }
                            else
                            {
                                cellsrow = cellinfo._row;
                                cheksrow = ssubrow;
                                cellerow = cellinfo._row + cellinfo._rowspan - 1;
                                chekerow = esubrow;
                            }

                            if ((cheksrow <= cellsrow && chekerow >= cellsrow) || (cheksrow <= cellerow && chekerow >= cellerow) || (cellsrow <= cheksrow && cellerow >= cheksrow) || (cellsrow <= chekerow && cellerow >= chekerow))
                            {
                                cellobjs.push(cells[j]);
                            }
                        }
                    }
                }
            }
        }
        return cellobjs;
    };

    _pGrid._setOverlayControlProperty = function (control, left, top, width, height, style_cells, target_datarow, target_cellinfo, is_create_ctrl, change_size)
    {
        if (!control)
            return;

        control.setControlElemPosition(left, top, width, height, change_size, (this._p_autofittype == "col" || this._p_autofittype == "both" || this._p_autofittype == "allboth" || this._p_autofittype == "col,allrow"));

        this._updateOverlayControlStyle(control, target_datarow, target_cellinfo)
    };

    _pGrid._updateOverlayControlStyle = function (control, target_datarow, target_cellinfo, status, call_flush)
    {
        if (!control)
            return;

        var datarow = target_datarow;
        var cellinfo = target_cellinfo;
        var selected = this._p_useselcolor && this._isSelectedCell(cellinfo._cellidx, datarow);
        var celldisplaytype = cellinfo._getDisplaytype(datarow);
        var cellstyle = this._getCellStyleInfo(cellinfo._cellidx, ["font", "color", "letterSpacing", "wordSpacing", "textDecoration", "padding", "cursor", "wordWrap", "align"], datarow, selected, undefined, undefined, undefined, status, call_flush);

        var celltext = cellinfo._getDisplayText(datarow);
        var cellalign = cellstyle.align.split(",");

        if (celldisplaytype == "imagecontrol")
        {
            control.set_text(celltext);
        }
        else
        {
            if (celltext && celltext.indexOf("\r") != -1)
                celltext = celltext.replace(/\r/g, "");

            control.set_text(celltext);

            if (celldisplaytype == "decoratetext")
                control.set_usedecorate(true);
            else
                control.set_usedecorate(false);

            control.set_wordWrap(cellinfo._getWordwrap(datarow));
        }

        control.set_tooltiptext(cellinfo._getTooltipText(datarow));
        control.set_font(cellstyle.font);
        control.set_letterSpacing(cellstyle.letterSpacing);
        control.set_wordSpacing(cellstyle.wordSpacing);
        control.set_textDecoration(cellstyle.textDecoration);
        control.set_color(cellstyle.color);
        control.set_cursor(cellstyle.cursor);
        control.set_padding(cellstyle.padding);
        control.set_wordWrap(cellstyle.wordWrap);
        control.set_verticalAlign(cellalign[1]);

        if (control._styles && control._styles.textalign)
            control.set_textAlign(control._styles.textalign);
        else
            control.set_textAlign(cellalign[0]);
    };

    _pGrid._checkInclude = function (virtual, subrowcnt, col, row, subrow)
    {
        if (virtual.start_column <= col && virtual.end_column >= col)
        {
            if (virtual.start_row <= row && virtual.end_row >= row)
            {
                if (subrow == undefined || virtual.start_subrow == undefined)
                {
                    return true;
                }
                else
                {
                    if (virtual.start_row < row && virtual.end_row > row) // row가 3개 이상일 때 중간에 껴있을 경우
                        return true;

                    if (virtual.start_row == virtual.end_row) // 하나의 row안에서의 처리
                    {
                        if (virtual.start_subrow <= subrow && virtual.end_subrow >= subrow)
                            return true;
                    }
                    else
                    {
                        if (virtual.start_row == row)
                        {
                            if (virtual.start_subrow <= subrow && subrowcnt > subrow)
                                return true;
                        }

                        if (virtual.end_row == row)
                        {
                            if (0 <= subrow && virtual.end_subrow >= subrow)
                                return true;
                        }
                    }
                }
            }
        }
        return false;
    };

    _pGrid._checkVirtualMerge = function (cellinfo, row)
    {
        if (cellinfo._getVirtualMergeInfo(row + 2))
            return cellinfo._getVirtualMergeInfo(row + 2);

        var virtual_arr = this._virtual_mergecell_arr;
        var virtual_arr_len = virtual_arr.length;
        var subrowcnt;
        var format = this._curFormat;
        var band;

        if (row == -1)
        {
            subrowcnt = (format._headrows) ? format._headrows.length : 0;
            band = "head";
        }
        else if (row == -2)
        {
            subrowcnt = (format._summrows) ? format._summrows.length : 0;
            band = "summ";
        }
        else if (row >= 0)
        {
            subrowcnt = (format._bodyrows) ? format._bodyrows.length : 0;
            band = "body";
        }

        if (!subrowcnt)
            return null;

        if (virtual_arr_len == 0)
            return null;

        var scol = cellinfo._col,
            ecol = cellinfo._col + cellinfo._colspan - 1,
            ssubrow = cellinfo._row,
            esubrow = cellinfo._row + cellinfo._rowspan - 1,
            area = cellinfo._area;

        for (var i = 0; i < virtual_arr_len; i++)
        {
            if (this._checkInclude(virtual_arr[i], subrowcnt, scol, row, ssubrow))
            {
                if (this._checkInclude(virtual_arr[i], subrowcnt, ecol, row, ssubrow))
                {
                    if (this._checkInclude(virtual_arr[i], subrowcnt, scol, row, esubrow))
                    {
                        if (this._checkInclude(virtual_arr[i], subrowcnt, ecol, row, esubrow))
                        {
                            var retn = "";

                            if (area != "right")
                            {
                                if (ecol < virtual_arr[i].end_column)
                                    retn += "right";
                            }
                            else
                            {
                                if (scol > virtual_arr[i].start_column)
                                    retn += "left";
                            }

                            if (band != "summ")
                            {
                                if (row < virtual_arr[i].end_row)
                                {
                                    retn += "bottom";
                                }
                                else if (row == virtual_arr[i].end_row)
                                {
                                    if (virtual_arr[i].end_subrow == undefined && esubrow < subrowcnt - 1)
                                        retn += "bottom";
                                    else if (esubrow < virtual_arr[i].end_subrow)
                                        retn += "bottom";
                                }
                            }
                            else
                            {
                                if (row > virtual_arr[i].start_row)
                                {
                                    retn += "top";
                                }
                                else if (row == virtual_arr[i].start_row)
                                {
                                    if (virtual_arr[i].start_subrow == undefined && ssubrow > 0)
                                        retn += "top";
                                    else if (ssubrow > virtual_arr[i].start_subrow)
                                        retn += "top";
                                }
                            }

                            retn += "virtual";
                            retn = { "remove": retn, "targetrow": virtual_arr[i].start_row, "targetcell": virtual_arr[i].first_cellinfo._cellidx, "overlayidx": i };

                            cellinfo._setVirtualMergeInfo(row + 2, retn);

                            return retn;
                        }
                    }
                }
            }
        }
        return null;
    };

    _pGrid._hasVirtualMergeCell = function ()
    {
        var virtualmerge_arr = this._virtual_mergecell_arr;
        if (virtualmerge_arr && virtualmerge_arr.length > 0)
        {
            return true;
        }
        else
        {
            return false;
        }
    };

    /* selection control method */
    _pGrid._applyCellSelection = function ()
    {
        if (!this._is_created || !this._isFocused())
            return;

        this._destroyCellSelectionControl();

        if (!this.showcellselection)
            return;

        var cell = this._getCurrentBodyCell(-1, -1);

        if (!cell)
            return;

        var border = cell._getCurrentStyleBorder();
        var cellleftborder = border ? border.left._width : 0;
        var celltopborder = border ? border.top._width : 0;
        var cellrightborder = border ? border.right._width : 0;
        var cellbottomborder = border ? border.bottom._width : 0;

        var left = cellleftborder + 1;
        var top = celltopborder + 1;
        var width = cell._adjust_width - cellleftborder - cellrightborder - 2;
        var height = cell._adjust_height - celltopborder - cellbottomborder - 2;

        // cell padding은무시..
        this._cellselection = new nexacro._GridSelectionControl(left, top, width, height, null, null, cell, "cellselection");
        this._cellselection.createComponent();
    };

    _pGrid._applySelection = function ()
    {
        if (!this._is_created)
            return;

        if (!this._p_showselection)
        {
            this._destroySelectionControls();
            return;
        }

        var parentband = this._bodyBand;
        if (!parentband || !parentband._is_created) return;

        var showrows = [];
        var scells = this._getSelectedCellsforRowRange(showrows); // cellidx -> cellobj
        if (!scells || (scells.length && !scells[0].begcell))
        {
            this._destroySelectionControls();
            return;
        }

        var scellslen = scells.length;
        var selinfo = this._selectinfo;
        var format = this._curFormat;

        // control destroy
        if (selinfo.area.length < this._selections.length)
            this._destroySelectionControls();

        var border = parentband._getCurrentStyleBorder();
        var bandleftborder = border ? border.left._width : 0;
        var bandtopborder = border ? border.top._width : 0;

        for (var i = 0; i < scellslen; i++)
        {
            var bshow = (showrows[i][0] == 0 && showrows[i][1] == 0) || (showrows[i][0] == -1 && showrows[i][1] == -1) ? false : true;
            var showendrowborder = true;

            var begcell = scells[i].begcell;
            var endcell = scells[i].endcell;

            if (!endcell)
                endcell = begcell;

            var begrect = begcell._getPositionInBand();
            var endrect = endcell._getPositionInBand();

            // left fixed area
            if (endrect.right < format.leftWidth && endcell._refinfo._area == "body")
                endrect.right = format.leftWidth;

            // top fixed row
            if (begcell.parent._fixed && !endcell.parent._fixed)
            {
                if (showrows[i][1] == 0 || (showrows[i][1] == 1 && endrect.bottom < this._fixed_height)) // top
                {
                    showendrowborder = false;
                    endrect.bottom = this._fixed_height;
                }
            }

            // right fixed area
            var rightpos = this._getClientWidth() - format.rightWidth;
            if (rightpos < begrect.left && begcell._refinfo._area == "body")
                begrect.left = rightpos;

            var width = endrect.right - begrect.left;
            var height = endrect.bottom - begrect.top;

            if (this._selections[i])
                this._selections[i].move(begrect.left - bandleftborder, begrect.top - bandtopborder, width, height);
            else
            {
                if (!this._isMultiSelected())
                    this._destroySelectionControls();

                // control create
                var selection = new nexacro._GridSelectionControl(begrect.left - bandleftborder, begrect.top - bandtopborder, width, height, null, null, parentband);
                selection.set_border(parentband.selectborder); // apply contents editor
                selection.createComponent();

                this._selections[i] = selection;
            }

            if (!bshow)
            {
                // invisible controls
                this._selections[i].move(begrect.left - bandleftborder, begrect.top + this._getClientHeight() - bandtopborder, width, height);
                continue;
            }

            // adjust border visibility
            var l, t, r, b;
            l = t = r = b = false;

            if (begrect.orgl < begrect.left || begrect.orgl < 0 || !width)
                l = true;
            if (showrows[i][0] != 1 || (begrect.orgt < 0 || begrect.orgt < begrect.top))
                t = true;
            if ((endrect.right < endrect.orgr && 0 <= endrect.orgr) || !width)
                r = true;
            if (showendrowborder && (showrows[i][1] != 1 || (endrect.bottom < endrect.orgb)))
                b = true;

            this._selections[i]._control_element.setElementBorderNone(l, t, r, b);
        }
    };

    _pGrid._destroySelectionControls = function ()
    {
        var sels = this._selections;
        if (sels.length)
        {
            for (var i = 0, n = sels.length; i < n; i++)
            {
                if (sels[i])
                    sels[i].destroy();
            }
        }
        this._selections = [];
    };

    _pGrid._destroyCellSelectionControl = function ()
    {
        if (this._cellselection)
        {
            this._cellselection.destroy();
            this._cellselection = null;
        }
    };

    _pGrid._getSelectedCellsforRowRange = function (showrows)
    {
        // [showrows flags] row가 가려지는 방향에 따라 flag를 설정
        // 1 : show, 0 : top, -1 : bottom

        var selinfo = this._selectinfo;
        var band = this._bodyBand;
        var begrow, endrow, currow = null, begcell = null, endcell = null, rtn = [], curcell;
        var rows = band._matrix._getAllRows();
        if (!rows || rows.length == 0)
            return null;

        var showrow;
        var toprowpos;
        var dstoprowpos;
        var bottomrowpos;
        var dsbottomrowpos;
        var dsbegrowidx;
        var dscurrowidx;
        var dsrowidx;
        var cellarea;
        var arealen;
        var begrowclen;
        var cell;
        var dsendrowidx;
        var endrowclen;
        var i, j, k;
        var format = this._curFormat;

        if (this._p_selecttype == "row")
        {
            showrow = [1, 1];

            dscurrowidx = this.getDatasetRow(selinfo.currow);
            toprowpos = this._toprowpos[0];
            dstoprowpos = this.getDatasetRow(toprowpos);
            bottomrowpos = this._getScreenBottomRowPos(this._getScrollTop(), true);
            dsbottomrowpos = this.getDatasetRow(bottomrowpos);

            if ((dstoprowpos <= dscurrowidx && (dsbottomrowpos == -1 || dscurrowidx <= dsbottomrowpos)) || dscurrowidx <= this._fixed_endrow)
            {
                currow = band._get_row(dscurrowidx);

            }
            else
            {
                // currow undefined
                showrow[0] = -1;
                showrow[1] = -1;

                currow = band._get_row(dstoprowpos);
            }

            if (!currow || !currow._is_alive) return null;
            begcell = currow._cells[0];
            endcell = currow._cells[currow._cells.length - 1];

            if ((endcell._refinfo._col + endcell._refinfo._colspan - 1) != (format._cols.length - 1))
            {
                var currowcells = currow._cells;
                for (var i = 1; i < currowcells.length; i++)
                {
                    if ((currowcells[i]._refinfo._col + currowcells[i]._refinfo._colspan - 1) == (format._cols.length - 1))
                        endcell = currowcells[i];
                }
            }

            showrows.push(showrow);
            rtn.push({ begcell: begcell, endcell: endcell });
        }
        else if (this._p_selecttype == "multirow")
        {
            cellarea = selinfo.area;
            arealen = cellarea.length;

            for (i = 0; i < arealen; i++)
            {
                showrow = [1, 1];

                // begcell
                dsbegrowidx = cellarea[i].begrow;
                toprowpos = this._toprowpos[0];
                dstoprowpos = this.getDatasetRow(toprowpos);
                bottomrowpos = this._getScreenBottomRowPos(this._getScrollTop(), true);
                dsbottomrowpos = this.getDatasetRow(bottomrowpos);

                if ((dstoprowpos <= dsbegrowidx && (dsbottomrowpos == -1 || dsbegrowidx <= dsbottomrowpos)) || dsbegrowidx <= this._fixed_endrow)
                {
                    begrow = band._get_row(dsbegrowidx);
                    if (!begrow || !begrow._is_alive) return null;
                    begcell = begrow._cells[0];
                }
                else
                {
                    // begrow undefined
                    if (dstoprowpos <= dsbegrowidx)
                        showrow[0] = -1; // bottom
                    else
                        showrow[0] = 0; // top

                    begrow = band._get_row(dstoprowpos);
                    if (!begrow || !begrow._is_alive) return null;
                    begcell = begrow._cells[0];
                }

                // endcell
                dsendrowidx = cellarea[i].endrow;

                if ((dstoprowpos <= dsendrowidx && (dsbottomrowpos == -1 || dsendrowidx <= dsbottomrowpos)) || dsendrowidx <= this._fixed_endrow)
                {
                    endrow = band._get_row(dsendrowidx);
                }
                else
                {
                    // endrow undefined
                    if (dsbottomrowpos <= dsendrowidx)
                        showrow[1] = -1; // bottom
                    else
                        showrow[1] = 0; // top

                    endrow = band._get_row(dsbottomrowpos);
                }

                if (!endrow || !endrow._is_alive) return null;
                endcell = endrow._cells[endrow._cells.length - 1];

                if ((endcell._refinfo._col + endcell._refinfo._colspan - 1) != (format._cols.length - 1))
                {
                    var endrowcells = endrow._cells;
                    for (var j = 1; j < endrowcells.length; j++)
                    {
                        if ((endrowcells[j]._refinfo._col + endrowcells[j]._refinfo._colspan - 1) == (format._cols.length - 1))
                            endcell = endrowcells[j];
                    }
                }

                showrows.push(showrow);
                rtn.push({ begcell: begcell, endcell: endcell });
            }
        }
        else if (this._p_selecttype == "cell")
        {
            showrow = [1, 1];
            dsrowidx = this.getDatasetRow(selinfo.currow);
            toprowpos = this._toprowpos[0];
            dstoprowpos = this.getDatasetRow(toprowpos);
            bottomrowpos = this._getScreenBottomRowPos(this._getScrollTop(), true);
            dsbottomrowpos = this.getDatasetRow(bottomrowpos);

            if ((dstoprowpos <= dsrowidx && (dsbottomrowpos == -1 || dsrowidx <= dsbottomrowpos)) || dsrowidx <= this._fixed_endrow)
            {
                currow = band._get_row(dsrowidx);
                if (!currow || !currow._is_alive) return null;
                curcell = currow._cells[selinfo.curcell];
            }
            else
            {
                //currow undefined
                showrow[0] = -1;
                showrow[1] = -1;

                currow = band._get_row(dstoprowpos);
                if (!currow || !currow._is_alive) return null;

                curcell = currow._cells[selinfo.curcell];
            }
            showrows.push(showrow);
            rtn.push({ begcell: curcell, endcell: curcell });
        }
        else if (this._p_selecttype == "area" || this._p_selecttype == "multiarea")
        {
            cellarea = selinfo.area;
            arealen = cellarea.length;

            for (i = 0; i < arealen; i++)
            {
                showrow = [1, 1];

                // begcell
                dsbegrowidx = cellarea[i].begrow;
                toprowpos = this._toprowpos[0];
                dstoprowpos = this.getDatasetRow(toprowpos);
                bottomrowpos = this._getScreenBottomRowPos(this._getScrollTop(), true);
                dsbottomrowpos = this.getDatasetRow(bottomrowpos);

                if ((dstoprowpos <= dsbegrowidx && (dsbottomrowpos == -1 || dsbegrowidx <= dsbottomrowpos)) || dsbegrowidx <= this._fixed_endrow)
                {
                    begrow = band._get_row(dsbegrowidx);
                    if (!begrow || !begrow._is_alive) return null;
                    begrowclen = begrow._cells.length;

                    for (j = 0; j < begrowclen; j++)
                    {
                        cell = begrow._cells[j];
                        if (cell._refinfo._col == cellarea[i].begcol) // col
                        {
                            if (cell._refinfo._row == cellarea[i].begsubrow[0]) // begsubrow index
                            {
                                begcell = cell;
                                break;
                            }
                        }
                    }
                }
                else
                {
                    // begcell undefined
                    if (dstoprowpos <= dsbegrowidx)
                        showrow[0] = -1; // bottom
                    else
                        showrow[0] = 0; // top

                    begrow = band._get_row(dstoprowpos);
                    if (!begrow || !begrow._is_alive) return null;

                    begrowclen = begrow._cells.length;

                    for (j = 0; j < begrowclen; j++)
                    {
                        cell = begrow._cells[j];
                        if (cell._refinfo._col == cellarea[i].begcol) // col
                        {
                            begcell = cell;
                            break;
                        }
                    }
                }

                // endcell
                dsendrowidx = cellarea[i].endrow;
                if ((dstoprowpos <= dsendrowidx && (dsbottomrowpos == -1 || dsendrowidx <= dsbottomrowpos)) || dsendrowidx <= this._fixed_endrow)
                {
                    endrow = band._get_row(dsendrowidx);
                    if (!endrow || !endrow._is_alive) return null;
                    endrowclen = endrow._cells.length;

                    for (k = endrowclen - 1; 0 <= k; k--)
                    {
                        cell = endrow._cells[k];
                        if ((cell._refinfo._col + cell._refinfo._colspan - 1) == cellarea[i].endcol) // col
                        {
                            if ((cell._refinfo._row + cell._refinfo._rowspan - 1) == cellarea[i].endsubrow[cellarea[i].endsubrow.length - 1]) // endsubrowidx
                            {
                                endcell = cell;
                                break;
                            }
                        }
                    }
                }
                else
                {
                    // endcell undefined
                    if (dsbottomrowpos <= dsendrowidx)
                        showrow[1] = -1; // bottom
                    else
                        showrow[1] = 0; // top

                    endrow = band._get_row(dsbottomrowpos);
                    if (!endrow || !endrow._is_alive) return null;

                    endrowclen = endrow._cells.length;

                    for (k = endrowclen - 1; 0 <= k; k--)
                    {
                        if (endrow._cells[k]._refinfo._col == cellarea[i].endcol) // col
                        {
                            cell = endrow._cells[k];
                            endcell = cell;
                            break;
                        }
                    }
                }
                showrows.push(showrow);
                rtn.push({ begcell: begcell, endcell: endcell });
            }
        }
        return rtn;
    };

    /* Accessibility Method Accessibility_Comp.js 이동*/
    // move focus
    _pGrid._moveToAccessibilityCell = _pGrid._moveToCell;
    _pGrid._moveToPosAccessibilityCell = _pGrid._moveToPosCell;
    _pGrid._setAccessibilityBandFocus = nexacro._emptyFn;
    _pGrid._moveToAccessibilityBand = nexacro._emptyFn;

    // get index
    _pGrid._getAccessibilityCellIndex = nexacro._emptyFn;
    _pGrid._getAccessibilityCurrentCell = nexacro._emptyFn;
    _pGrid._getAccessibilityLastCellIndex = nexacro._emptyFn;

    // band, row의 lastfocus 삭제
    _pGrid._removeAccessibilityCurrentFocus = nexacro._emptyFn;

    _pGrid._on_useInnerDsCells = function (/*obj, e*/)
    {
        this._is_update_inner_dataset = true;
        this._refreshAll();
        this._is_update_inner_dataset = undefined;
    };

    _pGrid._getFilterFullStr = function ()
    {
        var format = this._curFormat;
        var cells = format._headcells;
        var full_filter_str = "";

        for (var i = 0; i < cells.length; i++)
        {
            if (cells[i]._filterstr)
            {
                if (full_filter_str)
                    full_filter_str += " && ";

                full_filter_str += ("(" + cells[i]._filterstr + ")");
            }
            /*
            var subcells = cells[i]._subcells;
            for (var j = 0; j < subcells.length; j++)
            {
                if (subcells[j]._filterstr)
                {
                    if (full_filter_str)
                        full_filter_str += " && ";

                    full_filter_str += ("(" + subcells[i]._filterstr + ")");
                }
            }
            */
        }
        return full_filter_str;
    };

    _pGrid._getRowGroupControlCells = function ()
    {
        var format = this._curFormat;
        var bodycells = format._bodycells;
        var cells = [];

        for (var i = 0; i < bodycells.length; i++)
        {
            if (bodycells[i]._groupcol >= 0)
            {
                if (bodycells[i]._getDisplaytype(0) == "rowgroupcontrol")
                    cells.push(bodycells[i]);
            }
        }
        return cells;
    };

    _pGrid._getGroupColumnCells = function ()
    {
        var format = this._curFormat;
        var headcells = format._headcells;
        var cells = [];

        for (var i = 0; i < headcells.length; i++)
        {
            if (headcells[i].groupcolumn)
                cells.push(headcells[i]);
        }
        return cells;
    }

    _pGrid._getGroupSortStrObj = function ()
    {
        var format = this._curFormat;
        var cells = format._headcells;
        var groupstr = "", sortstr = "";
        var group_cols = [];

        var val = this._groupstr;

        if (val)
            group_cols = val.split(",");

        this._groupcount = group_cols.length;

        var sortinfo = this._sortinfo;
        if (sortinfo)
        {
            for (var i = 0; i < sortinfo.length; i++)
            {
                var sortcellidx = sortinfo[i].cellidx;
                if (cells[sortcellidx]._sortstr)
                {
                    var oper = cells[sortcellidx]._sortstr.charAt(0);
                    var sort = cells[sortcellidx]._sortstr.substring(1);
                    var bset = false;

                    for (var j = 0; j < this._groupcount; j++)
                    {
                        if (group_cols[j] == sort)
                        {
                            group_cols[j] = oper + group_cols[j];
                            bset = true;
                            break;
                        }
                    }

                    if (!bset)
                        sortstr += cells[sortcellidx]._sortstr;
                }
            }
        }

        if (group_cols.length)
            groupstr = group_cols.join(",");

        if (groupstr)
            groupstr = "G:" + groupstr;

        if (sortstr)
            sortstr = "S:" + sortstr;

        if (groupstr != "" && sortstr != "")
            groupstr += ", ";

        return { fullstr: groupstr + sortstr, groupstr: groupstr, sortstr: sortstr };
    };

    _pGrid._getGroupsStartCol = function ()
    {
        if (!this._curFormat || !this._curFormat._group_info)
            return 0;

        return this._curFormat._group_info.startcol;
    }

    _pGrid._applyGroupSort = function (b_sort_act)
    {
        var redraw = this._p_enableredraw;
        this.set_enableredraw(false);

        if (!b_sort_act)
            this._removeGroupCol();

        var groupsortobj = this._getGroupSortStrObj();
        var groupsortstr = groupsortobj.fullstr;
        var groupcount = this._groupcount;
        var groupstartcol = this._getGroupsStartCol();
        var format = this._curFormat;
        var dataset = this._binddataset;

        this._is_grid_sort_grouping = true;

        if (!b_sort_act)
        {
            var enableevt = dataset.enableevent;
            if (groupsortobj.groupstr != "")
            {
                if (this._grouprowtype == undefined)
                    this._grouprowtype = dataset._p_grouprowtype;

                if (this._grouprowtype != "header")
                {
                    dataset._p_enableevent = false;
                    dataset.grouprowtype = "both";
                    dataset._p_enableevent = enableevt;
                }
            }
            else
            {
                if (this._grouprowtype != undefined)
                {
                    dataset._p_enableevent = false;
                    dataset.grouprowtype = this._grouprowtype;
                    dataset._p_enableevent = enableevt;
                }
            }

            if (groupstartcol < 0)
                return;

            this._autofitcol_rate = [];

            var group_info = format._group_info;
            if (group_info)
            {
                for (var i = 0; i < groupcount; i++)
                {
                    var addcol = groupstartcol + i;

                    format.insertContentsCol(group_info.area, addcol, false, i);
                    format.setFormatColProperty(addcol, "band", group_info.area);

                    var bodygroupcells = this._getRowGroupControlCells();
                    var limitsize = this._getMaxColSize(bodygroupcells, addcol, 0);

                    format.setFormatColProperty(addcol, "size", Math.max(group_info.colsize, limitsize));
                }

                this._clearTempBand();
                this._clearBindTypeFlag();
                this._recreate();

                if (groupcount == 0)
                {
                    this._treeCellinfo = null;
                    this._setTree(false, true);
                }
            }
        }

        this.clearSelect();

        dataset.set_keystring(groupsortstr);
        this._is_grid_sort_grouping = undefined;

        this.set_enableredraw(redraw);
    };

    _pGrid._applyFilter = function ()
    {
        this._is_grid_filtering = true;
        this._binddataset.set_filterstr(this._getFilterFullStr());
        this._is_grid_filtering = undefined;
    };

    _pGrid._removeGroupCol = function ()
    {
        this._clearFilterSortInfo();
        this._clearMultiSortIcons();

        var format = this._curFormat;
        var cols = format._cols;

        if (this._groupcount > 0)
        {
            var redraw = this._p_enableredraw;
            this.set_enableredraw(false);

            for (var i = cols.length - 1; i >= 0; i--)
            {
                if (cols[i].groupcol >= 0)
                {
                    var col = this._curFormat.deleteContentsCol(null, i);
                    if (col >= 0)
                    {
                        this._clearTempBand();
                        this._clearBindTypeFlag();
                        this._recreate();
                    }
                }
            }

            this._groupcount = 0;
            this.set_enableredraw(redraw);
        }
    };

    _pGrid._applyMultiSortIcons = function (cellidx, sort)
    {
        if (!this._sortinfo)
            this._sortinfo = [];

        var sortinfo = this._sortinfo;
        var idx = -1;

        for (var i = 0; i < sortinfo.length; i++)
        {
            if (sortinfo[i].cellidx == cellidx)
            {
                idx = i;
                break;
            }
        }

        if (sort == "ascending" || sort == "descending")
        {
            var info = sortinfo[idx];
            if (info)
                info.sort = sort;
            else
                sortinfo.push({ cellidx: cellidx, sort: sort });
        }
        else
        {
            var info = sortinfo[idx];
            if (info)
            {
                var rowctrl = this._headBand._get_rows()[0];
                var cells = rowctrl._cells;

                cells[info.cellidx]._clearSortStatus();
                cells[info.cellidx]._refinfo._sortidx = "";
                cells[info.cellidx]._updateAll();
                sortinfo.splice(idx, 1);
            }
        }

        if (this._headBand)
        {
            var rowctrl = this._headBand._get_rows()[0];
            var cells = rowctrl._cells;

            if (sortinfo.length > 1)
            {
                for (i = 0; i < sortinfo.length; i++)
                {
                    cells[sortinfo[i].cellidx]._refinfo._sortidx = i + 1;
                    cells[sortinfo[i].cellidx]._updateAll();
                }
            }
            else if (sortinfo.length == 1 && sort != "ascending" && sort != "descending")
            {
                for (i = 0; i < sortinfo.length; i++)
                {
                    cells[sortinfo[i].cellidx]._refinfo._sortidx = "";
                    cells[sortinfo[i].cellidx]._updateAll();
                }
            }
        }
    };

    _pGrid._clearMultiSortIcons = function (except_cellidx)
    {
        if (this._headBand)
        {
            var sortinfo = this._sortinfo;
            var rowctrl = this._headBand._get_rows()[0];
            var cells = rowctrl._cells;

            if (sortinfo)
            {
                for (let i = 0; i < sortinfo.length; i++)
                {
                    cells[sortinfo[i].cellidx]._refinfo._sortidx = "";
                    cells[sortinfo[i].cellidx]._updateAll();

                    if (except_cellidx == undefined || sortinfo[i].cellidx != except_cellidx)
                        sortinfo.splice(i--, 1);
                }

                if (this._sortinfo.length == 0)
                    this._sortinfo = null;
            }

            for (let i = 0; i < cells.length; i++)
            {
                if (except_cellidx == undefined || i != except_cellidx)
                    cells[i]._clearSortStatus();
            }
        }
    };

    _pGrid.groupBy = function (columns)
    {
        if (!columns)
            return;

        if (columns.length)
        {
            var gcells = this._getGroupColumnCells();
            var vals = [];

            for (var i = 0; i < gcells.length; i++)
            {
                for (var j = 0; j < columns.length; j++)
                {
                    var gcol = gcells[i]._getAttrValue(gcells[i]._p_groupcolumn, -1);
                    columns[j] = columns[j].trim();

                    if (columns[j].trim() == gcol)
                    {
                        vals.push(columns[j]);
                        break;
                    }
                }
            }

            if (vals.length)
            {
                this._groupstr = vals.join(",");

                if (this._groupBar)
                    this._groupBar._updateAll();

                this._applyGroupSort();
            }
        }
    };

    _pGrid.getGroupingColumnIds = function ()
    {
        var retn = [];
        if (this._groupstr)
            retn = this._groupstr.split(",");

        return retn;
    };

    _pGrid.getGroupInfo = function ()
    {
        var retn = { headcelltexts: [], groupcolumns: [] };
        var cells = this._getGroupColumnCells();

        for (var i = 0; i < cells.length; i++)
        {
            var text = cells[i]._getDisplayText(-1);
            var gcol = cells[i]._getAttrValue(cells[i]._p_groupcolumn, -1);

            retn.headcelltexts.push(text);
            retn.groupcolumns.push(gcol);
        }

        return retn;
    };

    _pGrid.clearGroup = function ()
    {
        this._clearGroup();
    };

    _pGrid._clearGroup = function (is_keep_keystring)
    {
        if (this._groupstr)
        {
            this._groupstr = "";

            if (is_keep_keystring)
                this._removeGroupCol();
            else
                this._applyGroupSort();

            this._resetTreeCellinfo(true);
        }
        else
        {
            this._clearSortInfo();
            this._clearMultiSortIcons();
        }
    };

    _pGrid.clearSort = function ()
    {
        this._clearSortInfo();
        this._clearMultiSortIcons();
        this._applyGroupSort(true);
    };

    _pGrid._clearFilterSortInfo = function ()
    {
        var format = this._curFormat;
        var cells = format._headcells;

        if (!cells)
            return;

        for (var i = 0; i < cells.length; i++)
        {
            cells[i]._filterstr = "";
            cells[i]._sortstr = "";
            cells[i]._sortstatus = "";
            cells[i]._filtersaveinfo = null;
        }
    };

    _pGrid._clearFilterInfo = function ()
    {
        var format = this._curFormat;
        var cells = format._headcells;

        if (!cells)
            return;

        for (var i = 0; i < cells.length; i++)
        {
            cells[i]._filterstr = "";
            cells[i]._filtersaveinfo = null;
        }
    };

    _pGrid._clearSortInfo = function ()
    {
        var format = this._curFormat;

        if (!format)
            return;

        var cells = format._headcells;

        if (!cells)
            return;

        for (var i = 0; i < cells.length; i++)
        {
            cells[i]._sortstr = "";
            cells[i]._sortstatus = "";
        }
    };

    _pGrid.clearFilter = function ()
    {
        this._clearFilterInfo();
        this._applyFilter();
    };

    _pGrid._getImageCallbackfunc = function (autosizetype)
    {
        return (autosizetype != "none" ? this._on_sizeloading_autosize : this._on_sizeloading);
    };

    _pGrid.blinkCell = function (row, cell_columns, /* nPivot, */ keepsec, blinkcnt)
    {
        if (keepsec === undefined || keepsec === null || keepsec === "")
            return;

        if (blinkcnt === undefined || blinkcnt === null || blinkcnt === "")
            return;

        keepsec = +keepsec;
        blinkcnt = +blinkcnt;

        if (keepsec < 0 || blinkcnt < 0)
            return;

        if (!this._blinktask)
            this._blinktask = {};

        if (!this._blinktasklist)
            this._blinktasklist = {};

        var cnt = blinkcnt * 2;
        var sec = keepsec / cnt;

        var i, n, cellinfo, bindcellinfos, blinktask;
        var cellinfos = [];
        var is_blinkinfos = false;

        cell_columns = nexacro._isString(cell_columns) ? cell_columns.split(",") : [cell_columns];
        for (i = 0, n = cell_columns.length; i < n; i++)
        {
            if (typeof (cell_columns[i]) == "string")
            {
                bindcellinfos = this._getBindTextCellInfo(cell_columns[i].trim());
                if (bindcellinfos[1])
                {
                    cellinfos = cellinfos.concat(bindcellinfos[0]);
                }
            }
            else
            {
                cellinfos = [this._curFormat._bodycells[cell_columns]];
            }

            if (cellinfos.length)
            {
                is_blinkinfos = true;
            }
        }

        if (is_blinkinfos)
        {
            var blink_cancel = keepsec === 0 || blinkcnt === 0;
            if (blink_cancel)
            {
                for (i = 0, n = cellinfos.length; i < n; i++)
                {
                    cellinfo = cellinfos[i];
                    cellinfo._blinked_status[row] = false;

                    var cell = this._getCurrentBodyCell(row, cellinfo._cellidx);
                    if (cell)
                    {
                        cell._changeUserStatus("blinked", false);
                    }

                    delete this._blinktasklist[row + "_" + cellinfo._cellidx];
                }
            }
            else
            {
                var callback = function (id)
                {
                    var row, cell, task;
                    var is_taskempty = true;
                    for (i in this._blinktasklist)
                    {
                        if (this._blinktasklist.hasOwnProperty(i))
                        {
                            task = this._blinktasklist[i];
                            row = i.split("_")[0];
                            if (task.taskid == id && task.cnt > 0)
                            {
                                is_taskempty = false;
                                task.blinkstatus = !task.blinkstatus;
                                task.cellinfo._blinked_status[row] = task.blinkstatus;

                                cell = this._getCurrentBodyCell(row, task.cellinfo._cellidx);
                                if (cell)
                                    cell._changeUserStatus("blinked", task.blinkstatus);

                                if ((task.cnt -= 1) == 0)
                                {
                                    is_taskempty = true;
                                    this._blinktasklist[i] = undefined;
                                    delete this._blinktasklist[i];
                                }
                            }
                        }
                    }

                    if (is_taskempty)
                    {
                        this._blinktask[id].destroy();
                        this._blinktask[id] = undefined;
                        delete this._blinktask[id];
                    }
                };

                blinktask = new nexacro._CallbackTimer(this, callback, sec);
                this._blinktask[blinktask.id] = blinktask;

                for (i = 0, n = cellinfos.length; i < n; i++)
                {
                    cellinfo = cellinfos[i];
                    this._blinktasklist[row + "_" + cellinfo._cellidx] = {
                        "taskid": blinktask.id,
                        "cellinfo": cellinfo,
                        "cnt": cnt,
                        "blinkstatus": false
                    };
                }

                blinktask.start();
            }
        }
    };

    _pGrid.blinkCellByInterval = function (row, cell_columns, /* nPivot, */ interval, blinkcnt)
    {
        if (interval === undefined || interval === null || interval === "")
            return;

        if (blinkcnt === undefined || blinkcnt === null || blinkcnt === "")
            return;

        interval = +interval;
        blinkcnt = +blinkcnt;

        if (interval < 0 || blinkcnt < 0)
            return;

        if (!this._blinktasklist)
            this._blinktasklist = {};

        var KEEP_SECOND = 500;
        var cnt = blinkcnt * 2;

        var i, n, cellinfo, bindcellinfos;
        var cellinfos = [];
        var blinktask;
        var is_blinkinfos = false;
        var cell;

        cell_columns = nexacro._isString(cell_columns) ? cell_columns.split(",") : [cell_columns];
        for (i = 0, n = cell_columns.length; i < n; i++)
        {
            if (typeof (cell_columns[i]) == "string")
            {
                bindcellinfos = this._getBindTextCellInfo(cell_columns[i].trim());
                if (bindcellinfos[1])
                {
                    cellinfos = cellinfos.concat(bindcellinfos[0]);
                }
            }
            else
            {
                cellinfos = [this._curFormat._bodycells[cell_columns]];
            }

            if (cellinfos.length)
            {
                is_blinkinfos = true;
            }
        }

        if (is_blinkinfos)
        {
            var blink_cancel = interval === 0 || blinkcnt === 0;
            if (blink_cancel)
            {
                for (i = 0, n = cellinfos.length; i < n; i++)
                {
                    cellinfo = cellinfos[i];
                    cellinfo._blinked_status[row] = false;
                    cell = this._getCurrentBodyCell(row, cellinfo._cellidx);
                    if (cell)
                    {
                        cell._changeUserStatus("blinked", false);
                    }
                    delete this._blinktasklist[row + "_" + cellinfo._cellidx];
                }
            }
            else
            {
                var callback = function (id)
                {
                    var row, cell, task;

                    for (i in this._blinktasklist)
                    {
                        if (this._blinktasklist.hasOwnProperty(i))
                        {
                            task = this._blinktasklist[i];
                            row = i.split("_")[0];
                            if (task.taskid == id && task.cnt > 0)
                            {
                                task.cnt--;

                                task.blinkstatus = !task.blinkstatus;
                                task.cellinfo._blinked_status[row] = task.blinkstatus;

                                cell = this._getCurrentBodyCell(row, task.cellinfo._cellidx);
                                if (cell)
                                    cell._changeUserStatus("blinked", task.blinkstatus);

                                if (task.cnt > 0)
                                {
                                    blinktask = nexacro._OnceCallbackTimer.callonce(this, callback, task.cnt % 2 == 0 ? task.interval : KEEP_SECOND);
                                    task.taskid = blinktask.id;
                                }
                                else
                                {
                                    this._blinktasklist[i] = undefined;
                                    delete this._blinktasklist[i];
                                }
                            }
                        }
                    }
                };

                blinktask = nexacro._OnceCallbackTimer.callonce(this, callback, KEEP_SECOND);

                for (i = 0, n = cellinfos.length; i < n; i++)
                {
                    cellinfo = cellinfos[i];
                    this._blinktasklist[row + "_" + cellinfo._cellidx] = {
                        "taskid": blinktask.id,
                        "cellinfo": cellinfo,
                        "cnt": cnt,
                        "interval": interval,
                        "blinkstatus": false
                    };
                }
            }
        }
    };

    _pGrid._start_perftime = null;
    _pGrid._end_perftime = null;
    _pGrid._startScrollTimeCheck = function ()
    {
        this._start_perftime = this._fn_CheckTime();
    };

    _pGrid._endScrollTimeCheck = function ()
    {
        this._end_perftime = this._fn_CheckTime();
        var result = this._fn_diffTime(this._start_perftime, this._end_perftime, "ss") + "초";

        this._start_perftime = null;
        this._end_perftime = null;

        return result;
    };

    _pGrid._fn_CheckTime = function ()
    {
        function fn_Right(strString, nSize)
        {
            var nStart = String(strString).length;
            var nEnd = Number(nStart) - Number(nSize);
            var rtnVal = strString.substring(nStart, nEnd);

            return rtnVal;
        }

        var objDate = new Date();
        var strTime = fn_Right("0" + objDate.getHours(), 2);
        strTime += fn_Right("0" + objDate.getMinutes(), 2);
        strTime += fn_Right("0" + objDate.getSeconds(), 2);
        strTime += fn_Right("0" + objDate.getMilliseconds(), 3);

        return strTime;
    };

    _pGrid._fn_diffTime = function (sStartTime, sEndTime, sType)
    {
        sStartTime = "" + sStartTime;
        sEndTime = "" + sEndTime;
        var nFrom_HH = nexacro.toNumber(sStartTime.substring(0, 2));
        var nFrom_mm = nexacro.toNumber(sStartTime.substring(2, 4));
        var nFrom_ss = nexacro.toNumber(sStartTime.substring(4, 6));
        var nFrom_ms = nexacro.toNumber(sStartTime.substring(6, 9));

        var nTo_HH = nexacro.toNumber(sEndTime.substring(0, 2));
        var nTo_mm = nexacro.toNumber(sEndTime.substring(2, 4));
        var nTo_ss = nexacro.toNumber(sEndTime.substring(4, 6));
        var nTo_ms = nexacro.toNumber(sEndTime.substring(6, 9));

        var nFromTotal_ss = (nFrom_HH * 3600) + (nFrom_mm * 60) + nFrom_ss + (nFrom_ms / 1000);
        var nToTotal_ss = (nTo_HH * 3600) + (nTo_mm * 60) + nTo_ss + (nTo_ms / 1000);

        if (sType == "HH")
        {
            return (Math.floor((nToTotal_ss - nFromTotal_ss) / 3600));
        }
        else if (sType == "mm") 
        {
            return (Math.floor((nToTotal_ss - nFromTotal_ss) / 60));
        }
        else if (sType == "ss") 
        {
            return nexacro.round((nToTotal_ss - nFromTotal_ss), 3);
        }
    };

    nexacro._defineProperties(_pGrid, _pGrid._properties);

    _pGrid = null;

    //===============================================================
    // nexacro._GridGroupControl : MultiCombo
    // description : use Event Notifiers, style control - controlType
    //===============================================================
    nexacro._GridGroupControl = function (id, left, top, width, height, minheight, parent)
    {
        nexacro.MultiCombo.call(this, id, left, top, width, height, null, null, null, null, minheight, null, parent);

        this._p_tabstop = false;
        this._grid = parent;
    };

    var _pGridGroupControl = nexacro._createPrototype(nexacro.MultiCombo, nexacro._GridGroupControl);
    nexacro._GridGroupControl.prototype = _pGridGroupControl;

    _pGridGroupControl._type_name = "GridGroupControl";
    _pGridGroupControl._is_subcontrol = true;
    _pGridGroupControl._is_nc_control = true;


    //===============================================================
    // nexacro._GridGroupControl : Create & Destroy & Update
    //===============================================================
    _pGridGroupControl.on_destroy_contents = function ()
    {
        nexacro.MultiCombo.prototype.on_destroy_contents.call(this);
        this._grid = null;
    };

    _pGridGroupControl._recalcLayout = function ()
    {
        if (this._is_created_contents)
        {
            var dropbutton = this._p_dropbutton;
            var multicombotagbox = this._p_multicombotagbox;

            var client_left = this._getClientLeft();
            var client_top = this._getClientTop();
            var client_width = this._getClientWidth();
            var client_height = this._getClientHeight();

            var dropbutton_size = this._p_buttonsize;
            var dropbutton_width, dropbutton_height;

            if (dropbutton_size == undefined)
            {
                dropbutton_width = dropbutton._on_getFitSize()[0];
                dropbutton_height = client_height;
            }
            else
            {
                if (typeof (dropbutton_size) == "number")
                {
                    dropbutton_width = dropbutton_height = dropbutton_size;
                }
                else
                {
                    dropbutton_size = dropbutton_size.split(" ");
                    dropbutton_width = +dropbutton_size[0];
                    dropbutton_height = (dropbutton_size[1]) ? +dropbutton_size[1] : client_height;
                }
            }

            if (dropbutton_width > client_width)
            {
                dropbutton_width = client_width;
            }
            if (dropbutton_height > client_height)
            {
                dropbutton_height = client_height;
            }

            if (dropbutton)
            {
                var btn_left = client_width - dropbutton_width;
                var btn_top = client_top;

                if (dropbutton_height < client_height)
                    btn_top = (client_height - dropbutton_height) / 2;

                dropbutton.move(client_left, btn_top, dropbutton_width, dropbutton_height, null, null);
            }

            if (multicombotagbox)
            {
                var tagbox_width, tagbox_height;
                var tagbox_left = dropbutton ? (dropbutton._adjust_left + dropbutton._adjust_width) : 0;

                tagbox_width = client_width - dropbutton_width;
                tagbox_height = client_height;

                multicombotagbox.move(tagbox_left, client_top, tagbox_width, tagbox_height, null, null);
                multicombotagbox._recalcLayout();
            }
            this._autoHeight();
        }
    };

    _pGridGroupControl.on_fire_ondropdown = function (obj)
    {
        return this._grid.on_fire_ondropdown(obj);
    };

    _pGridGroupControl.on_fire_oncloseup = function (obj, beforeIndex, beforeText, beforeValue, afterIndex, afterText, afterValue, isSelect)
    {
        nexacro.MultiCombo.prototype.on_fire_oncloseup.call(this, obj, beforeIndex, beforeText, beforeValue, afterIndex, afterText, afterValue, isSelect);
        this._grid.on_fire_oncloseup(obj, beforeText, afterText, beforeValue, afterValue, isSelect);
        this._setDataset();
    };

    _pGridGroupControl.on_fire_onitemchanged = function (obj, preindex, pretext, prevalue, postindex, posttext, postvalue)
    {
        if (this._isPopupVisible() == false)
            this._setDataset();

        return (nexacro.MultiCombo.prototype.on_fire_onitemchanged.call(this, obj, preindex, pretext, prevalue, postindex, posttext, postvalue));
    };

    _pGridGroupControl._isEnable = function ()
    {
        if (this._grid)
            return this._grid._enable;

        return true;
    };

    _pGridGroupControl._getGroupColumnCells = function ()
    {
        return this._grid._getGroupColumnCells();
    };

    _pGridGroupControl._autoHeight = function ()
    {
        var tagbox = this._p_multicombotagbox;

        if (tagbox)
        {
            var height = 0;
            if (tagbox._multicombotags)
            {
                for (var tag in tagbox._multicombotags)
                {
                    height = Math.max(height, tagbox._multicombotags[tag]._adjust_top + tagbox._multicombotags[tag]._adjust_height);
                }
            }
            var padd = tagbox._getCurrentStylePadding();
            height += padd ? (padd.top + padd.bottom) : 0;

            padd = this._getCurrentStylePadding();
            height += padd ? (padd.top + padd.bottom) : 0;

            var bord = this._getCurrentStyleBorder();
            height += bord ? (bord.top._width + bord.bottom._width) : 0;

            if (this._adjust_height != height)
            {
                height = Math.max(this.minheight, height);
                this.set_height(height);
                this.parent.on_change_groupbarHeight();
            }
        }
    };

    _pGridGroupControl._updateValue = function ()
    {
        var v = this._grid._groupstr;
        var _value = this._p_value;

        this.set_value(v);

        if (v === undefined && _value === undefined)
        {
            if (this.applyto_bindSource("value", v))
            {
                this._p_value = v;
                this.on_apply_value(v);
                this.redraw();
            }
        }
    };

    _pGridGroupControl._updateInnerDataset = function ()
    {
        var cells = this._getGroupColumnCells();

        if (!cells.length)
            return;

        var opts = [];

        for (var i = 0; i < cells.length; i++)
        {
            var text = cells[i]._getDisplayText(-1);
            var gcol = cells[i]._getAttrValue(cells[i]._p_groupcolumn, -1);

            opts.push([text, gcol]);
        }

        var innerds = this._createInnerDataset(opts);
        this.setInnerDataset(innerds);
    };

    _pGridGroupControl._confirmValue = function ()
    {
        if (this._p_readonly)
            return;

        var multicombolist = this.multicombolist;
        var ds = this._selectDataset();
        var pre_value = this._default_value;
        var pre_text = this._default_text;
        var pre_index = this._default_index;

        var cur_value = this._p_value;
        var cur_text = this.text;
        var cur_index = this.index;
        var rawidx, curobj;

        if (this._isPopupVisible())
        {
            curobj = multicombolist._get_rowobj_status("mouseover", "status") || multicombolist._get_rowobj_status("selected", "userstatus");
            if (curobj)
            {
                cur_index = curobj.index;
            }
        }

        if (cur_index >= 0)
        {
            if (this.type == "filter" || this.type == "filterlike" || this.type == "caseifilter" || this.type == "caseifilterlike")
            {
                rawidx = this._getRawIndex(ds, cur_index);
                rawidx = (rawidx == -1) ? cur_index : rawidx;
                ds.set_filterstr("");
            }
            else
            {
                rawidx = cur_index;
            }
        }
        else
        {
            rawidx = cur_index;
        }

        if (this.index != rawidx)
        {
            cur_value = this._getItemValue(rawidx);
            cur_text = this._getItemText(rawidx);
            cur_index = rawidx;

            if (!this._on_value_change(pre_index, pre_text, pre_value, cur_index, cur_text, cur_value))
            {
                this._setEditValue(this.text);
                cur_value = pre_value;
                cur_text = pre_text;
                cur_index = pre_index;
            }
        }

        this._setDefaultProps(cur_index, cur_value, cur_text);
    };

    _pGridGroupControl._selectDataset = function (bInit)
    {
        if (this._displaymode)
            return this._innerdataset;

        return nexacro.MultiCombo.prototype._selectDataset.call(this, bInit);
    };

    _pGridGroupControl._getDlgCode = function (keycode, altKey, ctrlKey, shiftKey)
    {
        var retn = nexacro.MultiCombo.prototype._getDlgCode.call(this, keycode, altKey, ctrlKey, shiftKey);
        retn.want_tab = (this._grid ? this._grid._acceptstab : retn.want_tab);

        return retn;
    };

    _pGridGroupControl._createPopupControl = function ()
    {
        var popupcontrol = this._popupcontrol;
        if (!popupcontrol)
        {
            popupcontrol = this._popupcontrol = new nexacro._GridMultiComboPopupControl("grouppopup", 0, 0, 0, 0, null, null, null, null, null, null, this);
            popupcontrol._setType(this.popuptype);

            popupcontrol.createComponent(true);
        }
    };

    _pGridGroupControl._createInnerDataset = function (opts)
    {
        var innerds = new nexacro.NormalDataset("filter_combo_innerdataset", this);
        var contents = "<ColumnInfo><Column id=\"codecolumn\" size=\"256\"/><Column id=\"datacolumn\" size=\"256\"/></ColumnInfo><Rows>";

        for (var i = 0; i < opts.length; i++)
        {
            contents += "<Row>";
            contents += "<Col id=\"codecolumn\">" + opts[i][1] + "</Col><Col id=\"datacolumn\">" + opts[i][0] + "</Col>";
            contents += "</Row>";
        }

        innerds._setContents(contents);
        return innerds;
    };

    _pGridGroupControl._setDataset = function ()
    {
        var grid = this._grid;
        var retn = true;

        if (grid._groupstr != this.value)
        {
            grid._groupstr = this.value;
            grid._applyGroupSort();
        }
        return retn;
    };

    _pGridGroupControl._updateAll = function ()
    {
        var grid = this._grid;
        this.value = grid._groupstr;
    };


    _pGridGroupControl = null;

    //===============================================================
    // nexacro._GridMultiComboPopupControl
    //===============================================================
    nexacro._GridMultiComboPopupControl = function (id, left, top, width, height, right, bottom, minwidth, maxwidth, minheight, maxheight, parent)
    {
        nexacro._MultiComboPopupControl.call(this, id, left, top, width, height, right, bottom, minwidth, maxwidth, minheight, maxheight, parent);
    };

    var _pGridMultiComboPopupControl = nexacro._createPrototype(nexacro._MultiComboPopupControl, nexacro._GridMultiComboPopupControl);
    nexacro._GridMultiComboPopupControl.prototype = _pGridMultiComboPopupControl;


    /* internal variable */
    _pGridMultiComboPopupControl._is_subcontrol = true;

    //===============================================================
    // nexacro._GridMultiComboPopupControl : Override
    //===============================================================
    _pGridMultiComboPopupControl._getPopupParentPos = function ()
    {
        var combo = this._p_parent;

        var rect;
        var bandrect;
        if (combo._p_parent._getPositionInRootComponent)
        {
            var ret = combo._p_parent._getPositionInRootComponent(combo);
            rect = ret[0];
            bandrect = ret[1];

            var combo_size = [rect.width, rect.height];
            var combo_elem_pos = nexacro._getElementPositionInFrame(combo.getElement(), true);
            var xgap = 0;
            var ygap = 0;
            if (0 > bandrect.orgl)
            {
                xgap = Math.abs(bandrect.orgl);
            }
            if (0 > bandrect.orgt)
            {
                ygap = Math.abs(bandrect.orgt);
            }


            //var x,y,
            return { "x": combo_elem_pos.x, "y": combo_elem_pos.y, "width": combo_size[0], "height": combo_size[1], "xgap": xgap, "ygap": ygap };
        }
        else
            return nexacro._MultiComboPopupControl.prototype._getPopupParentPos.call(this);
    };

    _pGridMultiComboPopupControl = null;
};